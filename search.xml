<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>&lt;游戏算法&gt;Unity 实现2D游戏中的四叉树空间管理和矩形碰撞检测(2)</title>
      <link href="/2019/MyLearn-QTree2/"/>
      <url>/2019/MyLearn-QTree2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/ConfuseL%E5%9B%9B%E5%8F%89%E6%A0%91%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.gif" alt=""></p><h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><h2 id="携带碰撞盒的游戏实体QEntity以及实体管理脚本QEnityManager"><a href="#携带碰撞盒的游戏实体QEntity以及实体管理脚本QEnityManager" class="headerlink" title="携带碰撞盒的游戏实体QEntity以及实体管理脚本QEnityManager"></a>携带碰撞盒的游戏实体<code>QEntity</code>以及实体管理脚本<code>QEnityManager</code></h2><p>​    前一篇博客中，四叉树部分基本完成了，现在就剩一个带有碰撞盒，并且实时检测的MONO游戏脚本，还有一个管理类。</p><h3 id="实体管理脚本QEntityManager"><a href="#实体管理脚本QEntityManager" class="headerlink" title="实体管理脚本QEntityManager"></a>实体管理脚本<code>QEntityManager</code></h3><p>​    在实现<code>QEntity</code>之前，我们需要实现管理脚本。管理脚本需要管理<code>id</code>到Qobj以及Tranform的映射/字典，这样我们可以通过id去控制各个实体的矩形以及位置信息。</p><p>​    当然最重要的就是，管理游戏四叉树的根节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class QEntityManager  &#123;</span><br><span class="line">    //单例模式</span><br><span class="line">    public static QEntityManager Instance &#123; get &#123; if (qEntityManager == null) qEntityManager = new QEntityManager();return qEntityManager; &#125; &#125;</span><br><span class="line">    private static QEntityManager  qEntityManager;</span><br><span class="line">    //用于自增的id计数</span><br><span class="line">    private int cnt = 0;</span><br><span class="line">    //映射的字典</span><br><span class="line">    Dictionary&lt;int, QObj&gt; EntityMap;</span><br><span class="line">    Dictionary&lt;int, Transform&gt; TransfromMap;</span><br><span class="line">    //四叉树的根节点</span><br><span class="line">    public QuadTree quadTree;</span><br><span class="line"></span><br><span class="line">    //用于临时引用 减少内存消耗</span><br><span class="line">    private QObj tempQObj;</span><br><span class="line">    private Transform tempTransform;</span><br><span class="line"></span><br><span class="line">    //构造函数 初始化两个字典</span><br><span class="line">    public QEntityManager()</span><br><span class="line">    &#123;</span><br><span class="line">        EntityMap = new Dictionary&lt;int, QObj&gt;();</span><br><span class="line">        TransfromMap = new Dictionary&lt;int, Transform&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化函数 给定四叉树根节点</span><br><span class="line">    public void Init(QuadTree quadTree)</span><br><span class="line">    &#123;</span><br><span class="line">       this.quadTree = quadTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //注册一个游戏实体 </span><br><span class="line">    public void Register(QObj qObj,Transform transform)</span><br><span class="line">    &#123;</span><br><span class="line">        qObj.SetID(++cnt);//设置ID</span><br><span class="line">        EntityMap.Add(qObj.id, qObj);//添加到字典中</span><br><span class="line">        TransfromMap.Add(qObj.id, transform);</span><br><span class="line">        quadTree.AddObj(qObj);//添加到树中</span><br><span class="line">    &#125;</span><br><span class="line">    //获得碰撞盒信息</span><br><span class="line">    public QObj GetPiont(ref int id)</span><br><span class="line">    &#123;</span><br><span class="line">        return EntityMap[id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面实现了对四叉树的静态管理，能够注册游戏实体，将<code>Qobj</code>和<code>Transforms</code>作为参数注册，为什么不用封装的<code>QEntity</code>呢，我们在前一篇实现的碰撞盒检测，以及四叉树中的象限检测，都是通过<code>QObj</code>为操作单位的，而不是<code>QEntity</code>，然后这么分开也是为了位移和碰撞盒分离，好控制一些，也为了在今后学习ECS的时候方便更新代码吧。</p><h4 id="游戏物体的移动"><a href="#游戏物体的移动" class="headerlink" title="游戏物体的移动"></a>游戏物体的移动</h4><p>​    然后该考虑移动了，我们的游戏物体会出现移动的情况，我们需要实现游戏物体自发的移动而导致四叉树更新的行为，同时也要实现从四叉树空控制游戏物体位移的行为(即修复发生碰撞的游戏物体)。</p><h5 id="主动移动的游戏物体"><a href="#主动移动的游戏物体" class="headerlink" title="主动移动的游戏物体"></a>主动移动的游戏物体</h5><p>​    作为主角，大部分游戏都是可移动的，移动的过程中，就要时刻触发四叉树空间的象限检测，一旦某物体超出某象限，就要重新规划一下管理的游戏物体。</p><p>​    但是Unity的移动只能保证自身物体移动，而我们设计的碰撞盒并不会实时更新，所以我们需要在实体管理脚本中添加一个函数，当游戏实体移动时，同步自己的碰撞盒坐标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    //在实体的循环中调用，是物体主动移动，这时候需要更改碰撞盒的位置</span><br><span class="line">//Vector3 point 这个是游戏的坐标</span><br><span class="line">    public void ChangePoint( int id, Vector3 point)//改变点的信息</span><br><span class="line">    &#123;</span><br><span class="line">        tempQObj = EntityMap[id];</span><br><span class="line">        tempQObj.rect.o.x = point.x;</span><br><span class="line">        tempQObj.rect.o.y = point.z;</span><br><span class="line">        //这个是绘制在Scene窗口的一个类</span><br><span class="line">        DrawLine.Instance.ChangeADrawObj(ref id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="被动移动的游戏物体"><a href="#被动移动的游戏物体" class="headerlink" title="被动移动的游戏物体"></a>被动移动的游戏物体</h5><p>​    当游戏物体发生碰撞的时候，我们需要修复它的坐标，因此我们也需要在实体管理脚本种添加一个函数，当游戏物体发生碰撞时，修复自身的游戏物体坐标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    //在实体的碰撞修复时调用，是物体被动移动，这时候需要更改物体的位置</span><br><span class="line">//Point point 这是我们碰撞盒保存的碰撞坐标</span><br><span class="line">    public void ChangePoint(int id, Point point)//改变点的信息并移动</span><br><span class="line">    &#123;</span><br><span class="line">        tempQObj = EntityMap[id];</span><br><span class="line">        tempTransform = TransfromMap[id];</span><br><span class="line">        tempQObj.rect.o.x = point.x;</span><br><span class="line">        tempQObj.rect.o.y = point.y;</span><br><span class="line">        tempTransform.position = new Vector3((float)point.x, tempTransform.position.y, (float)point.y);</span><br><span class="line">        //这个是绘制在Scene窗口的一个类</span><br><span class="line">        DrawLine.Instance.ChangeADrawObj(ref id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="游戏实体QEntity"><a href="#游戏实体QEntity" class="headerlink" title="游戏实体QEntity"></a>游戏实体<code>QEntity</code></h3><p>​    一个游戏实体<code>QEntity</code>，包含一个碰撞盒，提供监视面板设置的宽高，一个<code>bool</code>变量存储是否打开碰撞器。</p><p>​    在脚本初始化<code>Awake</code>的时候，我们查找我们绑定游戏实体的游戏物体是否有2D精灵图，如果有，我们直接从精灵图上获得宽高，否则，我们从监视面板上自己设置的宽高。</p><p>​    在脚本开始<code>Start</code>的时候，我们向实体管理脚本注册一个游戏实体。</p><p>​    接下来，我们在物理循环中，每一帧上传自己的位移操作给实体管理脚本，同时调用碰撞盒的碰撞检测算法，检测当前所属象限的所有物体是否发生碰撞，随后判断自身是否超出所属象限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class QEntity : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    public QObj self;</span><br><span class="line">    Point remain;//用来恢复的位置</span><br><span class="line">    [Range(1, 1000)]</span><br><span class="line">    public double weight;</span><br><span class="line">    [Range(1, 1000)]</span><br><span class="line">    public double hight;</span><br><span class="line">    public bool isTrigger &#123; set &#123; self.isTrigger = value; &#125; get &#123; return self.isTrigger; &#125; &#125;</span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        //优先读取图片的宽高</span><br><span class="line">        if(GetComponent&lt;SpriteRenderer&gt;()!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            self = new QObj(new Point(transform.position.x, transform.position.z), GetComponent&lt;SpriteRenderer&gt;().bounds.size.x, GetComponent&lt;SpriteRenderer&gt;().bounds.size.z );</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        self = new QObj(new Point(transform.position.x, transform.position.z), weight, hight);</span><br><span class="line">        self.isTrigger = isTrigger;</span><br><span class="line">        self.qEntity = this;</span><br><span class="line">        //初始化的时候，记录位置</span><br><span class="line">        remain = new Point(self.rect.o.x, self.rect.o.y);</span><br><span class="line">    &#125;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //向管理脚本注册</span><br><span class="line">        QEntityManager.Instance.Register(self,transform); ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        //主动更改位置信息</span><br><span class="line">        QEntityManager.Instance.ChangePoint(self.id, transform.position);</span><br><span class="line">        //判断是否超出当前节点位置</span><br><span class="line">        self.ISOutOfLocate();</span><br><span class="line">        //碰撞检测</span><br><span class="line">        self.locate.Collide(self,ref remain);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        self.qEntity = null;//解除循环引用</span><br><span class="line">        self = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制类DrawLine"><a href="#绘制类DrawLine" class="headerlink" title="绘制类DrawLine"></a>绘制类<code>DrawLine</code></h2><p>​    接下来就是绘制了，绘制只是更方便的观察四叉树以及碰撞过程，对于游戏本身是无所谓的，但是在演示的工程中，我们四叉树的初始化写在了<code>DrawLine</code>里，因此对于演示工程，它是必要的。</p><p>​    <code>DrawLine</code>同样是一个单例，它维护者需要绘制的四叉树矩阵链表，以及不同颜色的字典映射和游戏实体id到向量坐标的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class DrawLine: MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    public static DrawLine Instance;</span><br><span class="line">    List&lt;Vector3[]&gt; DrawRect;//这个存储的是四叉树的绘制矩形</span><br><span class="line">    Dictionary&lt;int,Vector3[]&gt; qObjs;//这个是游戏物体的碰撞盒矩形</span><br><span class="line">    Dictionary&lt;int,int&gt; colors;</span><br><span class="line">    List&lt;Color&gt; colorList;</span><br><span class="line">    Color temp;</span><br><span class="line"></span><br><span class="line">    //这里提供面板设置四叉树根节点的范围和每一层节点的最大管理数量</span><br><span class="line">    [Range(1,1e9f)]</span><br><span class="line">    public double x, y, w, h;</span><br><span class="line">    [Range(4,1e6f)]</span><br><span class="line">    public int maxSum;</span><br><span class="line"></span><br><span class="line">    // Use this for initialization</span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        DrawRect = new List&lt;Vector3[]&gt;();</span><br><span class="line">        qObjs = new Dictionary&lt;int, Vector3[]&gt;();</span><br><span class="line">        colors = new Dictionary&lt;int, int&gt;();</span><br><span class="line">        colorList = new List&lt;Color&gt;();</span><br><span class="line">        //随机颜色</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            colorList.Add(new Color(Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0f, 1f)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Instance = this;</span><br><span class="line">        //调用实体管理脚本初始化四叉树</span><br><span class="line">        QEntityManager.Instance.Init(new QuadTree(new Rect(x,y,w,h), maxSum,0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 每一帧绘制绘制的矩阵</span><br><span class="line">void Update () &#123;</span><br><span class="line">foreach(Vector3[] rects in DrawRect)//四叉树范围</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.DrawLine(rects[0], rects[1]);</span><br><span class="line">            Debug.DrawLine(rects[1], rects[2]);</span><br><span class="line">            Debug.DrawLine(rects[2], rects[3]);</span><br><span class="line">            Debug.DrawLine(rects[3], rects[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        foreach (KeyValuePair&lt;int, Vector3[]&gt; rects in qObjs)//游戏实体碰撞盒范围</span><br><span class="line">        &#123;</span><br><span class="line">            temp = colorList[colors[rects.Key]];</span><br><span class="line">            Debug.DrawLine(rects.Value[0], rects.Value[1], temp);</span><br><span class="line">            Debug.DrawLine(rects.Value[1], rects.Value[2], temp);</span><br><span class="line">            Debug.DrawLine(rects.Value[2], rects.Value[3], temp);</span><br><span class="line">            Debug.DrawLine(rects.Value[3], rects.Value[0], temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接下来，我们编写两个函数，用来在四叉树划分时添加四叉树节点的矩形，以及添加游戏实体时添加游戏实体的碰撞盒范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public void AddDrawObj(Rect rect)//四叉树的范围</span><br><span class="line">   &#123;</span><br><span class="line">       Vector3[] temp = new Vector3[4];//用数组表示</span><br><span class="line">     //表示矩形的四个点</span><br><span class="line">       temp[0] = new Vector3((float)(rect.o.x-rect.Rwidth), 1, (float)(rect.o.y - rect.Rheight));</span><br><span class="line">       temp[1] = new Vector3((float)(rect.o.x - rect.Rwidth), 1, (float)(rect.o.y + rect.Rheight));</span><br><span class="line">       temp[2] = new Vector3((float)(rect.o.x + rect.Rwidth), 1, (float)(rect.o.y + rect.Rheight));</span><br><span class="line">       temp[3] = new Vector3((float)(rect.o.x + rect.Rwidth), 1, (float)(rect.o.y - rect.Rheight));</span><br><span class="line">       DrawRect.Add(temp);</span><br><span class="line">   &#125;</span><br><span class="line">//游戏实体的碰撞盒范围</span><br><span class="line">   public void AddDrawObj(int id,Point point,ref double w,ref double h,int deep)</span><br><span class="line">   &#123;</span><br><span class="line">       if (colors.ContainsKey(id))//根据游戏实体所在的四叉树深度决定绘制的颜色</span><br><span class="line">           colors[id] = deep;</span><br><span class="line">       else</span><br><span class="line">           colors.Add(id, deep);//每种游戏实体id对应一种颜色</span><br><span class="line">       if (qObjs.ContainsKey(id))//如果游戏实体存在了就不添加</span><br><span class="line">           return;</span><br><span class="line">       Vector3[] temp = new Vector3[4];//同样是四个点</span><br><span class="line">       temp[0] = new Vector3((float)(point.x- w), 1, (float)(point.y - h));</span><br><span class="line">       temp[1] = new Vector3((float)(point.x - w), 1, (float)(point.y + h));</span><br><span class="line">       temp[2] = new Vector3((float)(point.x + w), 1, (float)(point.y + h));</span><br><span class="line">       temp[3] = new Vector3((float)(point.x + w), 1, (float)(point.y - h ));</span><br><span class="line">       qObjs.Add(id,temp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​    当然，我们的游戏实体是可以移动的，所以不光是在游戏实体管理脚本<code>QEntityManager</code>中添加更改实体坐标的方法，我们也要提供更改绘制坐标的方法。</p><p>​    我们只需要传入需要更新实体的id即可，我们根据id从游戏实体管理脚本<code>QEntityManager</code>中获取到它的碰撞盒信息，利用其信息来更新矩形坐标就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void ChangeADrawObj(ref int id)</span><br><span class="line">&#123;</span><br><span class="line">    if (!qObjs.ContainsKey(id))</span><br><span class="line">        return;</span><br><span class="line">    QObj obj = QEntityManager.Instance.GetPiont(ref id);</span><br><span class="line">    Vector3[] temp;</span><br><span class="line">    qObjs.TryGetValue(id, out temp);</span><br><span class="line">    temp[0].x = (float)(obj.rect.o.x - obj.rect.Rwidth);</span><br><span class="line">    temp[0].z = (float)(obj.rect.o.y - obj.rect.Rheight);</span><br><span class="line"></span><br><span class="line">    temp[1].x = (float)(obj.rect.o.x - obj.rect.Rwidth);</span><br><span class="line">    temp[1].z = (float)(obj.rect.o.y + obj.rect.Rheight);</span><br><span class="line"></span><br><span class="line">    temp[2].x = (float)(obj.rect.o.x + obj.rect.Rwidth);</span><br><span class="line">    temp[2].z = (float)(obj.rect.o.y + obj.rect.Rheight );</span><br><span class="line"></span><br><span class="line">    temp[3].x = (float)(obj.rect.o.x + obj.rect.Rwidth);</span><br><span class="line">    temp[3].z = (float)(obj.rect.o.y - obj.rect.Rheight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    现在整个代码的大致情况已经介绍完毕了，在学习和总结上感觉这些代码还是可以行的，对于实际使用不知道这些代码能否承受住大数量的运算和完全的碰撞逻辑正确。。。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    其实代码两三天就撸完了，但是博客很久才写，是因为临近期末要弄课设和考试没得时间。</p><p>​    四叉树和碰撞检测似乎是各游戏开发面试官常问的问题，自己实现一遍有助于理解，但可靠性不可预知了，希望今后有机会学习了ECS框架并重构这些代码。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;游戏算法&gt;Unity 实现2D游戏中的四叉树空间管理和矩形碰撞检测(1)</title>
      <link href="/2019/MyLearn-QTree1/"/>
      <url>/2019/MyLearn-QTree1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/ConfuseL%E5%9B%9B%E5%8F%89%E6%A0%91%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.gif" alt=""></p><hr><p><a href="https://github.com/ConfuseL/QuadTreeAndQEntity"><strong>源码和工程地址</strong></a></p><hr><h2 id="关于四叉树"><a href="#关于四叉树" class="headerlink" title="关于四叉树"></a>关于四叉树</h2><p>​    网上已经有很多四叉树的介绍以及作用详解了，在这里就不多论述，直接进入代码设计以及实现。</p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="象限"><a href="#象限" class="headerlink" title="象限"></a>象限</h4><p>​    首先确定象限的位置，可以利用整形枚举变量存储起来。因为四叉树是将空间划分为四个子部分，正好对应四个象限，当然因为只有四个象限，所以直接用下标0到3也可以。</p><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>​    由于是2D游戏中的空间管理，因此我们只考虑两个坐标轴，即X与Y轴，为了计算精度更高一些，可以使用<code>double</code>来存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Point</span><br><span class="line">&#123;</span><br><span class="line">    public double x;</span><br><span class="line">    public double y;</span><br><span class="line"></span><br><span class="line">    public Point(double x, double y)</span><br><span class="line">    &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为什么是<code>class</code>而不是<code>struct</code>呢，因为<code>struct</code>在C#中是结构体类型，而坐标这种东西，普遍运算量很大，如果每次传参都是值传递，那么会产生很多不必要的内存浪费。</p><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p>​    矩形是该算法的核心数据结构，不管是四叉树的空间表示，还是碰撞体的空间表示，都由它负责。</p><p>​    在正式写这篇博客之前，我的矩形是用两个点表示的，即对角线的两点，因为仅存两点在构造的时候很方便，但是发现在后面的包含检测和碰撞检测上需要进行拆分多次判断，效率不高，所以改成了点+半宽度+半高度的存储结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Rect  &#123;</span><br><span class="line"></span><br><span class="line">    public Point o;//中心点</span><br><span class="line">    public double Rwidth, Rheight;//半宽度 半高度</span><br><span class="line"></span><br><span class="line">    public Rect(double x, double y, double w, double h)//传参是全宽度和高度</span><br><span class="line">    &#123;</span><br><span class="line">        o = new Point(x, y);</span><br><span class="line">        Rwidth = w / 2;//在这里取一半</span><br><span class="line">        Rheight = h / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Rect(Point point, double w, double h)</span><br><span class="line">    &#123;</span><br><span class="line">        o = point;</span><br><span class="line">        Rwidth = w / 2;</span><br><span class="line">        Rheight = h / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="包含检测"><a href="#包含检测" class="headerlink" title="包含检测"></a>包含检测</h5><p>​    在这个矩形类中，我们需要实现一个方法，这个方法就是包含检测，我们要检测某个矩阵是否在这个矩阵中。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E7%9F%A9%E5%BD%A2%E5%8C%85%E5%90%AB.png" alt=""></p><p>​    如上图，小矩形刚好在大矩形内，W为大矩形的半宽度，w为小矩形的半宽度，那么我们可以根据这两个宽度差与两个矩形的中点X坐标差对比，来确定在X轴方向是否在大矩阵内。</p><p>​    同理，利用半高度和中点Y坐标差对比，来确定在Y轴方向是否在大矩阵内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public bool IsInclude(Rect target)</span><br><span class="line">&#123;</span><br><span class="line">    if((Mathf.Abs((float)(target.o.x-o.x))&lt;=(Rwidth-target.Rwidth))&amp;&amp;(Mathf.Abs((float)(target.o.y - o.y)) &lt;= (Rheight - target.Rheight)))</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四叉树管理的碰撞盒物体QObj"><a href="#四叉树管理的碰撞盒物体QObj" class="headerlink" title="四叉树管理的碰撞盒物体QObj"></a>四叉树管理的碰撞盒物体QObj</h2><p>​    在设计四叉树之前，我们需要先把管理的碰撞盒设计了，因为我们需要实现自己的碰撞检测，所以需要一个封装一个对应的碰撞盒类。</p><p>​    在这个QObj中(当然可以自己命名)，包含一个矩阵，代表自身的碰撞盒范围，包含一个id，用于快速检索管理这个携带碰撞盒的物体，还有一个四叉树节点，用来表示自己当前所属的四叉树节点。</p><p>​    同时我们需要自己实现类似<code>OnCollision</code>和<code>OnTrigger</code>的功能，所以我们需要在里面添加两个委托，让开发者对不同的碰撞盒添加不同的处理方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class QObj</span><br><span class="line">&#123;</span><br><span class="line">    //矩阵当碰撞盒</span><br><span class="line">    public Rect rect;</span><br><span class="line">    //id</span><br><span class="line">    public int id &#123; private set; get; &#125;</span><br><span class="line">//当前位置节点</span><br><span class="line">    public QuadTree locate;</span><br><span class="line">//模仿Unity中的触发器</span><br><span class="line">    public bool isTrigger = false;</span><br><span class="line">    //两个委托 分别对应碰撞器和触发器</span><br><span class="line">    public Action&lt;QEntity,QEntity&gt; OnCollision;</span><br><span class="line">    public Action&lt;QEntity, QEntity&gt; OnTrigger;</span><br><span class="line">    //关联自身的游戏实体</span><br><span class="line">    public QEntity qEntity=null;</span><br><span class="line">    </span><br><span class="line">    //构造函数1 接收id，坐标，宽高</span><br><span class="line">    public QObj(int id,Point o, double w, double h)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        rect = new Rect(o, w, h);</span><br><span class="line">    &#125;</span><br><span class="line"> //构造函数2 接收坐标，宽高</span><br><span class="line">    public QObj(Point o, double w, double h)</span><br><span class="line">    &#123;</span><br><span class="line">        rect = new Rect(o, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    //设置id</span><br><span class="line">    public void SetID(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QObj之间的碰撞检测"><a href="#QObj之间的碰撞检测" class="headerlink" title="QObj之间的碰撞检测"></a>QObj之间的碰撞检测</h3><p>​    初中数学就教过两个圆如何判断是否相交，即两圆点的距离与两圆半径和进行对比，距离小于等于半径和就代表两个圆相交或相切了。</p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1047015610,2574472785&amp;fm=26&amp;gp=0.jpg" alt=""></p><p>​    那么我们转换成矩形，其思想也相近，只不过要分别判断两个方向的轴，因为圆只有半径，矩形有宽高。</p><p>​    也就是说，在X轴上，两矩阵中点的x坐标差的绝对值与两矩阵的半宽和对比，如果小于则代表在X轴上发生相交。</p><p>​    在Y轴上，两矩阵中点的y坐标差的绝对值与两矩阵的半高和对比，如果小于则代表在Y轴上发生相交。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E7%9F%A9%E5%BD%A2%E7%A2%B0%E6%92%9E.png" alt=""></p><h3 id="如何实现碰撞之后的无法继续前进的伪物理效果"><a href="#如何实现碰撞之后的无法继续前进的伪物理效果" class="headerlink" title="如何实现碰撞之后的无法继续前进的伪物理效果"></a>如何实现碰撞之后的无法继续前进的伪物理效果</h3><p>​    很容易想得到的方法，就是第一次产生碰撞的时候，我们记录自身的位置，然后只要继续发生碰撞，我们强制修正坐标即可。</p><p>​    但这样很容易出现bug，就是当我们碰撞的时候，无论怎么移动都无法移动，因为我们的坐标一直被强制修复，但因为一直在修复，我们也无法移动，这样就造成了恶行循环。</p><p>​    那么如何破解这种情况呢，很简单，同样的将移动方向分解成XY轴，在碰撞的时候让该阻挡得方向轴对应坐标强制修复即可。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E7%A7%BB%E5%8A%A8%E6%96%B9%E5%90%91%E6%97%A0%E6%B3%95%E7%A7%BB%E5%8A%A8.png" alt=""></p><p>​    如上图，A在向左方向移动的时候，与B发生碰撞，这个时候，理应任何向左发生移动的行为都应该被阻止。也就是说，如果发生上述条件，我们只需要在碰撞检测成功后修复X坐标即可，如果我们向右移动，因为不在碰撞检测范围内，因此不会被修复，也就可以正常移动。</p><p>​    那么我们如何判断物体碰撞时趋于什么方向的运动呢。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%80%BC%E5%88%A4%E6%96%AD.png" alt=""></p><p>​    观察上图，矩形A在这个时候，向左移动是该被组织的，我们不难发现，两矩形中点的Y坐标差绝对值比X坐标差绝对值小很多，我们可以利用这一点去判断哪个坐标是否被修复。为了更标准的判断，我们应该让坐标差归一化，也就是除以对应的半换/高度和。</p><p>​    下面放代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public bool Collide(QObj obj,ref Point rem)//碰撞检测的对方物体，以及修复坐标(注意不能是本身rect中的坐标o)</span><br><span class="line">    &#123;</span><br><span class="line">//获取XY轴的标准化差值</span><br><span class="line">             float offsetX = (float)((rect.o.x - obj.rect.o.x)/ (obj.rect.Rwidth + rect.Rwidth)), offsetY = (float)((rect.o.y - obj.rect.o.y)/ (obj.rect.Rheight + rect.Rheight));</span><br><span class="line">    //如果两个标准化差值都小于1，证明它们开始相交/碰撞了</span><br><span class="line">            if (Mathf.Abs(offsetX) &lt; 1 &amp;&amp; Mathf.Abs(offsetY) &lt; 1)</span><br><span class="line">            &#123;</span><br><span class="line">//如果两者的触发器bool都关闭 那么就要组织该物体继续朝某方向移动</span><br><span class="line">            if (!isTrigger &amp;&amp;!obj.isTrigger)</span><br><span class="line">            &#123;</span><br><span class="line">                rem = rect.o;//首先缓存坐标</span><br><span class="line">                if (Mathf.Abs(offsetX) &gt;= Mathf.Abs(offsetY))//判断哪个插值更大，说明那个轴不可移动。</span><br><span class="line">                &#123;//X轴的差值更大，说明该矩形在目标矩形的左右方向</span><br><span class="line">                    rem.x = obj.rect.o.x;//获取对方矩形的圆点X坐标</span><br><span class="line">                    if(offsetX&gt;=0)//对比0来判断该矩形是在左边还是右边 然后修复X坐标</span><br><span class="line">                        rem.x+=(obj.rect.Rwidth + rect.Rwidth);</span><br><span class="line">                    else</span><br><span class="line">                        rem.x -= (obj.rect.Rwidth + rect.Rwidth);</span><br><span class="line">                &#125;</span><br><span class="line">                else//Y轴的差值更大，说明该矩形在目标矩形的上下方向</span><br><span class="line">                &#123;</span><br><span class="line">                    rem.y = obj.rect.o.y;//获取对方矩形的圆点y坐标</span><br><span class="line">                    if (offsetY &gt;= 0)//对比0来判断该矩形是在上边还是下边 然后修复y坐标</span><br><span class="line">                        rem.y+=(obj.rect.Rheight + rect.Rheight);</span><br><span class="line">                    else</span><br><span class="line">                        rem.y -= (obj.rect.Rheight + rect.Rheight);</span><br><span class="line">                &#125;</span><br><span class="line">//这个后面会实现 作用是修改对应id的坐标</span><br><span class="line">                QEntityManager.Instance.ChangePoint(id, rem);</span><br><span class="line">                //向双方的碰撞委托发送信息</span><br><span class="line"> if(OnCollision!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    OnCollision(qEntity,obj.qEntity);</span><br><span class="line">                &#125;</span><br><span class="line">                if (obj.OnCollision != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    obj.OnCollision(qEntity, obj.qEntity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                //向对方的触发器委托发送信息</span><br><span class="line">            if(obj.OnTrigger !=null)</span><br><span class="line">            &#123;</span><br><span class="line">                obj.OnTrigger(qEntity,obj.qEntity);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h2><p>​    弄完碰撞盒，我们可以进入四叉树的设计。四叉树简单来说就是一个管理着四个子节点的数据结构，每个子节点也可以管理自己的四个子节点。</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4256445987,2885583687&amp;fm=26&amp;gp=0.jpg" alt=""></p><p>​    但是对于空间划分呢，我们还需要添加存储的物体链表，用来表示当前这个节点下，有多少个物体位于这个节点代表的空间中，很显然我们还需要一个矩阵去表示这个节点表示的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class QuadTree</span><br><span class="line">&#123;</span><br><span class="line">    //当自身存储数量达到多少的时候 开始划分</span><br><span class="line">    public int maxSum;</span><br><span class="line">    //四个子区域 用象限下标去访问</span><br><span class="line">    public QuadTree[] childs;</span><br><span class="line">    //存储的数量</span><br><span class="line">    public List&lt;QObj&gt; objs; </span><br><span class="line">    //当前该节点代表的的深度</span><br><span class="line">    public int deep;</span><br><span class="line">    //自己的位置信息</span><br><span class="line">    public Rect rect;</span><br><span class="line">    //指向自己的父亲节点 起到优化作用 后面解释如何使用</span><br><span class="line">    private QuadTree father;</span><br><span class="line">    </span><br><span class="line">    public QuadTree(Rect rect,int deep, QuadTree fa=null)//默认父亲节点为空</span><br><span class="line">    &#123;</span><br><span class="line">        father = fa;</span><br><span class="line">        this.rect = rect;  </span><br><span class="line">        this.deep = deep + 1;//深度+1 为了方便在划分四个子区域的时候子区域深度自动+1</span><br><span class="line">        objs = new List&lt;QObj&gt;();</span><br><span class="line">        maxSum = 4;//这个随意设置，一般来说这个maxSum应该是统一的。</span><br><span class="line">        DrawLine.Instance.AddDrawObj(this.rect);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得物体在该节点的哪个象限GetIndex"><a href="#获得物体在该节点的哪个象限GetIndex" class="headerlink" title="获得物体在该节点的哪个象限GetIndex()"></a>获得物体在该节点的哪个象限<code>GetIndex()</code></h3><p>​    我们可以直接调用在前面矩形类中写好的包含方法<code>IsInclude()</code>去判断是否在这个象限内，但是需要注意的是，如果矩形刚好在四叉树分界线上怎么办，我个人的解决方法是把让该矩形的物体受当前节点管理，而不是子节点。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E5%B1%9E%E4%BA%8E%E6%9C%AC%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt=""></p><p>​    如上图，这些物体应该归这一层的节点管理而不是四个子节点管理。</p><p>​    如何判断呢，相信在前面的那两个碰撞检测和包含方法上很容易联想到了，同样是物体碰撞盒的矩形中点与该四叉树的矩形中点差值进行判断就好，不再论述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int GetIndex(QObj target)</span><br><span class="line">&#123;</span><br><span class="line">    //如果在分界轴上，返回-1</span><br><span class="line">    if (Mathf.Abs((float)(target.rect.o.x - rect.o.x))&lt; target.rect.Rwidth || Mathf.Abs((float)(target.rect.o.y - rect.o.y)) &lt; target.rect.Rheight)</span><br><span class="line">        return -1;</span><br><span class="line">    for(int i=0;i&lt;4;i++)//遍历四个子节点，调用isInclude去判断</span><br><span class="line">    &#123;</span><br><span class="line">        if (childs[i].rect.IsInclude(target.rect))</span><br><span class="line">            return i;//返回对应的象限号</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向四叉树节点添加物体AddObj"><a href="#向四叉树节点添加物体AddObj" class="headerlink" title="向四叉树节点添加物体AddObj()"></a>向四叉树节点添加物体<code>AddObj()</code></h3><p>​    添加物体时，要注意是否超过容量，超过设定的阈值，就要开始分割。</p><p>​    如果是分割后加入物体，那么得遍历子节点，再添加到正确的子节点中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void AddObj(QObj obj)</span><br><span class="line">&#123;</span><br><span class="line">    //这个是调用绘制类在scene窗口绘制矩形 可以无视 后面会给实现</span><br><span class="line">    DrawLine.Instance.AddDrawObj(obj.id, obj.rect.o, ref obj.rect.Rwidth, ref obj.rect.Rheight, deep);</span><br><span class="line">    obj.locate = this;//设置这个碰撞盒的所在节点 为当前四叉树节点</span><br><span class="line">    if (childs==null)//如果子节点不存在 说明还没有分割</span><br><span class="line">    &#123;</span><br><span class="line">        objs.Add(obj);//添加到list中</span><br><span class="line">        if (deep&lt;=5&amp;&amp;objs.Count &gt; maxSum)//如果深度到达某个阈值(这里是5)，并且管理的物体对象数量超过最大值</span><br><span class="line">            Split();//调用分割函数 下面给出实现</span><br><span class="line">    &#125;</span><br><span class="line">    else //如果子节点存在，说明这个四叉树节点不是叶子节点</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        int index = GetIndex(obj);//获取所在对应子节点的想象</span><br><span class="line">        if (index &gt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            childs[index].AddObj(obj);//调用该子节点的添加方法</span><br><span class="line">        &#125;</span><br><span class="line">        else//如果象限小于 那就是这个物体在分界线上，因此属于该节点管理</span><br><span class="line">            objs.Add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四叉树分割Split"><a href="#四叉树分割Split" class="headerlink" title="四叉树分割Split()"></a>四叉树分割<code>Split()</code></h3><p>​    分割实现主要是一些数学逻辑的计算，直接看代码就好了。</p><p>​    值得注意的是，分割之后，还要遍历当前节点的管理物体，对四个新分割的子节点一一判断是否可以交给子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void Split()</span><br><span class="line">    &#123;</span><br><span class="line">        childs = new QuadTree[4];</span><br><span class="line">        //第一象限</span><br><span class="line">        childs[0] = new QuadTree(new Rect(rect.o.x+rect.Rwidth/2, rect.o.y + rect.Rheight / 2,rect.Rwidth,rect.Rheight), deep,this);</span><br><span class="line"> //第二象限</span><br><span class="line">        childs[1] = new QuadTree(new Rect(rect.o.x - rect.Rwidth / 2, rect.o.y + rect.Rheight / 2, rect.Rwidth, rect.Rheight), deep, this);</span><br><span class="line"> //第三象限</span><br><span class="line">        childs[2] = new QuadTree(new Rect(rect.o.x - rect.Rwidth / 2, rect.o.y - rect.Rheight / 2, rect.Rwidth, rect.Rheight), deep, this);</span><br><span class="line"> //第四象限</span><br><span class="line">        childs[3] = new QuadTree(new Rect(rect.o.x + rect.Rwidth / 2, rect.o.y - rect.Rheight / 2, rect.Rwidth, rect.Rheight), deep, this);</span><br><span class="line"></span><br><span class="line">    //开始将当前管理的物体交给子节点</span><br><span class="line">        for(int i= objs.Count-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            int index = GetIndex(objs[i]);</span><br><span class="line">            if (index &gt;= 0)//只有象限大于的才给子节点，否则还是自己保管</span><br><span class="line">            &#123;</span><br><span class="line">                childs[index].AddObj(objs[i]);</span><br><span class="line">                objs.Remove(objs[i]);</span><br><span class="line">            &#125;              </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对四叉树节点中所有物体的碰撞检测Collide"><a href="#对四叉树节点中所有物体的碰撞检测Collide" class="headerlink" title="对四叉树节点中所有物体的碰撞检测Collide()"></a>对四叉树节点中所有物体的碰撞检测<code>Collide()</code></h3><p>​    前面我们实现过碰撞盒类的碰撞检测方法，现在我们要应用到四叉树上，我们的四叉树是实时划分区域的，因此，我们只需要与当前节点管理的物体、子节点管理的物体、和父物体的管理物体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void Collide(QObj obj,ref Point rem)</span><br><span class="line">&#123;</span><br><span class="line">    //对自身检测</span><br><span class="line">        for (int i = objs.Count - 1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">        if (obj.id!= objs[i].id&amp;&amp; obj.Collide(objs[i],ref rem))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;与&quot;+ objs[i].id+&quot;发生碰撞&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //对子节点检测</span><br><span class="line">        if(childs!=null)</span><br><span class="line">        foreach(QuadTree child in childs)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = child.objs.Count - 1; i &gt;= 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                if (obj.id != child.objs[i].id &amp;&amp; obj.Collide(child.objs[i], ref rem))</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.Log(&quot;与&quot; + child.objs[i].id + &quot;发生碰撞&quot;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      //对父节点检测</span><br><span class="line">        if(father!=null)</span><br><span class="line">        &#123;</span><br><span class="line">        for (int i = father.objs.Count - 1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (obj.id != father.objs[i].id &amp;&amp; obj.Collide(father.objs[i], ref rem))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;与&quot; + father.objs[i].id + &quot;发生碰撞&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以想一想为什么我没有调用父节点和子节点的<code>Collide()</code>方法而是在一个方法内完成所有遍历。:smile_cat:</p><h3 id="判断是否在某个四叉树节点中IsHere"><a href="#判断是否在某个四叉树节点中IsHere" class="headerlink" title="判断是否在某个四叉树节点中IsHere()"></a>判断是否在某个四叉树节点中<code>IsHere()</code></h3><p>​    游戏中，大部分物体是静止的，但是对于可操控的角色或者AI都是可移动的，因此我们得实时判断物体的所属节点位置，一旦不属于自身之前的节点，我们就需要重新检索，找到对应的位置。</p><p>​    这里可以优化，因为树是自上而下的结构，我们不需要从头节点往下查询，我们只需要在之前的节点找到父节点，去判断是否在父节点即可，如果不是，再判断父节点的父节点。这样效率理论上比从头结点往下遍历快得多，特别是深度很大的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void IsHere(QObj target)</span><br><span class="line">   &#123;</span><br><span class="line">       //判断是否包含在矩形范围内</span><br><span class="line">       if (rect.IsInclude(target.rect))</span><br><span class="line">       &#123;</span><br><span class="line">           //如果包含，就查出可不可以添加到子节点里</span><br><span class="line">           if (childs == null)</span><br><span class="line">               return;</span><br><span class="line">           int index = GetIndex(target);</span><br><span class="line">           if (index &gt;= 0)</span><br><span class="line">           &#123;</span><br><span class="line">               if (objs.Count &gt; 0)</span><br><span class="line">                   for (int i = objs.Count - 1; i &gt;= 0; i--)</span><br><span class="line">                   &#123;</span><br><span class="line">                       if (target.id == objs[i].id)</span><br><span class="line">                       &#123;</span><br><span class="line">                           childs[index].AddObj(objs[i]);//添加到子节点</span><br><span class="line">                           objs.Remove(objs[i]);//从自身移除</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else//不在矩形范围内 说明物体可能移动出去了</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           if (objs.Count &gt; 0)</span><br><span class="line">               for (int i = objs.Count - 1; i &gt;= 0; i--)</span><br><span class="line">               &#123;</span><br><span class="line">                   if (target.id == objs[i].id)//尝试找到是不是在自身的管理物体列表里 如果存在 那么的确是从自身范围移动出去的</span><br><span class="line">                   &#123;</span><br><span class="line">                       objs.Remove(objs[i]);//移除</span><br><span class="line">                       if (father != null)</span><br><span class="line">                           father.AddObj(target);//添加到父物体中 调用AddObj的时候 会自动添加到父物体对应的子节点里</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>下一篇实现游戏实体以及管理脚本和在Scene窗口绘制矩形和四叉树的脚本~</p><hr>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity3D内存优化-GC</title>
      <link href="/2019/MyLearn-Unity-GC/"/>
      <url>/2019/MyLearn-Unity-GC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/GC/GC.png" alt=""></p><h2 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h2><p>​    本篇重点介绍GC，因此我们必须了解什么是GC，GC是<strong>Garbage collection</strong>的缩写，中文翻译为垃圾回收，可以理解为负责回收无用内存的一个机制，只要熟悉JAVA或者C#语言的程序猿应该都了解过GC，因为这两个语言大部分情况下都是运行在虚拟机上的，并非C/C++那样直接汇编成机器代码在操作系统上运行。而虚拟机为了减轻编程的负担，装备了GC这一机制。</p><p>​    那么在Unity3D中，GC是如何触发和如何运作的呢？</p><h3 id="GC的运行时机"><a href="#GC的运行时机" class="headerlink" title="GC的运行时机"></a>GC的运行时机</h3><p>​    GC是一个周期性或触发性的机制，并不是每分每秒都在执行的，它的运行触发条件如下：</p><ol><li>堆分配时堆上的可用内存不足时触发GC。</li><li>GC会不时的自动运行（频率因平台而异）。</li><li>手动强制调用GC</li></ol><h3 id="Unity的GC算法"><a href="#Unity的GC算法" class="headerlink" title="Unity的GC算法"></a>Unity的GC算法</h3><p>​    在<strong>.NET Framework</strong>环境下，提供的GC算法是代数的，分有<strong>012</strong>三代(似乎有<strong>3</strong>第四代)，每一代管理着不同相对内存大小的资源。</p><p>​    而目前已知<strong>Mono2.0</strong>(<a href="http://confusel.tech/2019/MyLearn-Mono&amp;IL2CPP/">什么是Mono</a>)采用的<strong>Boehm GC算法</strong>- 是非代数和非压缩的。“非世代”意味着GC在执行收集传递时必须扫描整个堆，因此其性能因堆扩展而降低。“非压缩”意味着内存中的对象不会被重新定位以便关闭对象之间的间隙。</p><p>​    IL2CPP的GC不知道是否像官方所说的利用.NET Core。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>每次执行GC时，将执行以下步骤：</p><ul><li>垃圾收集器检索堆上的每个对象。</li><li>垃圾收集器搜索所有当前对象引用以确定堆上的对象是否仍在作用域内。</li><li>不在作用域内的对象被标记为删除。</li><li>删除被标记的对象并将内存返回给堆。</li></ul><h4 id="这个算法产生的问题"><a href="#这个算法产生的问题" class="headerlink" title="这个算法产生的问题"></a>这个算法产生的问题</h4><blockquote><ol><li>最明显的问题是GC可能花费相当长的时间来运行。 如果堆上有很多对象和大量的对象引用要检查，则检查所有这些对象的过程可能很慢。 这可能会导致我们的游戏卡顿或运行缓慢。</li><li>另一个问题是GC可能在不合时宜的时刻被触发。 如果CPU在我们游戏的性能关键部分已经满负荷了，那此时即使是少量的GC额外开销也可能导致我们的帧速率下降和性能问题。</li><li>另一个不太明显的问题是<strong>堆碎片</strong>。当从堆中分配内存时，会根据必须存储的数据大小从不同大小的块中的可用空间中获取内存。当这些内存块返回到堆时，堆可能分成很多由分配块分隔的小空闲块。这意味着虽然可用内存总量可能很高，但由于碎片化太过严重而无法分配一块连续的大内存块。导致GC被触发或不得不扩大堆大小。</li></ol></blockquote><p>注：堆内存碎片化有两个后果，一是游戏内存大小会远高于实际所需要的大小，二是GC会被更频繁的触发。</p><p>我们可以围绕以上前两点，见招拆招。</p><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><h4 id="1-尽可能的减少堆内存的分配"><a href="#1-尽可能的减少堆内存的分配" class="headerlink" title="1.尽可能的减少堆内存的分配"></a>1.尽可能的减少堆内存的分配</h4><blockquote><ol><li>如果堆上有很多对象和大量的对象引用要检查，则检查所有这些对象的过程可能很慢。 这可能会导致我们的游戏卡顿或运行缓慢。</li></ol></blockquote><p>上面问题的解决方案可以归结为如何减少堆上的对象数量。在此之前，我们好好理解下，Unity是如何管理内存的。</p><h5 id="Unity内存管理"><a href="#Unity内存管理" class="headerlink" title="Unity内存管理"></a>Unity内存管理</h5><p>​    Unity的内存占用分为三类：代码内存、托管内存 (Managed Memory)和原生内存 (Native Memory )</p><ul><li>代码内存 是指Unity引擎原生代码、类库(Native Plugins)、以及我们编写的代码 编译以后形成的原生二进制文件(Native binary)在运行时所占用的内存</li><li>托管内存 是指脚本后处理机制(Mono/IL2CPP)的内存管理模块所控制的托管堆(managed heap)内存</li><li>原生内存 是指Unity引擎本身模块系统运转时申请的内存以及场景内用到的资源(网格，纹理，动画，音频等)所占用的内存</li></ul><p>本篇介绍的GC，即负责<strong>托管内存</strong>部分，因为目前版本的Unity3D可以说只支持C#了，而在C#中的内存结构，主要由以下两个：</p><h6 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a>Stack栈</h6><p>​    每个正在运行的程序都对应着一个进程，在一个进程内部，可以有一个或多个线程，每个线程都拥有一块“自留地”，称为“线程堆栈”，大小为1M，用于保存自身的一些数据，比如函数中定义的局部变量、函数调用时传送的参数值等，这部分由编译器自动释放，地址从高往底分配。</p><h6 id="Heap堆-托管堆"><a href="#Heap堆-托管堆" class="headerlink" title="Heap堆/托管堆"></a>Heap堆/托管堆</h6><p>​    GC负责的部分，存储引用类型，任何需要new操作的对象都在Heap上生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void TestFun()</span><br><span class="line">&#123;</span><br><span class="line">int a=0;//栈上</span><br><span class="line">int b=1;//栈上</span><br><span class="line">TestObject test;//自定义的对象，这个test只是一个引用，本身存储在栈上。</span><br><span class="line">test = new TestObject();//在堆上申请了一块内存，并调用构造函数，被test指向。</span><br><span class="line">&#125;//这个时候 a，b，test一定会从栈上被删除。</span><br><span class="line">//但是test所指向堆上的那个TestObject对象，不一定会被删除，因为这不是栈的负责部分，是GC负责，在执行一次GC的时候才会删除。</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/GC/%E6%A0%88%E5%A0%86.png" alt=""></p><center><br>    上面的函数结束，栈中的数据会被直接释放，但是堆中的数据需要等垃圾收集器GC回收。多次<br></center><h5 id="常用的优化方案"><a href="#常用的优化方案" class="headerlink" title="常用的优化方案"></a>常用的优化方案</h5><p><strong>1.同一容器(如Generic提供的泛型数据结构)配合如<code>clear()</code>这样的清空函数重复使用，避免产生多次仅仅使用一次的引用类型。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt;tempList;//声明</span><br><span class="line">Dictionary&lt;int,Weapon&gt;Dic;</span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    tempList=new List&lt;int&gt;();//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete()</span><br><span class="line">&#123;</span><br><span class="line">    //List&lt;int&gt;tempList=new List&lt;int&gt;(); 而不是在这里</span><br><span class="line">    tempList.clear();</span><br><span class="line">    foreach(var i in Dic)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i.value.dura==0)//删除符合某种条件的键值对</span><br><span class="line">            tempList.add(i.key);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;tempList.Count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Dic.remove(tempList[i]);//因为上面保证key绝对在字典里，所以不需要判断null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    C#中字典的foreach遍历过程是不允许删除键值对的，对于删除操作，一般都是利用额外的数据结构去存储需要删除数据的key，然后依次删除，如果在<code>Delete</code>函数中再去<code>new</code>一个<code>List</code>,意味着每一次执行该函数都会多一个引用对象。</p><p>​    也许单单从这里并不会觉得多占用内存，但是如果每一个类似的操作都是通过申请新引用对象来完成的，特别是放在循环中执行该函数的画，造成的内存浪费和GC频率可能就不可收拾了。。。</p><p><strong>2.对于内容一定的字符串使用<code>StringBuilder</code>代替<code>String</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string test=&quot;hello&quot;;</span><br><span class="line">test=test.ToUpper()+&quot;world&quot;;</span><br></pre></td></tr></table></figure><p>​    <code>string</code>在C#中是引用类型，并且有<strong>不可变</strong>的性质，因为不可变的性质，在每一次我们对<code>string</code>的大部分操作    中，都会产生临时的引用对象，这些临时的引用对象存储在堆中，也并不会立即回收。</p><p>如上面的代码，产生了一下几个临时对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;</span><br><span class="line">&quot;HELLO&quot;</span><br><span class="line">&quot;world~&quot;</span><br><span class="line">&quot;HELLO world&quot;</span><br></pre></td></tr></table></figure><p>​    <code>StringBuilde</code>r是由<code>Char</code>数组构成的。构建新的<code>StringBuilder</code>时能设置容量大小，当添加字符串，超过已分配的数组大小时，就会创建一个新的数组，此时容量会翻倍，旧的数据就会等待垃圾回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder test = new StringBuilder(&quot;hello&quot;);  </span><br><span class="line">foreach(char i in test)</span><br><span class="line">Char.ToUpper(i);</span><br><span class="line">test.append(&quot;world&quot;);</span><br></pre></td></tr></table></figure><p><strong>3.Unity内置函数的调用相关</strong></p><p>​    3.1 Unity一些字符串属性可以利用<code>CompareTag</code>比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private string playerTag=&quot;Player&quot;;</span><br><span class="line">void OnTriggerEnter(Collider other)</span><br><span class="line">&#123;</span><br><span class="line">   b//ool isPlayer = other.gameObject.tag == playerTag;</span><br><span class="line">   bool isPlayer = other.gameObject.CompareTag(playerTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3.2协程不使用<code>yield return</code>匿名对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WaitForSeconds delay = new WaiForSeconds(1f);</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">   //yield return new WaitForSeconds(1f); 每次返回都是一个新的WaitForSeconds</span><br><span class="line">    yield return delay;</span><br><span class="line">    //yield return 0; 0也会产生引用，应该用return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>如果可以，使用值类型类型的数组代替结构体</strong></p><p>​    这样面向过程的开发一定程度上减少了由引用类型引起的频繁GC，不过开发效率可能会降低。</p><p><strong>5.对于值类型的传参，善于使用ref关键字，把它当作一个引用，减少深拷贝的出现。</strong></p><h4 id="2-合适的实际手动调用GC"><a href="#2-合适的实际手动调用GC" class="headerlink" title="2.合适的实际手动调用GC"></a>2.合适的实际手动调用GC</h4><p>​    什么时候合适手动GC呢，个人觉得，在玩家不需要集中精力于游戏上时，例如在加载新场景的时候，在加载页面阶段可以手动GC，因为旧场景的大部分引用是不需要再用的。</p><h1 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h1><p><a href="http://www.newhappy.com.cn/?p=1058">一文搞懂Unity内存</a></p><p><a href="https://blog.csdn.net/diudiu5201/article/details/62220456">【Unity3d游戏开发】浅谈Unity中的GC以及优化</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《STL源码剖析》之序列式容器vector</title>
      <link href="/2019/MyLearn-STL-3/"/>
      <url>/2019/MyLearn-STL-3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%83%8C%E6%99%AF/3.jfif" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>研究数据的特定排列方式，以利于搜寻或排序或其它特殊目的，这一专门学科我们成为数据结构。</p></blockquote><table><thead><tr><th>序列式容器</th><th>关联式容器</th></tr></thead><tbody><tr><td><code>array(build-in)</code></td><td><code>RB-tree</code></td></tr><tr><td><code>vector</code></td><td><code>set</code></td></tr><tr><td><code>heap</code></td><td><code>map</code></td></tr><tr><td><code>priority-queue</code></td><td><code>multiset</code></td></tr><tr><td><code>list</code></td><td><code>multimap</code></td></tr><tr><td><code>slist</code></td><td><code>hashtable</code></td></tr><tr><td><code>deque</code></td><td><code>hash_set</code></td></tr><tr><td><code>stack</code></td><td><code>hash_map</code></td></tr><tr><td><code>queue</code></td><td><code>hash_multiset</code></td></tr><tr><td></td><td><code>hash_multmap</code></td></tr></tbody></table><h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><blockquote><p>所谓序列式容器，其中的元素都可序(ordered)，但未必有序(sorted)。C++语言本身提供了一个序列式容器<code>array</code>，STL另外在提供<code>vector，list,deque,stack,queue,priority-queue</code>等等序列式容器。其中stack和queue由于只是将<code>deque</code>改头换面而成，技术上被归类为一种配接器，但我仍把它放在本章讨论。</p></blockquote><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p><code>vector</code>的数据安排以及操作方式，与<code>array</code>非常相似，两者的唯一差别在于空间的运用的灵活性。<code>array</code>是静态控件，一旦配置了就不能改变；要换个大(或小)一点的房子，可以，一切琐细得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来得空间释放给系统。<code>vector</code>是动态空间，随着元素得加入，它的内部机制会自行扩充以容纳新元素。</p></blockquote><h4 id="SGI的vector定义摘要"><a href="#SGI的vector定义摘要" class="headerlink" title="SGI的vector定义摘要"></a>SGI的<code>vector</code>定义摘要</h4><p>​    为了阅读方便，我把原文的代码中一些声明顺序按照被调用的顺序而调换了，不影响实际效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先是类模板的声明，除了存储的数据之外，还默认了空间配置器为STL提供的alloc</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Tvalue_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type*pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type*iterator;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp;reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span>size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>difference_type;</span><br><span class="line"><span class="comment">//在公共成员中，定义了几个嵌套型别，分别是值类型、 指针、 迭代器、 引用、计量单位、指针差。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt;data_allocator;</span><br><span class="line">    <span class="comment">//simple_alloc是SGI对所使用的空间配置器的再度封装，它提供了符合STL规格的接口。</span></span><br><span class="line">    iterator start;<span class="comment">//指向数据头部的迭代器</span></span><br><span class="line">    iterator finish;<span class="comment">//指向数据尾部的迭代器</span></span><br><span class="line">    iterator end_of_storage;<span class="comment">//指向可用空间尾部的迭代器</span></span><br><span class="line">    <span class="comment">//在原文中没有详细讲述这个函数的实现，这个函数的作用是在position后面申请一个空间，然后赋予元素x。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position,<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span><span class="comment">//释放空间函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果首部迭代器不为空，代表已经存储至少一个数据</span></span><br><span class="line"><span class="keyword">if</span>(start)</span><br><span class="line">            <span class="comment">//调用空间配置器的内存释放函数，其中end_of_storage-start会在二级配置器中使用到，一级配置器会直接从start释放</span></span><br><span class="line">            <span class="comment">//大于128字节使用一级，小于则二级</span></span><br><span class="line">            data_allocator::deallocate(start,end_of_storage-start);</span><br><span class="line">        <span class="comment">//可以回顾一下 http://confusel.tech/2019/MyLearn-STL-1/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置空间并填满内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allocate_and_fill</span><span class="params">(size_type n,<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        iterator result=data_allocator::allocate(n);</span><br><span class="line">        <span class="comment">//STL内存处理函数，大致作用是：参数包括 : 一个迭代器，一个计数器以及一个值。该函数从迭代器指向的元素开始，将指定数量的元素设置为给定的值。</span></span><br><span class="line">        uninitialized_fill_n(result,n,x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充式初始化，把容器元素变成n个value</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n,<span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用了上面那个函数</span></span><br><span class="line">        start=allocate_and_fill(n,value);</span><br><span class="line">        <span class="comment">//调整尾部迭代器</span></span><br><span class="line">        finish=start+n;</span><br><span class="line">        end_of_storage=finish;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*********构造析构********/</span></span><br><span class="line">     <span class="comment">//无参构造函数，初始化三个迭代器</span></span><br><span class="line">    <span class="built_in">vector</span>():start(<span class="literal">nullptr</span>),end(<span class="literal">nullptr</span>),end_of_storage(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>(size_type n,<span class="keyword">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        fill_initialize(n,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        fill_initialize(n,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">long</span> n,<span class="keyword">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        fill_initialize(n,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用T的构造函数返回一个默认值</span></span><br><span class="line">        fill_initialize(n,T());</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这是STL的全局函数，从start到finish一一析构</span></span><br><span class="line">        destory(start,finish);</span><br><span class="line">        <span class="comment">//已在上面声明</span></span><br><span class="line">        deallocate();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/*********结束********/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line">    <span class="comment">//获得实际数据存储大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size_type(end()-begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得容器大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size_type(end_of_storage-begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> begin()==end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写操作符[]，通过下标访问元素</span></span><br><span class="line">    <span class="comment">//返回一个引用</span></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//指针加法+解引用</span></span><br><span class="line">        <span class="keyword">return</span> *(begin()+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取第一个元素</span></span><br><span class="line">   <span class="function">reference <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> *begin();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//取最后一个元素</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="comment">//end()永远指向空，即最后一个元素的下一个位置</span></span><br><span class="line">       <span class="keyword">return</span> *(end()<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//从后面插入一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果空间没满</span></span><br><span class="line">        <span class="keyword">if</span> (finish != end_of_storage)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//全局函数，内部实现主要是</span></span><br><span class="line">            <span class="comment">//new(p) T1(value);</span></span><br><span class="line">       <span class="comment">//placement new,在指针p所指向的内存空间创建一个类型为T1的对象。</span></span><br><span class="line">            <span class="comment">//也就是在finish处，生成一个x数据</span></span><br><span class="line">            construct(finish,x);</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            ++finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            insert_aux(end(),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最尾端元素取出</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//finish指向空，--才得到想要删除的元素迭代器</span></span><br><span class="line">        --finish;</span><br><span class="line">        <span class="comment">//全局函数 析构对象finish</span></span><br><span class="line">        destroy(finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过迭代器删除元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果不是最后一个有效元素</span></span><br><span class="line">        <span class="keyword">if</span>(position+<span class="number">1</span>!=end())</span><br><span class="line">            copy(position+<span class="number">1</span>,finish,position);</span><br><span class="line">        <span class="comment">//copy也是STL算法，实现内部如下，也就是将position以后的元素逐一前移。</span></span><br><span class="line">        <span class="comment">/*template&lt;class InputIterator, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">          OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          while (first!=last) &#123;</span></span><br><span class="line"><span class="comment">            *result = *first;</span></span><br><span class="line"><span class="comment">            ++result;</span></span><br><span class="line"><span class="comment">            ++first;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          return result;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//与pop_back()一致</span></span><br><span class="line">        --finish;</span><br><span class="line">        destroy(finish);</span><br><span class="line">        <span class="comment">//这里返回的是原本position的下一个元素</span></span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新设置大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size,<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果新容量小于当前，那么将多余部分删除</span></span><br><span class="line">        <span class="keyword">if</span>(new_size&lt;size())</span><br><span class="line">            <span class="comment">//std全局函数，删除两个迭代器之间的元素</span></span><br><span class="line">            erase(begin()+new_size,end());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则插入部分</span></span><br><span class="line">            <span class="comment">//std全局函数，在某个迭代器后面插入n个元素</span></span><br><span class="line">            insert(end(),new_size-size(),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">resize(new_size,T());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//std全局函数，删除两个迭代器之间的元素</span></span><br><span class="line">          erase(begin(),end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    可以看到，<code>vector</code>在构造函数和析构函数中调用了空间配置器，几乎所有成员函数如插入删除操作的实现，都是以迭代器为操作的基本单位而不是存储的元素本身。</p><p>​    而且，<code>vector</code>的迭代器类型竟然就是元素的原生指针。</p><h4 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a><code>vector</code>的迭代器</h4><blockquote><p><code>vector</code>维护的是一个连续线性空间，所以不论其元素型别为何，普通指针都可以作为<code>vector</code>的迭代器而满足所有必要条件，因为<code>vector</code>迭代器所需要的操作行为，如<code>operator\*,operator\-&gt;,operator++,operator--,operator+,operator-,operator+=,operator\-=</code>。普通指针天生就具备。所以,<code>vector</code>提供的是<code>Random Access Iterators</code>。</p></blockquote><h4 id="vector的成员函数insert-aux"><a href="#vector的成员函数insert-aux" class="headerlink" title="vector的成员函数insert_aux()"></a><code>vector</code>的成员函数<code>insert_aux()</code></h4><p>​    这个函数一般被调用于<code>push_back()</code>，也就是从后面插入新元素时，此时没有可用空间而触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T,Alloc&gt;:</span>:insert_aux(iterator position,<span class="keyword">const</span> T&amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果还有剩余的可用空间</span></span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在finish处申请一个空间并赋值*(finish-1)</span></span><br><span class="line">        construct(finish,*(finish<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//因为多了一个元素，所以finish要向后移</span></span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy=x;</span><br><span class="line">        <span class="comment">//STL算法，作用是把(position,finish-2)之间的元素移动到finish-1的前面</span></span><br><span class="line">        copy_backward(position,finish<span class="number">-2</span>,finish<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//让目的位置正确赋值</span></span><br><span class="line">        *position = x_copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有可用空间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">        <span class="comment">//如果当前空间为空，我们申请1个，否则我们申请原先的两倍</span></span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span>? <span class="number">2</span>*old_size:<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//利用空间配置器申请新空间</span></span><br><span class="line">        iterator new_start = data_allocator::allocate(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//STL内存处理工具函数之一，作用是把start到position的内容拷贝到new_start里，并返回末端。</span></span><br><span class="line">new_finish = uninitialized_copy(start,position,new_start);</span><br><span class="line">            <span class="comment">//赋值</span></span><br><span class="line">        construct(new_finish,x);</span><br><span class="line">            ++new_finish;</span><br><span class="line">            new_finish = uninitialized_copy(position,finish,new_finish);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//析构新容器的所有元素</span></span><br><span class="line">            destroy(new_start,new_finish);</span><br><span class="line">            <span class="comment">//释放空间</span></span><br><span class="line">            data_allocator::deallocate()new_start,len;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//析构旧元素</span></span><br><span class="line">        destroy(begin(),end());</span><br><span class="line">        <span class="comment">//释放</span></span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="comment">//吧新容器的迭代器赋值给当前容器的迭代器</span></span><br><span class="line">        start=new_start;</span><br><span class="line">        finish=new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们画几个图片方便理解。</p><p>​    以存储<code>int</code>数据类型的<code>vector</code>为例。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8.png" alt=""></p><center>当前总容量为8，已经填充了5个元素</center><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E6%8F%92%E5%85%A59.png" alt=""></p><center>我们填满vector，此时我们想在元素为5的位置插入新元素9</center><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/%E8%B0%83%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.png" alt=""></p><center>调用insert_aux的过程，因为可用空间不足，申请了新的双倍的空间</center><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vectotr%E6%96%B0%E5%86%85%E7%BB%93%E6%9E%9C.png" alt=""></p><center>最后把新的迭代器赋值给当前容器的迭代器并维护。旧内存将释放掉</center><h4 id="vector的成员函数insert"><a href="#vector的成员函数insert" class="headerlink" title="vector的成员函数insert()"></a><code>vector</code>的成员函数<code>insert()</code></h4><p>​    这个函数常用于在任意位置插入，与<code>insert_</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T,Alloc&gt;:</span>:insert(iterator position,size_type n,<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(size_type(end_of_storage-finish)&gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            T x_copy =x;</span><br><span class="line">            <span class="comment">//当前插入点后面有多少</span></span><br><span class="line">            <span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">            iterator old_finish = finish;</span><br><span class="line">            <span class="keyword">if</span> (elems_after &gt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将当前尾迭代器的前n个元素移动到尾迭代器的后面</span></span><br><span class="line">                uninitialized_copy(finish - n,finish,finish)</span><br><span class="line">                <span class="comment">//维护尾迭代器</span></span><br><span class="line">                finish+=n;</span><br><span class="line">                <span class="comment">//再把插入点后面剩余的元素移动到尾迭代器前面</span></span><br><span class="line">                copy_backward(position,old_finish-n,old_finish);</span><br><span class="line">                <span class="comment">//以上步骤结束后，会在插入点后面剩出n个空位</span></span><br><span class="line">                <span class="comment">//填充x_copy</span></span><br><span class="line">                fill(position,position+n,x_copy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//现在尾迭代器处填充n-elems_after个元素</span></span><br><span class="line">                uninitialized_fill_n(finish,n-elems_after,x_copy);</span><br><span class="line">                finish += n-elems_after;</span><br><span class="line">                <span class="comment">//再把插入点到原来尾迭代器之间的所有元素移动到新的尾迭代器后面</span></span><br><span class="line">                uninitialized_copy(position,old_finish,finish);</span><br><span class="line">                finish += elems_after;</span><br><span class="line">                <span class="comment">//插入点和旧尾迭代器填充之间的元素</span></span><br><span class="line">                fill(position,old_finish,x_copy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果备用空间不足，那么需要重新申请</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">            <span class="comment">//申请两倍或者更长(至少满足正好插入)</span></span><br><span class="line">            <span class="keyword">const</span> size_type len = old_size + max(old_size, n);</span><br><span class="line">            <span class="comment">//利用空间配置器申请len个空间</span></span><br><span class="line">            iterator new_start=data_allocator::allocate(len);</span><br><span class="line">            iterator new_finish=new_start;</span><br><span class="line">            <span class="comment">//#define __STL_TRY   try</span></span><br><span class="line">            __STL_TRY</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//三部分逐一赋值给新空间，插入点之前，插入的n个元素，原来插入点之后的元素</span></span><br><span class="line">                new_finish = uninitiallzed_copy(start,position,new_start);</span><br><span class="line">                new_finish = uninitiallzed_fill_n(new_finish,n,x);</span><br><span class="line">                new_finish = uninitiallzed_copy(position,finish,new_finish);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">                &#123;</span><br><span class="line">                    destory(new_start,new_finish);</span><br><span class="line">                    data_allocator::deallocate(new_start,len);</span><br><span class="line">                    <span class="keyword">throw</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">//析构</span></span><br><span class="line">            destory(start,finish);</span><br><span class="line">            <span class="comment">//释放之前的空间</span></span><br><span class="line">            deallocate();</span><br><span class="line">            <span class="comment">//维护三个迭代器</span></span><br><span class="line">            start=new_start;</span><br><span class="line">            finish=new_finish;</span><br><span class="line">            end_of_storage=new_start+len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h5><ul><li>当备用空间足够的时候: 我们想在其中插入2个元素。<ul><li>可用空间剩余2，我们想插入2个，插入点之后有3和元素，明显3&gt;2</li></ul></li></ul><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A51.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A52.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A53.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A54.png" alt=""></p><p>​        大致流程，是将<strong>原本的元素</strong>按<strong>两</strong>步移动，假设添加n个元素，那么首先移动插入点后的n个元素到尾迭代器后，然后再把剩余的前半段移动到尾迭代器的前面。</p><p>​        最后填充好中间的空闲元素。</p><ul><li><ul><li>可用空间剩余3，我们想插入3个，插入点之后有2个元素，明显2&lt;3。</li></ul><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A55.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A56.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A57.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/vector%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A58.png" alt=""></p><p>​        大致流程，是将<strong>填充的元素</strong>按<strong>两</strong>步移动，假设添加n个元素，那么首先在尾迭代器后填充(可用空闲数量-n)个目标元素。</p><p>​        将要被替换的、插入点之后到原尾迭代器之间的元素移动到新尾迭代器后面。</p><p>​        最后填充好中间的空闲元素。</p></li></ul><h5 id="不解"><a href="#不解" class="headerlink" title="不解"></a>不解</h5><p>​    为啥不直接把旧的元素移动完毕，再直接填充呢。</p><h4 id="代码测试push-back的内存和构造析构变化"><a href="#代码测试push-back的内存和构造析构变化" class="headerlink" title="代码测试push_back的内存和构造析构变化"></a>代码测试<code>push_back</code>的内存和构造析构变化</h4><p>看看下面的代码，猜猜会输出什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">role(<span class="keyword">const</span> <span class="keyword">char</span>* n) : name(n) &#123;&#125;</span><br><span class="line">~role() &#123;<span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">role r1("小李"), r2("小强") ,r3("小狗"), r4("小明");</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;role&gt; RoleVec;</span><br><span class="line">RoleVec rvec;  </span><br><span class="line">rvec.push_back(r1);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">rvec.push_back(r2);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    rvec.push_back(r3);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">rvec.push_back(r4);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">rvec.erase(rvec.begin());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">小李</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">小李</span></span><br><span class="line"><span class="comment">小强</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">小强</span></span><br><span class="line"><span class="comment">小狗</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">小狗</span></span><br><span class="line"><span class="comment">小强</span></span><br><span class="line"><span class="comment">小李</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们结合代码来分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">role r1("小李"), r2("小强") ,r3("小狗"), r4("小明");</span><br><span class="line"><span class="comment">//这四个，在栈上，顺序从上到下，从r1到r4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;role&gt; RoleVec;</span><br><span class="line">RoleVec rvec;  </span><br><span class="line"><span class="comment">//rvec进入栈 在r4下</span></span><br><span class="line">rvec.push_back(r1);</span><br><span class="line"><span class="comment">//空间为0，我们调用index_aux，申请了1的空间，将r1小李深拷贝进去</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">rvec.push_back(r2);</span><br><span class="line"><span class="comment">//空间为1，我们调用index_aux，申请了2的空间，将r1 r2深拷贝进去</span></span><br><span class="line"><span class="comment">//原来的空间元素被析构 </span></span><br><span class="line"><span class="comment">//小李</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">rvec.push_back(r3);</span><br><span class="line"><span class="comment">//空间为2，我们调用index_aux，申请了4的空间，将r1 r2 r3深拷贝进去</span></span><br><span class="line"><span class="comment">//原来的空间元素被析构 </span></span><br><span class="line"><span class="comment">//小李</span></span><br><span class="line"><span class="comment">//小强</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">rvec.push_back(r4);</span><br><span class="line"><span class="comment">//空间足够</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">rvec.erase(rvec.begin());</span><br><span class="line"><span class="comment">//vector 中的 r2 r3 r4向前拷贝,原r4被析构</span></span><br><span class="line"><span class="comment">//小明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这时候vector先被析构，因为栈高位向低位。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">小强</span></span><br><span class="line"><span class="comment">小狗</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//然后从下到上析构栈上的r4 r3 r2 r1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">小狗</span></span><br><span class="line"><span class="comment">小强</span></span><br><span class="line"><span class="comment">小李</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="不解-1"><a href="#不解-1" class="headerlink" title="不解"></a>不解</h2><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/Vector%E9%97%AE%E9%A2%98.png" alt=""></p><p>​    为啥Diana析构出现了两次，<br>​    前三次push_back已经确保容器空间为4了，用push_back插入尾部或者insert插入尾部都不会发成Diana析构。<br>但是在中间insert就会出现 ，SGI的insert源码里，只有空间不足才会扩张，否则都是移动+填充，按理来说Diana应该直接命中，只是被拷贝了一次才对嘛。。。<br>​    即使出现扩张空间，交换新旧内存引发的析构，也是旧内存里的ABC一起析构才对啊。。</p><p><em>以后解决了补上。</em></p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单了解Mono和IL2CPP</title>
      <link href="/2019/MyLearn-Mono&amp;IL2CPP/"/>
      <url>/2019/MyLearn-Mono&amp;IL2CPP/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%83%8C%E6%99%AF/4.jfif" alt=""></p><h2 id="NET-应用程序是怎么运行的？"><a href="#NET-应用程序是怎么运行的？" class="headerlink" title=".NET 应用程序是怎么运行的？"></a>.NET 应用程序是怎么运行的？</h2><p>​    开篇先自问个问题，<strong>.NET 应用程序是怎么运行的？</strong>，在没有去探索这些知识点的时候，自己是一片空白的，因为自己完全是为了使用Unity3D而去学习的C#，却没有去了解这个语言的执行过程(又不是不能用)。</p><p>​    百度启动，我们发现<strong>.NET平台的实现</strong>有两大派系：<strong>曾今闭源的.Net Framework</strong>和<strong>开源的Mono</strong>，那么，我们首先得知道，执行.NET程序为何需要它们。</p><h3 id="跨平台需求"><a href="#跨平台需求" class="headerlink" title="跨平台需求"></a>跨平台需求</h3><p>​    跨平台是个好东西，我们写了一个程序，不需要多大精力就可以将它发布在多个平台上，那么我们如何实现这个过程呢？绞尽脑汁，想了想，“把源代码编译成不同平台对应的机器码？”</p><p>​    咦，感觉八九不离十了，因为我们想到c/c++，每个平台都有对应的gcc，在linux上写的代码，<strong>大部分</strong>都可以在各个linux派生系统上直接编译运行，但是应该能马上意识到，linux和winodws有些api并不通用啊。</p><p>​    聪明的我们想到，宏定义判断平台，编码的时候写多个方式，通过makefile来自动选择编译的参数。</p><p>​    是的，我们开发是能这么做，我们也能体会到这样开发带来的成本很高，并且我们的角度只是以开发者的角度去思考这个问题，那么作为一个面向开发者的公司要如何思考呢。毕竟开发成本降低了，才能迎来更多的开发者，因此我们不应该让开发者去做这些繁重的事，我们需要实现一个东西，让开发者只需要按照某个规定/协议/规则编码，我们的东西识别这些符合定义的编码，将他们自动转换成各平台的机器码不就行了么。</p><p>​    因此，微软开发了一个称为<a href="http://zh.wikipedia.org/wiki/通用语言架构">通用语言架构</a>（Shared Source Common Language Infrastructure，Shared Source CLI)；也就是上面提到的，让开发者遵守的一种技术规范，它定义了一个语言无关的跨体系结构的运行环境，这使得开发者可以用规范内定义的各种高级语言来开发软件，并且无需修正即可将软件运行在不同的计算机体系结构上。</p><h3 id="CIL，公共中间语言（Common-Intermediate-Language）"><a href="#CIL，公共中间语言（Common-Intermediate-Language）" class="headerlink" title="CIL，公共中间语言（Common Intermediate Language）"></a>CIL，公共中间语言（Common Intermediate Language）</h3><p>​    我们遵守CLI规则，编译器会将我们编写的代码变成中间语言IL，我们还需要一个东西，专门负责翻译开发者的代码，变成对应的机器码。<em>注意别把CLI和CIL弄混。</em></p><h3 id="CLR，公共语言运行时（Common-Language-Runtime）"><a href="#CLR，公共语言运行时（Common-Language-Runtime）" class="headerlink" title="CLR，公共语言运行时（Common Language Runtime）"></a>CLR，公共语言运行时（Common Language Runtime）</h3><blockquote><p>无论通过任何语言构建产品，都必须寄宿到一个平台中运行，这正如我们的软件运行在操作系统环境一样，操作系统为CLR提供了运行环境，使用.NET构建的程序又运行在CLR之上，CRL为.NET程序的运行提供了温床，CLR提供基本的类库和运行引擎，基本类库封装操作系统函数供开发者方便调用，运行引擎用于编译并运行我们开发的程序。CLR包含.NET运行引擎和符合CLI的类库。通过.NET平台构建的程序都基于CLR基础类库来实现，并且运行在CLR提供的运行引擎之上。</p></blockquote><p>​    显然，这个CLR就是上文所需要的”东西“(是不是和java虚拟机差不多)，能把基于CLI规范的语言编写出来的IL代码翻译为机器代码运行，这是CLR最重要的功能。</p><p>​    那么CLR是如何对IL语言进行翻译的呢？CLR提供了JIT，即Just-in-time,动态(即时)编译，边运行边编译；AOT，Ahead Of Time，指运行前编译，两种程序的编译方式。</p><p>​    JIT具体的做法是这样的:当载入一个类型时,CLR为该类型创建一个内部数据结构和相应的函数,当函数第一次被调用时,JIT将该函数编译成<a href="https://baike.baidu.com/item/机器语言">机器语言</a>.当再次遇到该函数时则直接从cache中执行已编译好的机器语言。而AOT则是提前编译好所有代码。</p><h3 id="C-的执行过程"><a href="#C-的执行过程" class="headerlink" title="C#的执行过程"></a>C#的执行过程</h3><p>​    经过上面的探讨，相信运行过程开始清晰起来了。C#是遵循CLI规范的高级语言，被先被各自的编译器编译成中间语言：IL（CIL），等到需要真正执行的时候，这些IL会被加载到运行时库CLR中，由CLR动态的编译成汇编代码（JIT）然后在执行。</p><p><img src="https://pic3.zhimg.com/f1c18ef3b344b657a9c236258d1b4c7e_b.jpg" alt="img"></p><p>​        可能加上才刚认识的英文专有词缩写，这么表述还是有一点绕，那么通俗来解释，我们写完C#代码，编译器开始编译操作，编译器将它变成了一种中间语言，运行的时候，操作系统会调用一个解释器对这些中间语言进行动态解释或者提前编译运行。</p><h2 id="Net-Framework和Mono"><a href="#Net-Framework和Mono" class="headerlink" title=".Net Framework和Mono"></a>.Net Framework和Mono</h2><p>​    上面那一块主要功能就包含在叫做<strong>.Net Framework</strong>的框架中，那么既然有了<strong>.Net Framework</strong>,为何还需要<strong>Mono</strong>呢？下面引用别人的博客内容，阐述了<strong>Mono</strong>出现的原因。</p><blockquote><p>​    我想表达什么呢？其实我们现在在 Windows 平台下开发的 .NET 应用程序，是深深依赖于 .NET Framework（深深的那种），你的应用程序代码基本上都是在它之上完成的，而 .NET Framework 又是深深依赖于 Windows 平台下的 CLR（也是深深的那种），在这种情况下，根本就无法使你的应用程序跨平台，因为微软紧紧的抱住 Windows 平台，妄想 Windows 可以实现“大一统”，但现实是很残酷的，这次的 .NET 开源、跨平台，其实也是微软的无奈之举。但就是在这种背景下，Mono 出现了，并且在微软的各种“排挤”下坚持了下来，这是非常不容易的，其实实现 .NET 跨平台的三个关键是：<strong>编译器</strong>、<strong>CLR</strong> 和<strong>基础类库</strong>，而 Mono 实质上就是把他们三个进行跨平台实现了，一个很小团队完成了一个巨头需要完成的工作，而且还是在这个巨头的“排挤”下，其实这就是<strong>开源</strong>和<strong>社区</strong>的力量。</p></blockquote><p>​    是的，<strong>.Net Framework</strong>没有真正意义上实现跨平台，它只能在不同windows版本上工作，这是<strong>Mono</strong>出现的原因。我们来看看百度百科的介绍。</p><blockquote><p><strong>Mono</strong>是一个由 Xamarin公司（先前是Novell,最早为Ximian）所主持的自由开放源代码项目。该项目的目标是创建一系列符合ECMA标准（Ecma- 334和Ecma-335）的.NET工具，包括C#编译器和通用语言架构。与微软的.NET Framework（共通语言运行平台）不同，Mono项目不仅可以运行于Windows系统上，还可以运行于 Linux，FreeBSD，Unix，OS X和Solaris，甚至一些游戏平台，例如：Playstation 3，Wii或XBox 360之上。        </p></blockquote><p>​    Mono使得C#这门语言有了很好的跨平台能力。相对于微软的.Net Framework运行时库<strong>Mono</strong>使用自己的Mono VM作为运行时库。 加上C#本身快速友好的开发能力，最终使得Unity团队在创建之初就决定将<strong>Mono</strong>，C#作为其核心。</p><p>​    而<strong>Mono</strong>的执行方式和<strong>.Net Framework</strong>大致上差不多，只不过使用的改编后的CLR，使得在各平台上可以变成对应机器码。</p><h2 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h2><p>​    现在我们抛开<strong>.Net Framework</strong>，因为Unity目前支持<strong>Mono</strong>和<strong>IL2CPP</strong>，<strong>IL2CPP</strong>是后来加上的(Unity2017.3 版本以后)，先来后到，我们先谈谈<strong>Mono</strong>。</p><h3 id="Mono的组成"><a href="#Mono的组成" class="headerlink" title="Mono的组成"></a>Mono的组成</h3><ol><li><p>C#编译器<br>最新的Momo版本（5.0+）c#编译器完全兼容c#4.0以上，unity 2018 使用的依旧是 Mono 2.0 版本，它的编译器(mcs)就不支持c#4.0以上。</p></li><li><p>Mono运行时CLR<br>上面提到过，提供了JIT（即时编译器），AOT（提前编译器）两种编译器。</p><p>类库加载器。<br>垃圾回收器(Unity使用的是贝姆垃圾回收器)。</p></li><li><p>基础类库（与.net框架兼容）+Mono类库</p></li></ol><h3 id="Mono的执行流程"><a href="#Mono的执行流程" class="headerlink" title="Mono的执行流程"></a>Mono的执行流程</h3><p>   <img src="https://pic2.zhimg.com/cef19147534ab017c59b755b15766679_b.jpg" alt="img"></p><h3 id="Mono的优点"><a href="#Mono的优点" class="headerlink" title="Mono的优点"></a>Mono的优点</h3><ul><li>构建应用非常快</li><li>由于Mono的JIT(Just In Time compilation ) 机制, 所以支持更多托管类库</li><li>支持运行时代码执行(译者注: 由于JIT机制，所以能在运行的过程中执行新生成的或者动态加载的代码)</li></ul><h3 id="Mono的缺点"><a href="#Mono的缺点" class="headerlink" title="Mono的缺点"></a>Mono的缺点</h3><ul><li>​    Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成。<br>​    Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平 台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览器的平台。要让WebGL支持Mono的VM几乎是不可能的。</li><li>​    必须将代码发布成托管程序集(.dll 文件 ,  由mono或者.net 生成 )</li></ul><h2 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h2><p>​    从名字上看就很清楚了，IL to cpp 即IL翻译成cpp。根据Unity官方博客上的文章指出，使用.NET和Mono编译器对代码进行编译。</p><blockquote><p>​    我们可以在Windows平台的Unity安装路径Editor\Data\il2cpp目录下找到。对于OSX平台，它位于Unity安装路径的Contents/Frameworks/il2cpp/build目录内。 il2cpp.exe这个工具是一个托管代码可执行文件，其完全由C#写成。在开发IL2CPP的过程中，我们同时使用.NET和Mono编译器对其进行编译。</p></blockquote><p>​    而对于GC，官方是这么解释的：</p><blockquote><p>​    运行时的另外一个重要的部分，就是垃圾收集器。在Unity 5中，我们使用libgc垃圾收集器。它是一个典型的贝姆垃圾收集器（Boehm-Demers-Weiser garbage collector）。（译注：相对使用保守垃圾回收策略）。然而我们的libil2cpp被设计成可以方便使用其他垃圾回收器。因此我们现在也在研究集成微软开源的垃圾回收器（Microsoft GC）。对于垃圾回收器这一点，我们会在后续的一篇中专门的讨论，这里就不多说了。</p></blockquote><p><em>以上翻译内容来自<a href="https://www.jianshu.com/p/dd430c991d0b">用Unity做游戏，你需要深入了解一下IL2CPP</a></em></p><h3 id="IL2CPP的组成"><a href="#IL2CPP的组成" class="headerlink" title="IL2CPP的组成"></a>IL2CPP的组成</h3><ol><li><p>AOT编译器</p><p>il2cpp 接受来自Unity自带的或者由Mono编译器产生的托管程序集，将这些程序集转换成C++代码。这些转换出的C++代码最终由部署目标平台上的C++编译器进行编译。</p></li><li><p>一个支持虚拟机的运行时库</p><p>AOT编译器将由.NET 输出的中间语言(IL)代码生成为C++代码。运行时库则提供诸如垃圾回收，与平台无关的线程，IO以及内部调用（C++原生代码直接访问托管代码结构）这样的服务和抽象层。</p><p><img src="https://upload-images.jianshu.io/upload_images/269770-1716159336861dd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="img"></p></li></ol><h3 id="IL2CPP的执行流程"><a href="#IL2CPP的执行流程" class="headerlink" title="IL2CPP的执行流程"></a>IL2CPP的执行流程</h3><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/NET/IL2CPP.jpg" alt="img"></p><h3 id="IL2CPP的优点"><a href="#IL2CPP的优点" class="headerlink" title="IL2CPP的优点"></a>IL2CPP的优点</h3><ul><li>相比Mono, 代码生成有很大的提高</li><li>可以调试生成的C ++代码</li><li>可以启用引擎代码剥离(Engine code stripping)来减少代码的大小</li></ul><h3 id="IL2CPP的缺点"><a href="#IL2CPP的缺点" class="headerlink" title="IL2CPP的缺点"></a>IL2CPP的缺点</h3><ul><li>相比Mono构建应用非常慢</li><li>只支持AOT(Ahead of  Time)编译</li></ul><h3 id="可能产生的疑问"><a href="#可能产生的疑问" class="headerlink" title="可能产生的疑问"></a>可能产生的疑问</h3><ol><li><p>IL2CPP多了一次编译过程啊，从效率上来说为什么值得的使用呢？</p><p>​    IL2CPP多了一次的编译过程是将IL转成CPP，执行的时候还需要C++编译器编译一次，而在Mono中没有，所以在IL2CPP的缺点中，构建应用的时间很长，但是，Mono的JIT只在运行的时候将IL执行成机器码，意味着每一次运行都需要动态加载一些代码，而IL2CPP已经预先编译好了，可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度。</p><p>​    并且Cpp效率之快是大家都承认的。</p></li><li><p>CPP是静态的，那么还需要IL2CPP虚拟机干吗？</p><p>​    虽然通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如GC管理，线程创建这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得游戏载入时间缩短。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    C#是一种高级语言，需要编译转换成中间语言，通过不同平台的CLR解释成机器码，才能运行。</p><p>​    现在在Unity3D中，我们可以选择Mono和IL2CPP两种编译方式，各有优缺点，而一般都在开发阶段选择Mono，在发布的时候选择IL2CPP。</p><p>​    不过呢，据说现在IL2CPP的成熟程度挺高，也有人推荐开发阶段使用。</p><p><img src="https://pic4.zhimg.com/1ac61dcf8ccdf4c3f80ed81afcac5fe3_b.jpg" alt="img"><img src="https://pic2.zhimg.com/127145eba0473bbe7ae9fd371cf28d85_b.jpg" alt="img"></p><center>Unite 2014上官方给出的性能测试截图（数字越小表示运行得越快）</center><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.jianshu.com/p/dd430c991d0b">用Unity做游戏，你需要深入了解一下IL2CPP</a></p><p><a href="">Unity将来时：IL2CPP是什么？</a> <a href="https://www.cnblogs.com/lancidie/p/6258154.html">https://www.cnblogs.com/lancidie/p/6258154.html</a>)</p><p><a href="https://www.cnblogs.com/zjoch/p/6197025.html">魅力 .NET：从 Mono、.NET Core 说起</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《STL源码剖析》之迭代器相关</title>
      <link href="/2019/MyLearn-STL-2/"/>
      <url>/2019/MyLearn-STL-2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%83%8C%E6%99%AF/2.jfif" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>​    不论是泛性思维或者STL的实际运用，迭代器都扮演者重要的角色。STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶着剂将它们它们撮合在一起。容器和算法的反省话，从技术角度来看并不难，C++的class template 和 function templates 可分别达成目标，如何设计出两者之间的良好胶着剂，才是大难题。</p></blockquote><p>​    <em>这篇博客不讨论STL实现的迭代器的源码以及SGI中特定的<code>traits</code>技巧。</em></p><h2 id="迭代器是一种类似指针的对象"><a href="#迭代器是一种类似指针的对象" class="headerlink" title="迭代器是一种类似指针的对象"></a>迭代器是一种类似指针的对象</h2><blockquote><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领和成员访问，因此迭代器最重要的编程工作就是对operator *和operator -&gt; 进行重载工作。</p><p>关于这一点，C++标准程序库有一个 <code>auto_ptr</code>可供我们参考,这是一个用来包装原生指针的对象，声名狼藉的内存漏洞(memory leak)问题可以因此获得解决。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line">    Test(<span class="built_in">string</span> s):value(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="string">"构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="string">"析构"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Test* <span class="title">ps</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">"funb"</span>))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;Test&gt; ps(<span class="keyword">new</span> Test(<span class="string">"func"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    funb();</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果为</span></span><br><span class="line"><span class="comment">funb构造</span></span><br><span class="line"><span class="comment">func构造</span></span><br><span class="line"><span class="comment">func析构</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​    我们看输出结果，可以看到 <code>auto_ptr</code>自动帮我们释放了内存和析构。</p><h3 id="auto-ptr的简化实现"><a href="#auto-ptr的简化实现" class="headerlink" title="auto_ptr的简化实现"></a><code>auto_ptr</code>的简化实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> AUTOPTR_HPP_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTOPTR_HPP_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AutoPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//explicit声明不可以隐式转换</span></span><br><span class="line">    explicit AutoPtr(T *p=nullptr):pointee(p)&#123;&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">AutoPtr</span>(<span class="title">AutoPtr</span>&lt;U&gt; &amp; <span class="title">rhs</span>):</span>pointee(rhs.release())&#123;&#125;</span><br><span class="line">    ~AutoPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pointee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">AutoPtr</span>&lt;T&gt;&amp; <span class="title">operator</span>=(<span class="title">AutoPtr</span>&lt;U&gt; &amp; <span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=rhs)</span><br><span class="line">            reset(rhs.release());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *pointee;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *pointee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pointee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AUTOPTR_HPP_INCLUDED</span></span></span><br></pre></td></tr></table></figure><p>​    不难看出，智能指针对模板对象进行了一层封装，并重载了operator*() 和operator-&gt;()等操作。同时保证在析构的时候释放内存。</p><h2 id="自定义链表并实现迭代器"><a href="#自定义链表并实现迭代器" class="headerlink" title="自定义链表并实现迭代器"></a>自定义链表并实现迭代器</h2><p>​    我的代码并没有和原文中的封装方法一致，因为我觉得原文中的实现方式很容易暴露一些相对使用者没什么必要的对象，实现过程中一直没有去看原文3.2节的最后几段话。后面去才看，发现作者之所以使用如此暴露的封装方法实现迭代器的原意便是想体现出容器和对应迭代器的强连接性。</p><blockquote><p> 为一种容器设计迭代器，需要暴露很多细节，既然无可避免，干脆把迭代器的开发工作交给List的设计者好了，如厕以来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种STL容器都提供专属迭代器的缘故。</p></blockquote><h4 id="存储元素"><a href="#存储元素" class="headerlink" title="存储元素"></a>存储元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">    ListItem *next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListItem(T v):value(v),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListItem *<span class="title">Next</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链接 自己添加的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ListItem* nextValue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next=nextValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Item* ptr;</span><br><span class="line">    ListIter(Item *p =<span class="literal">nullptr</span>):ptr(p)&#123;&#125;</span><br><span class="line">    Item&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    Item* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    Item&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前置式：累加然后取出</span></span><br><span class="line">    ListIter&amp; <span class="keyword">operator</span>++( )</span><br><span class="line">    &#123;</span><br><span class="line">        ptr=ptr-&gt;Next();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置式：取出然后累加</span></span><br><span class="line">    ListIter&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ListIter tmp=*<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对比的是迭代器封装的值</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> ListIter&amp; i) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> ListIter&amp; i) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr != i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//头元素</span></span><br><span class="line">    ListItem&lt;T&gt;* front;</span><br><span class="line">    <span class="comment">//尾元素</span></span><br><span class="line">    ListItem&lt;T&gt;* last;</span><br><span class="line">    <span class="comment">//首部迭代器 原文不存在</span></span><br><span class="line">    ListIter&lt;ListItem&lt;T&gt; &gt;begin;</span><br><span class="line">    <span class="comment">//尾部迭代器 原文不存在</span></span><br><span class="line">    ListIter&lt;ListItem&lt;T&gt; &gt;end;</span><br><span class="line">    <span class="keyword">long</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    List():front(<span class="literal">nullptr</span>),last(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//从前插入 原文不实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertFront</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt; * newValue = <span class="keyword">new</span> ListItem&lt;T&gt;(value);</span><br><span class="line">        <span class="keyword">if</span>(front)</span><br><span class="line">        &#123;</span><br><span class="line">            newValue-&gt;Insert(front);</span><br><span class="line">        &#125;</span><br><span class="line">        front=newValue;</span><br><span class="line">        begin.ptr=front;</span><br><span class="line">        <span class="keyword">if</span>(!last)</span><br><span class="line">            last=front;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从后插入 原文不实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertEnd</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt; * newValue = <span class="keyword">new</span> ListItem&lt;T&gt;(value);</span><br><span class="line">        <span class="keyword">if</span>(last)</span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;Insert(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">        last=newValue;</span><br><span class="line">        end.ptr=last-&gt;Next();</span><br><span class="line">        <span class="keyword">if</span>(!front)</span><br><span class="line">            front=last;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//输出链表 原文不实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os = <span class="built_in">std</span>::<span class="built_in">cout</span>)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt;*iter=front;</span><br><span class="line">        <span class="keyword">while</span>(iter!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            os&lt;&lt;iter-&gt;Value();</span><br><span class="line">            iter=iter-&gt;Next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取得尾部迭代器（空） 自己添加的函数</span></span><br><span class="line">    ListIter&lt;ListItem&lt;T&gt; &gt; End() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取得首部迭代器 自己添加的函数</span></span><br><span class="line">    ListIter&lt;ListItem&lt;T&gt; &gt; Begin() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//find函数实现</span></span><br><span class="line"><span class="comment">//首尾迭代器以及查找的目标值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Iterator</span> <span class="title">Find</span>(<span class="title">Iterator</span> <span class="title">first</span>,<span class="title">Iterator</span> <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">target</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//因为在使用的时候，我们实际比较的是迭代器的值目标值，但是迭代器的值是一个封装的元素，所以还需要获得元素存储的值。</span></span><br><span class="line">    <span class="keyword">while</span>(first!=last&amp;&amp; first-&gt;Value()!=target)</span><br><span class="line">        ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//大写List，使用上面的自定义链表</span></span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; myList;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        myList.InsertFront(i);</span><br><span class="line">        myList.InsertEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line">    myList.display();<span class="comment">//5432112345</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/* 原文实例代码</span></span><br><span class="line"><span class="comment">    ListIter&lt;ListItem&lt;int&gt; &gt;begin(mylist.front());</span></span><br><span class="line"><span class="comment">    ListIter&lt;ListItem&lt;int&gt; &gt;end;</span></span><br><span class="line"><span class="comment">    ListIter&lt;ListItem&lt;int&gt; &gt;iter;</span></span><br><span class="line"><span class="comment">    iter=find(begin,end,3)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//因为自己将迭代器封装到了容器中，直接调用即可</span></span><br><span class="line">    <span class="keyword">if</span>(Find(myList.Begin(),myList.End(),<span class="number">4</span>)!=myList.End())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"存在4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"不存在4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//存在4</span></span><br><span class="line">    <span class="keyword">if</span>(Find(myList.Begin(),myList.End(),<span class="number">6</span>)!=myList.End())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"存在6"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"不存在6"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//不存在6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在原文的示例代码中，作者故意没有将迭代器和List一起封装，因此在<code>main()</code>中，特地声明了多个迭代器，去指向链表的<code>front</code>和<code>end</code>以及结果，而我误打误撞的避免了这种情况:sweat_smile:</p><h3 id="迭代器相应型别"><a href="#迭代器相应型别" class="headerlink" title="迭代器相应型别"></a>迭代器相应型别</h3><blockquote><p>​    上述的<code>ListIter</code>提供了一个迭代器雉形。如果将思想拉得更高远一些，我们便会发现，在算法中运用迭代器时，很可能会用到其相应型别(associated type)。什么是相应型别？迭代器所指之物的型别就是其一。假设算法中有必要声明一个变量，以“迭代器所指对象的型别”为型别，如何是好？毕竟C++值支持<code>sizeof()</code>，并未支持<code>typeof()</code>,即便动用<code>RTTI</code>性质中的<code>typeid()</code>,获得的也只是型别名称，不能拿来做变量声明只用。</p></blockquote><p>​    在上面的代码中，我们自己实现的<code>Find()</code>函数，只能应用与这个特定的<code>List</code>中，因为<code>first-&gt;Value()!=target</code>这段代码，并不是所有模板类对象拥有<code>Value()</code>这个方法来获取成员变量，(代码中的<code>Iterator</code>拥有)，因此我们很可能需要在函数模板中，判断参数的实际类型，甚至直接操作这些类型，比如需要生成这个类型的对象等，那么我们需要怎么做呢？</p><p>​    书中给了答案：</p><blockquote><p>解决办法是：利用 <code>function template</code> 的参数推导机制。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">func_imp1</span>(<span class="title">I</span> <span class="title">iter</span>,<span class="title">T</span> <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T target;<span class="comment">//我们这里是不是已经获取到了数据类型T，虽然这样看起来，它只是一个模板类T，但是在编译期后，它就是int了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">func</span>(<span class="title">I</span> <span class="title">iter</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    func_imp1(iter,*iter);</span><br><span class="line">    <span class="comment">//这里的I是指针，所以还要调用一次。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    func(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    函数模板的参数推导实在调用函数时 &lt;类型&gt; 缺省的情况下编译器去推导的，我们可以借用这个方式去获得对应的类型，如果只是获得类型的画，其实也可以用<code>auto</code>。</p><hr><p>关于auto和函数模板的相关知识可以看一下别人的博客<a href="https://www.cnblogs.com/wangxiaobao/p/5829358.html">类型推导：函数模板与auto</a>，总结的很好。</p><hr><h2 id="Traits-编程技法–STL源代码门钥"><a href="#Traits-编程技法–STL源代码门钥" class="headerlink" title="Traits 编程技法–STL源代码门钥"></a>Traits 编程技法–STL源代码门钥</h2><h3 id="通过内嵌型别，来返回对应的类型"><a href="#通过内嵌型别，来返回对应的类型" class="headerlink" title="通过内嵌型别，来返回对应的类型"></a>通过内嵌型别，来返回对应的类型</h3><p>​    虽然我们可以通过函数模板的参数机制来推导类型，但是也只能限制在参数上，如果我们必须要用于返回值，就束手无策了。</p><p>​    原文演示了<code>内嵌型别</code>的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">T* ptr;</span><br><span class="line">    MyIter(T *p=<span class="literal">nullptr</span>):ptr(p)&#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:value_type</span><br><span class="line">func(I ite)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一</span></span><br><span class="line">MyIter&lt;<span class="keyword">int</span>&gt; ite(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</span><br><span class="line"><span class="comment">//二</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;fun(ite);<span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>​    我们来捋一捋这段代码，在结构体<code>MyIter</code>中，声明了一个类型别名<code>value_type</code>，这也使得<code>typename I::value_type</code>对于程序来说，是已知的。我们在一中初始化迭代器<code>ite</code>，将一个指向存储类型为<code>int</code>内容为<code>8</code>的地址给迭代器的<code>ptr</code>，在二中调用方法<code>fun()</code>，将<code>ptr</code>的解引用返回，这个时候，因为我们规定了<code>fun()</code>的返回值类型为传参类<code>I</code>中的<code>value_type</code>，而<code>value_type</code>在<code>MyIter&lt;int&gt;</code>中就是<code>int</code>的别名，所以返回的值类型就是<code>int</code>。</p><blockquote><p>​    看起来不错。但是有个隐晦的陷阱并不是所有迭代器都是<code>class type</code>，原生指针就不是！如果不是<code>class type</code>，就无法为它定义内嵌型别。但STL(以及整个泛型思维)绝对必须接受原生指针作为一种迭代器，所以上面这样还不够，有没有办法可以让上述的一般化概念针对特定情况做特殊化处理呢？</p></blockquote><h3 id="Partial-Specialization-偏特化"><a href="#Partial-Specialization-偏特化" class="headerlink" title="Partial Specialization 偏特化"></a><code>Partial Specialization</code> 偏特化</h3><h4 id="Partial-Specialization-的-含义"><a href="#Partial-Specialization-的-含义" class="headerlink" title="Partial Specialization 的 含义"></a><code>Partial Specialization</code> 的 含义</h4><blockquote><p>   大致的意义是：如果<code>class template</code> 拥有一个以上的 <code>template</code>参数，我们可以针对其中某个(或数个，但非全部) <code>template</code>参数进行特化工作。换句话说，我们可以在泛化设计中提供一个特化版本(也就是将泛化版本中的某些<code>template</code>参数赋予明确的指定)。</p></blockquote><h4 id="简单特性萃取iterator-traits实现"><a href="#简单特性萃取iterator-traits实现" class="headerlink" title="简单特性萃取iterator_traits实现"></a>简单特性萃取<code>iterator_traits</code>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特征萃取，萃取类I中的value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type  value_type; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//pointer</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> T  value_type; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//pointer to const </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> T  value_type; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直白来看，只是比上面的代码多了一层封装,但是通过这层封装，我们能更准确的在不同复杂理性中萃取到真正的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:value_type</span><br><span class="line">func(I ite)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/%E7%89%B9%E6%80%A7%E8%90%83%E5%8F%96%E5%99%A8.png" alt=""></p><h3 id="五个常用迭代器相应型别"><a href="#五个常用迭代器相应型别" class="headerlink" title="五个常用迭代器相应型别"></a>五个常用迭代器相应型别</h3><h4 id="迭代器相应型别之一：value-type"><a href="#迭代器相应型别之一：value-type" class="headerlink" title="迭代器相应型别之一：value_type"></a>迭代器相应型别之一：<code>value_type</code></h4><blockquote><p>所谓<code>value_type</code>，是指迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class，都应该定义自己的<code>value_type</code>内嵌型类别，做法就像上节所述。</p></blockquote><h4 id="迭代器相应型别之二：different-type"><a href="#迭代器相应型别之二：different-type" class="headerlink" title="迭代器相应型别之二：different_type"></a>迭代器相应型别之二：<code>different_type</code></h4><blockquote><p><code>different_type</code>用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是器最大容量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pointer</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="comment">//用ptrdiff_t 来保存两个指针相减的结果</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>  different_type; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//pointer to const </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>  different_type; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    //写明返回的类型</span></span><br><span class="line"><span class="class">    <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:different_type</span><br><span class="line">    count(I first,I last,<span class="keyword">const</span> T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;I&gt;::different_type n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">            <span class="comment">//这个函数的作用是统计在连续容器中，value出现了多少次</span></span><br><span class="line">            <span class="keyword">if</span>(*first==value)</span><br><span class="line">                n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference_type"></a>迭代器相应型别之三：<code>reference_type</code></h4><blockquote><p>从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：</p><ul><li>不允许改变“所指对象之内容”，成为<code>constant iterators</code>，例如 <code>const int * pic</code></li><li>允许改变“所指对象之内容”，成为<code>mustable iterators</code>，例如 <code>int * pic</code></li></ul><p>当我们对一个<code>mustable iterators</code>进行提领操作时，获得的不应该是一个右值，而是一个左值，因为右值不允许赋值操作，左值才允许。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">9</span>);</span><br><span class="line">*pi=<span class="number">7</span>;</span><br><span class="line">*pci=<span class="number">1</span>;<span class="comment">//错误，pic是右值</span></span><br></pre></td></tr></table></figure><blockquote><p>在C++中，函数如果要传回左值，都是以<code>by reference</code>的方式进行，所以当<code>p</code>是一个<code>mustable iterators</code>时，如果其<code>value_type</code>是<code>T</code>，那么<code>*p</code>的型别不应该是<code>T</code>，应该是<code>T&amp;</code>，当<code>p</code>是一个<code>constant iterators</code>时，如果其<code>value_type</code>是<code>T</code>，那么<code>*p</code>的型别不应该是<code>const T</code>，应该是<code>const T&amp;</code>，这里所讨论的<code>-[]</code>写别，即所谓的<code>reference type</code>，实现细节将在下一小节一并展示。</p></blockquote><h4 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer_type"></a>迭代器相应型别之四：<code>pointer_type</code></h4><blockquote><p><code>pointer</code>和<code>references</code>在C++中有非常密切的挂变脸，如果”传回一个左值,令它代表p所指之物”是可能的，那么”传回一个左值,令它代表p所指之物的地址”也一定可以，也就是说，我们能够传回一个<code>pointer</code>，指向迭代器所指之物。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer  pointer; </span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference  reference; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//pointer</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> T*  pointer; </span><br><span class="line">      <span class="keyword">typedef</span> T&amp;  reference; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//pointer to const </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> T*  pointer; </span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;  reference; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>​    和上面的<a href="#简单特性萃取`iterator_traits`实现">简单特性萃取</a>实现区分开来，那里只是指值，这里是专门指引用和指针。</p><h4 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：<code>iterator_category</code></h4><h5 id="五类迭代器"><a href="#五类迭代器" class="headerlink" title="五类迭代器"></a>五类迭代器</h5><blockquote><p>根据移动特性与施行操作，迭代器被分为五类：</p><ul><li><code>input iterator</code>:这种迭代器所指的对象，<strong>不允许被外界改变</strong>。只读。</li><li><code>output iterator</code>:只写。</li><li><code>Forward iterator</code>:允许”写入型”算法在这种迭代器形成的区间上进行读写操作。</li><li><code>Bidrectional iterator</code>:可双向移动，某些算法需要逆向走访某个迭代器区间(例如逆向拷贝某范围内的元素)，可以使用<code>Bidrectional iterator</code></li><li><code>Random Accesson iterator</code>：前四种迭代器都只供应一部分指针算数能力(前三种支持<code>operator ++</code>，第四种加上<code>operator--</code>)，第五种则覆盖所有指针算数能力，包括<code>p+n,p-n,p[n],p1-p2,pq&lt;p2</code>;</li></ul></blockquote><p>​    它们之间可以用继承关系表示：</p><pre class="mermaid">graph TB    input_iterator-->Forward_iterator    output_iterator-->Forward_iterator    Forward_iterator-->Bidrectional_iterator    Bidrectional_iterator-->Random_Access_Iterator</pre><p>​    在设计算法的时候，应该尽力为每个迭代器提供一个明确定义，以保证提供最大的效率，因为它们是继承关系，所有派生类对象是可以向上转换成基类对象的，意味着派生类对象可以使用针对基类对象的算法，但是这个算法对于派生类对象来说可能不是最佳的，虽然能用。</p><p>​    以原文提到的<code>advanced()</code>为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance_II</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(n--)++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以双向移动，所以要考虑n为负数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectuibIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance_BI</span>(<span class="title">BidirectuibIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span>(n--)++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(n++)--i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为随机访问迭代器支持指针算术，所以直接+=</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessonIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance_RAI</span>(<span class="title">BidirectuibIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">i+=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Inputerator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//判断是否是某种迭代器而去调用</span></span><br><span class="line">    <span class="keyword">if</span>(is_random_accesson_iterator(i))</span><br><span class="line">        advance_RAI(I,n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_bidirectuib_iterator(i))</span><br><span class="line">        advance_BI(I,n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        advance_II(I,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    相信刚接触迭代器设计思想时，应该也会写出上面的代码，或者说时习惯性写法，不过在接触更多的更棒的源码之后，就会感受到这样写的不足了，每一次调用<code>advance()</code>都会判断几次，效率太低了。</p><h5 id="利用重载函数和萃取器特性以及继承性提高效率"><a href="#利用重载函数和萃取器特性以及继承性提高效率" class="headerlink" title="利用重载函数和萃取器特性以及继承性提高效率"></a>利用重载函数和萃取器特性以及继承性提高效率</h5><p>​    我们定义五个类/结构体，利用继承的特性把它们定义一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅仅拿来做一个标识，不去实现内部成员。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span>input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span>forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span>bidirectional_iterator_tag&#123;&#125;;</span><br></pre></td></tr></table></figure><p>​    我们通过同参数数量，不同参数类型的方式重载<code>__advance()</code>函数。这里除了新添加的第三个参数，其余和上面原先的<code>advance()</code>函数差不多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>,<span class="title">input_iterator_tag</span>)//不需要用到实参，我们可以不接受</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(n--)++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>,<span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __advance(i,n,input_iterator_tag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以双向移动，所以要考虑n为负数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectuibIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectuibIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>,<span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span>(n--)++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(n++)--i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为随机访问迭代器支持指针算术，所以直接+=</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessonIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectuibIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>,<span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">i+=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们再针对上面的信息，在特征萃取器中添加一个起到迭代器类型别名作用的成员<code>iterator_category</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特征萃取，萃取iterator_category </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//原有部分</span></span><br><span class="line">      ...</span><br><span class="line">          <span class="comment">//添加部分</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category  iterator_category; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以随机访问迭代器 iterator_category 为例子的偏特化中，添加别名，</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//这样，当取iterator_category的时候，实际上得到的就是random_access_iterator_tag</span></span><br><span class="line">     <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>​    再写一个获得临时类型的复制函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:iterator_category</span><br><span class="line">iterator_category(<span class="keyword">const</span> I&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数名取InputIterator的原因是STL算分的一个命名规则：以算法所能接受的最低阶迭代器类型，来为迭代器型别参数命名。</span></span><br><span class="line"><span class="comment">//这个也很好理解，因为每个作用于基类对象的函数都可以被派生类使用。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Inputerator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">__advance(i,n,iterator_traits&lt;InputIterator&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样我们是不是就不需要每次调用<code>advance</code>时进行判断了，因为在编译期，我们就已经获得了每个声过的迭代器的类型<code>iterator_category</code>。</p><h2 id="stl-iterator的保证"><a href="#stl-iterator的保证" class="headerlink" title="stl::iterator的保证"></a><code>stl::iterator</code>的保证</h2><blockquote><p>为了符合规范，任何迭代器都应该提供五个内嵌相应型别，以利于<code>traits</code>萃取，否则便是自别于整个STL架构，可能无法与其它STL组件顺利搭配，然而写代码难免挂一漏万，谁也不能保证不会有粗心大意的时候，如果能够将事情简化，就好多了。</p><p>STL提供了一个<code>iterators class</code>如下，如果每个新设计的迭代器都能继承自它，就可保证符合STL所需规范：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>,</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">        <span class="title">class</span> <span class="title">Refernce</span> = <span class="title">T</span>&amp;&gt;       </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Distance distance_type;</span><br><span class="line"><span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line"><span class="keyword">typedef</span> Refernce refernce;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>iterators class</code>不含任何成员，纯粹只是型别定义，所以继承它并不会招致任何额外负担，由于后三个参数皆有默认值，故新的迭代器只需提供两个参数即可。</p></blockquote><p>​    因此，在前文提到自己实现的链表<a href="#迭代器">迭代器</a>，可以直接这样实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span>input_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//继承与std提供的迭代器型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIter</span>:</span><span class="keyword">public</span> <span class="built_in">std</span>::iterator&lt;<span class="built_in">std</span>::forward_iterator_tag,Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>符合STL标准的迭代器，需要具有获取自身型别、 元素、指针差、 元素指针以及引用。</li><li>可以利用继承性与函数模板的重载优化对不同迭代器的同种函数操作。</li><li>设置适当的迭代器型别，是迭代器的责任，设计适当的迭代器，是容器的责任。</li><li>函数模板参数推导机制可以实现迭代器所存储的数据类型的获取。</li><li><code>traits</code>的编程技巧之巧妙，需要好好研究。</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《STL源码剖析》之空间配置器</title>
      <link href="/2019/MyLearn-STL-1/"/>
      <url>/2019/MyLearn-STL-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%83%8C%E6%99%AF/1.jfif" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>​    Allocator是C++语言标准库中最神秘的部分之一。它们很少被显式使用，标准也没有明确出它们应该在什么时候被使用。</p><p>​    今天的allocator与最初的STL建议非常不同，在此过程中还存在着另外两个设计－－这两个都依赖于语言的一些特性，而直到最近才在很少的几个编译器上可用。对allocator的功能，标准似乎在一些方面追加了承诺，而在另外一些方面撤销了承诺。</p></blockquote><h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><blockquote><p>如果我们要实现自己的空间配置器，要遵守这些标准接口。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type<span class="comment">//值类型</span></span><br><span class="line">allocator::pointer<span class="comment">//指针</span></span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference<span class="comment">//引用</span></span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line">allocator::allocator()<span class="comment">//默认构造函数</span></span><br><span class="line">allocator::allocator(<span class="keyword">const</span> allocator&amp;)<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span>  allocator::alloctor(<span class="keyword">const</span> alloctor &amp;)<span class="comment">//泛化的拷贝构造</span></span><br><span class="line">allocator::~allocator()<span class="comment">//析构函数</span></span><br><span class="line">pointer allocator::address(reference x) <span class="keyword">const</span> <span class="comment">//返回某个对象的地址</span></span><br><span class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span> <span class="comment">//返回某个const对象的地址</span></span><br><span class="line">pointer allocator::allocate(size_type n,<span class="keyword">const</span> <span class="keyword">void</span>*=<span class="number">0</span>)<span class="comment">//配置空间，存储n个T对象。第二个参数是提示，可忽略</span></span><br><span class="line"><span class="keyword">void</span> allocator::deallocate(pointer p,size_type n)<span class="comment">//归还先前配置的空间</span></span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span> <span class="comment">//返回可配置的最大量</span></span><br><span class="line"><span class="keyword">void</span> allocator::construct(pointer p,<span class="keyword">const</span> T&amp;)<span class="comment">//构造T对象</span></span><br><span class="line"><span class="keyword">void</span> allocator::destroy(pointer p)<span class="comment">//对象T的析构</span></span><br></pre></td></tr></table></figure><h4 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h4><blockquote><p>rebind需要详细解释一下。</p><p>rebind允许一个类型的对象的allocator分配其它类型的对象的存储。</p><p>假如有一个容器类MyVector, 它用的是<code>Allocator_A&lt;int&gt;</code>内存分配器，这个容器类很有可能需要double类型的分配器，而且要求对int和double类型的内存分配策略是一样的，这是rebind的意义就体现出来了。总之一句话，rebind实现了对不同类型使用同一种内存分配策略的要求。</p></blockquote><h3 id="自定义简单的空间适配器"><a href="#自定义简单的空间适配器" class="headerlink" title="自定义简单的空间适配器"></a>自定义简单的空间适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LQALLOC_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LQALLOC_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt;//定义了一些标准宏及类型。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;//常用函数库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;//定义数据类型的最大最小值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;//输入输出流</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LQ</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//配置模板类空间的函数，传入数据大小，申请内存</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">T</span>* _<span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>,<span class="title">T</span>*)</span></span><br><span class="line"><span class="class">        //<span class="title">ptrdiff_t</span>是<span class="title">C</span>/<span class="title">C</span>++标准库中定义的一个与机器相关的数据类型。<span class="title">ptrdiff_t</span>类型变量通常用来保存两个指针减法操作的结果。</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::set_new_handler(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">//set_new_handler(0)主要是为了卸载目前的内存分配异常处理函数，这样一来一旦分配内存失败的话，C++就会强制性抛出std:bad_alloc异常，而不是跑到处理某个异常处理函数去处理</span></span><br><span class="line">        T *tmp=(T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size *<span class="keyword">sizeof</span>(T))));</span><br><span class="line">        <span class="comment">//::operator new()这是一个重载函数，完成的操作一般只是分配内存，事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个void*指针。而构造函数的调用(如果需要)是在new运算符中完成的。</span></span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">"内存超出"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归还先前配置的空间</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> _<span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="comment">//::operator delete()与operator new相反，释放内存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过传递目标地址，和目的内容，构造出目标对象。</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> _<span class="title">construct</span>(<span class="title">T1</span> *<span class="title">p</span>,<span class="title">const</span> <span class="title">T2</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">new</span>(p) T1(value);</span><br><span class="line">        <span class="comment">//placement new,在指针p所指向的内存空间创建一个类型为T1的对象。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摧毁：调用析构函数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy</span>(<span class="title">T</span>* <span class="title">ptr</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ptr-&gt;~T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">allocator</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">//T这个类里，可以存储着U类对象</span></span><br><span class="line">            <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//申请内存</span></span><br><span class="line">        <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n,<span class="keyword">const</span> <span class="keyword">void</span>* hint =<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _allocate((difference_type)n,(pointer)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _deallocate(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _destroy(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回对象的地址</span></span><br><span class="line">        <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回常量指针</span></span><br><span class="line">        <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (const_pointer)&amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//返回能计算机能存储类对象的大小</span></span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size_type(UINT_MAX/<span class="keyword">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LQALLOC_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><p>​    我们可以看到，这个配置器实现了最基本的四大功能，空间分配和释放，对象的构造和析构。</p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"lqalloc.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//声明vector时，显示调用我们的自定义空间配置器。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>,LQ::allocator&lt;<span class="keyword">int</span>&gt;&gt;iv&#123;ia,ia+<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;iv.size();i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iv[i]&lt;&lt;<span class="string">' '</span>;<span class="comment">//0 1 2 3 4</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一个简单的自定义allocator，并不能使用与STL中所有容器。</p><ol><li>根据书上介绍，在<strong>PJ STL</strong>中，由于PJ供应的许多容器都需要一个非标准的空间配置器接口,<code>allocator::_Charalloc()</code>。<ol start="2"><li>在<strong>RW STL</strong>中,许多供应容器运用了缓冲区。</li><li>在<strong>SGI  STL</strong>中，使用了专属的、 带有层次配置能力的特殊配置器。</li></ol></li></ol><hr><p>关于STL版本，可以看一下<a href="https://blog.csdn.net/guowenyan001/article/details/11480141">STL版本介绍：HP STL、SGI STL、STL Port、PJ STL、RW STL</a></p><hr><h2 id="SGI-的特殊空间配置器-std-alloc"><a href="#SGI-的特殊空间配置器-std-alloc" class="headerlink" title="SGI 的特殊空间配置器 std::alloc"></a>SGI 的特殊空间配置器 <code>std::alloc</code></h2><blockquote><p>SGI STL是开源软件，源码可读性甚高。在《STL源码剖析》中作者极力推荐阅读，也将它当作目标源码进行剖析。</p><p>在SGI中，提供了两种空间配置器：</p><ol><li>一种是标准的<code>alloctor</code>，但是只是HP默认空间配置器，SGI进行了一层很薄的封装，没有任何效率上的强化。</li><li>另一种时非标准的<code>alloc</code>,就是上面提到的待用层次配置能力，效率优越的特殊配置器。</li></ol></blockquote><p>我们先来分析一下，常用的类声明，对象定义，释放对象的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Foo* p = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="comment">//new 的时候，我们先调用了::operator new 配置内存</span></span><br><span class="line"><span class="comment">//调用Foo的构造函数</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//我们先调用Foo的析构函数</span></span><br><span class="line"><span class="comment">//最后才是::operator delete 释放内存</span></span><br></pre></td></tr></table></figure><p>上面的过程还是非常容易理解的，而在标准的<code>allocator</code>中,规定将new和delete操作分开，由<code>alloc:allocate</code>负责内存的配置，<code>alloc::deallocate</code>负责释放内存。由<code>::construct</code>负责对象的构造，<code>::destroy</code>负责析构对象。</p><p>我们查看·<memory>·头文件，可以看到包含了下面两个头文件</memory></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stl_alloc.h&gt;//负责内存的配置和释放</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stl_construct.h&gt;//负责对象的构造和析构</span></span></span><br></pre></td></tr></table></figure><h3 id="构造和析构的工具construct和destroy"><a href="#构造和析构的工具construct和destroy" class="headerlink" title="构造和析构的工具construct和destroy"></a>构造和析构的工具<code>construct</code>和<code>destroy</code></h3><pre class="mermaid">graph LR    destory["destory()"]--泛化forwardIt_Last_and_first-->_destroy["_destory()"]    _destroy["_destory()"]-->has_trivial_destructor?    has_trivial_destructor?--false_type-->for["foreach_destroy"]    has_trivial_destructor?--true_type-->1["no-op"]    destory["destory()"]--特化char*-->2["no-op"]    destory["destory()"]--特化wchar*-->3["no-op"]    destory["destory()"]--特化pointer-->pointer["pointer->~T()"]</pre><blockquote><p>​    在STL中空间配置时候<code>destory（）</code>函数会判断要释放的迭代器的指向的对象有没有 <code>trivial destructor</code>（STL中有一个 <code>has_trivial_destructor</code>函数，很容易实现检测）放，如果有<code>trivial destructor</code>则什么都不做，如果没有即需要执行一些操作，则执行真正的<code>destory</code>函数。</p><p>​    <code>destory（）</code>有两个版本，第一个版本接受一个指针，准备将该指针所指之物析构掉，第二个版本接受first和last两个迭代器，准备将[first，last]范围内的所有对象析构掉。</p><p>​    我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒，那么一次次调用这些析构函数，对效率是一种伤害，因此这里首先利用<code>value_type()</code>获得迭代器所指对象的类别，再利用<code>_type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒，若是(_true_type)，则什么也不做就结束，若否(_false_type),这才以循环的方式巡访整个范围，并在循环中每经历一个对象就调用第一个版本的destory()。</p></blockquote><hr><p>后面补充<code>value_type()</code>和<code>_type_traits&lt;T&gt;</code>的实现~</p><hr><h3 id="空间的配置和释放stl-alloc"><a href="#空间的配置和释放stl-alloc" class="headerlink" title="空间的配置和释放stl_alloc"></a>空间的配置和释放<code>stl_alloc</code></h3><h4 id="SGI的设计哲学"><a href="#SGI的设计哲学" class="headerlink" title="SGI的设计哲学"></a>SGI的设计哲学</h4><blockquote><ul><li>向堆要求空间</li><li>考虑多线程状态</li><li>考虑内存不足时的应变措施</li><li>考虑内存碎片问题</li></ul></blockquote><h4 id="SGI的双层级配置器"><a href="#SGI的双层级配置器" class="headerlink" title="SGI的双层级配置器"></a>SGI的双层级配置器</h4><blockquote><p>考虑到小型区块可能造成的内存破碎问题，SGI设计了双层级配置器。</p><p>在第一级的配置器中，直接使用<code>malloc()</code>和<code>free()</code>。在第二层的配置器中。当配置区块超过128字节时，认为内存足够大，直接调用一级配置器。反之，认为内存过小，采用内存池memory pool的整理方式。</p><p>配置器的开放级别，取决与<code>__USE_MALLOC</code>是否被定义。在SGI STL中并未定义。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8.png" alt=""></p><p>​    绘制流程图来分析，编译器通过<code>__USE_MALLOC</code>是否定义，来决定配置器的默认级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">judge&#123;__USE_MALLOC?&#125;--yes--&gt;1[将alloc定义为第一级配置器]</span><br><span class="line">judge--ne--&gt;2[将alloc定义为第二级配置器]</span><br><span class="line">1---11[&quot;typedef __malloc_alloc_template&lt;0&gt; malloc_alloc&quot;]</span><br><span class="line">11---111[&quot;typedef malloc_alloc alloc&quot;]</span><br><span class="line">2---22[&quot;typedef __deault_alloc_template&lt;0,0&gt; alloc&quot;]</span><br></pre></td></tr></table></figure><p>​    我们可以观察到，第一级配置器，实际上是<code>__malloc_alloc_template&lt;0&gt;</code>类型的别名，而第二级配置器，实际上是<code>__defualt_alloc_template&lt;0&gt;</code>类型的别名，我们接下来实时剖析这两种类型的实现以及作用吧。</p><h3 id="SGI-一级配置器-malloc-alloc-template"><a href="#SGI-一级配置器-malloc-alloc-template" class="headerlink" title="SGI 一级配置器__malloc_alloc_template"></a>SGI 一级配置器<code>__malloc_alloc_template</code></h3><p>源码以及个人分析注解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW_BAD_ALLOC throw bad_alloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !defined(__THROW_BAD_ALLOC)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THROW_BAD_ALLOC std::cerr&lt;&lt;<span class="meta-string">"out of memory"</span>&lt;&lt;std::endl; exit(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一级空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//处理内存不足的情况</span></span><br><span class="line">    <span class="comment">//oom:  out of memory</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当内存不足时，申请内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">//当内存不足时，重新规划内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">//oom下尝试释放内存的例程</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//配置内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用malloc</span></span><br><span class="line">        <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);   <span class="comment">//第一级配置器直接使用malloc()</span></span><br><span class="line">        <span class="comment">//无法满足需求时，直接使用oom_malloc()</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == result)</span><br><span class="line">            result = oom_malloc(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里直接调用free</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重新规划内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> , <span class="keyword">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用realloc</span></span><br><span class="line">        <span class="keyword">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">        <span class="comment">//无法满足需求时，直接使用oom_realloc()</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == result)</span><br><span class="line">            result = oom_realloc(p, new_sz);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//模仿std::set_new_handler();可以在这里定义自己oom句柄</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span><span class="comment">//函数返回值为函数指针，参数是void (*f)(),即函数指针</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">void</span> (*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = f;</span><br><span class="line">        <span class="keyword">return</span> (old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//malloc_alloc out_of_memory handling</span></span><br><span class="line"><span class="comment">//将指针指向的地址为0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> (*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oom下申请内存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> *__malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (*my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line"><span class="comment">//不断尝试释放,配置,再释放,再配置</span></span><br><span class="line">    <span class="keyword">for</span>(;;)         </span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == my_malloc_handler)</span><br><span class="line">        &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)();<span class="comment">//企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oom下重新规划内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (*my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line"><span class="comment">//与oom_malloc类似，不断尝试释放,配置,再释放,再配置</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler == __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == my_malloc_handler)</span><br><span class="line">        &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)();<span class="comment">//企图释放内存</span></span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n);</span><br><span class="line">        <span class="keyword">if</span>(result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里直接将inst指定为0了</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure><p>​    我们可以看到，SGI一级配置器在oom情况下，进行<code>malloc</code>和<code>realloc</code>时，会循环调用例程<code>__malloc_alloc_oom_handler</code>，如果例程没有被开发者设定，那么就直接cerr，或exit(1)退出。</p><p>​    因此书上也表明：</p><blockquote><p>记住，设计“内存不足处理例程”时客户的责任，设定“内存不足处理例程”也是客端的责任。</p></blockquote><h3 id="SGI-二级配置器-default-alloc-template"><a href="#SGI-二级配置器-default-alloc-template" class="headerlink" title="SGI 二级配置器__default_alloc_template"></a>SGI 二级配置器<code>__default_alloc_template</code></h3><p>​    上文提到，为了避免太多小额区块造成的内存碎片，制定了二级配置器，一般来说，小额区块越小，额外负担的比例也就越大，越显得浪费。在系统中，每索取一块内存，这块内存中都会有一部分是属于系统预留用来记住内存大小的。</p><p>​    我们知道。当区块小于128字节时，二级配置器会采用内存池来管理，而书中解释道，这里指的内存池管理，指配置一大块内存时，维护一个自由链表，为了方便管理，将自由链表存储的内存大小规定为8的倍数。</p><p>​    二级配置器维护着16个自由链表，他们维护的内存大小分别是8,16,24到128，即8*n，n∈[1,16]。</p><p>​    其结构如下，是一个共用体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> obj</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">union</span> obj* free_list_link;</span><br><span class="line">    <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    可以看到设计者的聪明之处，使用了共用体，巧妙地避免了维护链表所必须的指针而造成内存的另一种浪费。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8.png" alt=""></p><p>部分源码以及注解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//区块上调枚举</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//区块上调函数，接收到申请的大小，我们向上取8的倍数</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_t<span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> __bytes)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//链表节点联合体</span></span><br><span class="line">  <span class="keyword">union</span> _Obj &#123;</span><br><span class="line">        <span class="keyword">union</span> _Obj* _M_free_list_link;</span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.*/</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//16个 free-list</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//根据申请的大小，确定出在自由链表的下标</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> __bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回大小为__n的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line">  <span class="comment">//配置一大块空间，可以容纳__nobjs大小个__size的区块</span></span><br><span class="line">  <span class="comment">//可能会随着内存不足，而降低__nobjs数量</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* start_free;        <span class="comment">//内存池起始</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* end_free;          <span class="comment">//内存池结束</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;        <span class="comment">//区块数</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这四个函数是静态数据成员的定义与初始设定</span></span><br><span class="line"><span class="comment">//__threads是线程设定，书中不讨论</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    _NFREELISTS</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    __default_alloc_template&lt;__threads, __inst&gt;::_NFREELISTS</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    看着大部分有些难以理解，但是依然能看出，定义了16个自由链表，可以申请也可以查找。</p><h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数<code>allocate()</code></h3><blockquote><p>​    作为一个空间配置器，自然拥有配置器的标准接口函数<code>allocate()</code>，此函数首先判断区块大小，大于128字节就调用一级配置器，小于128字节就检查对应的自由链表，如果对应链表可用，那么久拿来用，反之，将区块大小上调至8倍数边界，然后调用<code>refill()</code>，重新填充空间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *<span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj *result;</span><br><span class="line">    <span class="comment">//如果申请大小n大于128，直接调用一级配置器</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;(<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用一级配置器的空间配置函数。</span></span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过大小确定自由链表的对应下标</span></span><br><span class="line">    my_free_list=free_list+FREELIST_INDEX(n);</span><br><span class="line">    result=*my_free_list;</span><br><span class="line">    <span class="comment">//如果返回为空</span></span><br><span class="line">    <span class="keyword">if</span>(result==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> *r =refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对自由链表进行调整</span></span><br><span class="line">    *my_free_list=result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E7%BB%B4%E6%8A%A4.png" alt=""></p><h3 id="空间释放函数deallocate"><a href="#空间释放函数deallocate" class="headerlink" title="空间释放函数deallocate()"></a>空间释放函数<code>deallocate()</code></h3><blockquote><p>作为一个空间配置器，自然拥有配置器的标准接口函数<code>deallocate()</code>，此函数首先判断区块大小，大于128字节就调用一级配置器，小于128字节就检查对应的自由链表,回收空间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> * <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *q=(obj *)p;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果申请大小n大于128，直接调用一级配置器</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;(<span class="keyword">size_t</span>)__MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用一级配置器的空间配置函数。</span></span><br><span class="line">        malloc_alloc::deallocate(p,n);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过大小确定自由链表的对应下标</span></span><br><span class="line">    my_free_list=free_list+FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">//回收</span></span><br><span class="line">    q-&gt;free_list_link=*my_free_list;</span><br><span class="line">    *my_free_list=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/%E8%87%AA%E7%94%B1%E9%93%BE%E8%A1%A8%E7%BB%B4%E6%8A%A42.png" alt=""></p><h3 id="空间填充函数refill"><a href="#空间填充函数refill" class="headerlink" title="空间填充函数refill()"></a>空间填充函数<code>refill()</code></h3><blockquote><p>回头讨论先前说过的allocate()。当它发现自由链表中没有可用区块时，会调用refill。缺省取得20个新区块，如果内存池空间不足，获得区块数可能小于20.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads,<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> * __default_alloc_template&lt;threads,inst&gt;::refill(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nobjs=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//调用chunk_alloc(),尝试取得nobjs个区块作为自由链表的新节点。</span></span><br><span class="line">    <span class="comment">//传参nobjs是个引用</span></span><br><span class="line">    <span class="keyword">char</span> *chunk=chunk_alloc(n,nobjs);</span><br><span class="line">    <span class="comment">//自由链表</span></span><br><span class="line">    obj *<span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj *result;</span><br><span class="line">    <span class="comment">//用于连接的前后节点</span></span><br><span class="line">    obj * current_obj,*next_obj;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//如果当前需求只有一个，我们直接返回给调用者，不用添加到自由链表里</span></span><br><span class="line">    <span class="keyword">if</span>(nobjs==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (chunk);</span><br><span class="line">    <span class="comment">//取得目的自由链表</span></span><br><span class="line">    my_free_list=free_list+FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">//显示转换，将result指向新的来的区块头部，后面返回给调用者</span></span><br><span class="line">    result=(obj *)chunk;</span><br><span class="line">    <span class="comment">//chunk+n 是指chunk后移n位，就是下一块区块</span></span><br><span class="line">    *my_free_list=next_obj=(obj *)(chunk +n);</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">1</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current_obj=next_obj;</span><br><span class="line">        <span class="comment">//取得下一区块</span></span><br><span class="line">        next_obj=(obj*)((<span class="keyword">char</span> *)next_obj+n);</span><br><span class="line">        <span class="comment">//当连接数量满足时，跳出</span></span><br><span class="line">        <span class="keyword">if</span>(nobjs<span class="number">-1</span>==i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把尾部指向0/nullptr</span></span><br><span class="line">            current_obj-&gt;free_list_link=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            current_onj-&gt;free_list_link=next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看完代码，就很好理解<code>refill()</code>的作用了,通过<code>chunk_alloc()</code>申请到新的区块，然后如同正常连接链表般把几个区块转换成共用体obj，再连接起来。在此之前让对应的自由链表指向第二块区块(第一块要给调用者)。</p><p>​    那么唯一不明白的就是<code>chunk_alloc()</code>时如何工作的。</p><h3 id="空间分块函数chunk-alloc"><a href="#空间分块函数chunk-alloc" class="headerlink" title="空间分块函数chunk_alloc()"></a>空间分块函数<code>chunk_alloc()</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads,<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> * __default_alloc_template&lt;threads,inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size,<span class="keyword">int</span> &amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> * result;</span><br><span class="line">    <span class="comment">//需求的内存大小</span></span><br><span class="line">    <span class="keyword">size_t</span> total_bytes=size*nobjs;</span><br><span class="line">    <span class="comment">//计算内存剩余空间</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes_left=end_free-start_free;</span><br><span class="line">    <span class="comment">//容量足够</span></span><br><span class="line">    <span class="keyword">if</span>(bytes_left &gt;= total_bytes)</span><br><span class="line">    &#123;</span><br><span class="line">        result=start_free;</span><br><span class="line">        <span class="comment">//将剩余的开始位置偏移调整</span></span><br><span class="line">        start_free+=total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量不足以全部产出，但是还可以‘挤’出几块块</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算还可以‘挤’出几块</span></span><br><span class="line">        nobjs=bytes_left/size;</span><br><span class="line">        <span class="comment">//新的需求大小</span></span><br><span class="line">        total_bytes=size*nobjs;</span><br><span class="line">        result=start_free;</span><br><span class="line">        <span class="comment">//将剩余的开始位置偏移调整</span></span><br><span class="line">        start_free+=total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一块也‘挤’不出</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里获得要使用malloc申请的内存大小，建议申请的大小是当前需求的两倍加上ROUND_UP(heap_size&gt;&gt;4)，不过目前无法理解右移4位的意思</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get=<span class="number">2</span>*total_bytes+ROUND_UP(heap_size&gt;&gt;<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//如果剩余一丁点内存</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_left&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//用剩余内存大小去找到对应的自由链表</span></span><br><span class="line">            obj * <span class="keyword">volatile</span> * my_free_list=free_list+FREELIST_INDEX(bytes_left);</span><br><span class="line">            <span class="comment">//数组对应自由链表头-&gt;剩余内存大小的块-&gt;原本的自由链表</span></span><br><span class="line">            ((obj *)start_free)-&gt;free_list_link=*my_free_list;</span><br><span class="line">            *my_free_list=(obj*)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用malloc申请大小</span></span><br><span class="line">        start_free=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="comment">//申请失败</span></span><br><span class="line">        <span class="keyword">if</span>(start_free==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            obj * <span class="keyword">volatile</span> * my_free_list,*p;</span><br><span class="line">            <span class="comment">//每次i+8</span></span><br><span class="line">             <span class="keyword">for</span> (i = size;i &lt;= (<span class="keyword">size_t</span>) __MAX_BYTES;i += (<span class="keyword">size_t</span>) __ALIGN) </span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//从下标0到15，检索所有自由链表</span></span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                 <span class="comment">//如果某个链表还有区块</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;</span><br><span class="line">                    <span class="comment">//我们取一块区块出来</span></span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;</span><br><span class="line">                    <span class="comment">//把这块当作新的内存池可用空间</span></span><br><span class="line">                    start_free = (<span class="keyword">char</span>*)p;</span><br><span class="line">                    end_free = start_free + i; </span><br><span class="line">                    <span class="comment">//再调用自身，看看这个区块的内存是否足够</span></span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        end_free = <span class="number">0</span>;   </span><br><span class="line">            <span class="comment">//调用一级配置器，看看oom下是否可以尽力完成</span></span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="comment">//递归自己，修正nobjs？</span></span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    不难看出，<code>chunk_alloc()</code>的作用是尽力分配内存池给目标自由链表，当内存池足够时，返回需求的对应区块，不够就能产多少产多少，当一块区块都产不出的时候，开始遍历所有自由链表，尝试把它们的区块收纳，然后交给对应自由链表。</p><p>​    如果真的无法挤出内存了，就调用一级配置器，而一级配置器是直接使用<code>malloc()</code>申请内存的，因为内存已经没了，必定调用<code>oom_malloc()</code>，不断由例程释放内存，申请内存。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote><p>假设程序一开始，客端就调用<code>chunk_alloc(32,20)</code>,对应的free_list[3]空空如也，此时内存池为空，于是<code>malloc()</code>配置40个32字节的区块。并把第一个交给调用者，剩下19个交给free_list[3]维护，剩下20个交给内存池。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/chunk1.png" alt=""></p><blockquote><p>客端接着调用<code>chunk_alloc(64,20)</code>,对应的free_list[7]空空如也，内存池是20*32字节大小的连续内存，可以分成10块64字节大小的区块，把第一块返回给调用者，剩下9块加入到对应的自由链表free_list[7]，此时内存池为空。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/STL/chunk2.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="空间配置器的作用"><a href="#空间配置器的作用" class="headerlink" title="空间配置器的作用"></a>空间配置器的作用</h3><ol><li>在容器中，负责申请内存空间、 释放空间，对存储的对象进行构造和析构。</li><li>在析构的时候，会智能的判断，避免不重要的多次析构。</li></ol><h3 id="SGI一级配置器"><a href="#SGI一级配置器" class="headerlink" title="SGI一级配置器"></a>SGI一级配置器</h3><ol><li>直接调用<code>malloc()</code>和<code>free()</code>对内存进行操作。</li><li>内存不足时，进入oom(out of memory)状态，此时操作内存时，会调用留给客端实现的内存释放例程，一直释放、 申请，直到满足条件或者报错。</li></ol><h3 id="SGI二级配置器"><a href="#SGI二级配置器" class="headerlink" title="SGI二级配置器"></a>SGI二级配置器</h3><ol><li>二级配置器时为了尽量避免小额区块产生的内存碎片。</li><li>在SGI中，很多配置器都被缺省为二级配置器，例如<code>sample_alloc</code>。</li><li>如果申请内存空间时，大小大于128字节，则直接调用一级配置器。</li><li>维护16个自由链表，每个自由链表维护n个8倍数的内存区块共用体，它们之间通过指针相连。</li><li>对应自由链表没有区块时，会调用<code>refill()</code>以及<code>chunk_alloc()</code>，前者作用时将后者产出的区块维护成链表，交给对应的自由链表，后者负责操作内存，如果内存池不为空，那么利用内存池分块，将区块产出，如果内存是为空，那么调用<code>malloc()</code>，申请两倍的区块所需大小的内存，一半给自由链表，一半给内存池。</li><li>如果内存为0，调用一级配置器，尝试通过oom机制释放内存。</li></ol>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;常用算法的C++实现&gt;堆排序</title>
      <link href="/2019/MyAlgorithm-heapSort/"/>
      <url>/2019/MyAlgorithm-heapSort/</url>
      
        <content type="html"><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>这里的堆指的是数据结构的堆,不是操作系统中内存的堆。</p><p>堆是一种特殊的完全二叉树,特殊之处在于它的每一个点都比自身的子节点的值更大或者更小(区别于搜索树,搜索树是左子节点比右子节点更大或更小)。</p><p>而我们常说的小根堆和大根堆,指的就是上述中每个点都比自身的子节点值更大(最大堆)/更小(最小堆)。</p></blockquote><p><img width="400" src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%B9%E5%A0%86%E5%9B%BE.png"></p><p><img width="400" src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%9B%BE.png"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>简单的了解了一下什么是堆之后,我们来了解一下什么是堆排序。</p></blockquote><h3 id="堆的存储方式"><a href="#堆的存储方式" class="headerlink" title="堆的存储方式"></a>堆的存储方式</h3><blockquote><p>我们知道二叉树的存储方式可以是连续式的数组array,和连接式的树tree。</p><p>不过对于堆排序,通常都是用数组来存储数据,因为我们可以随机访问数据,并且进行快速交换。</p><p>对于下标从0开始的数组中,我们有以下三种性质:</p><ol><li>索引为i的左孩子的索引是 (2*i+1);</li><li>索引为i的左孩子的索引是 (2*i+2);</li><li>索引为i的父结点的索引是 ((i-1)/2);</li></ol></blockquote><p><img width="600" src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%A0%B9%E5%A0%86.png"></p><center>数组上面的箭头代表右节点,下面的箭头代表左节点</center><h3 id="堆排序的思想"><a href="#堆排序的思想" class="headerlink" title="堆排序的思想"></a>堆排序的思想</h3><blockquote><ol><li>我们先把需要排序的数据进行初始化堆的操作,也就是把它们变成最大堆或者最小堆的形式。</li><li>每一次我们让根节点值[0]和最后一层的最右节点[n]的值交换,之后最右子节点的值[n]绝对是当前最大或者最小的。因为性质决定根节点的值是最大或者最小。</li><li>重新对0到n-1进行初始化堆操作。</li><li>重新2操作,3操作,直到0&gt;n-1。</li></ol></blockquote><h3 id="一些可能出现的疑问"><a href="#一些可能出现的疑问" class="headerlink" title="一些可能出现的疑问"></a>一些可能出现的疑问</h3><p>1.初始化的时候就是最大/小堆了,为何不能直接输出呢?</p><blockquote><p>因为根堆只能保证节点比子节点大或者小,但是不能保证子节点两个的大小顺序。</p></blockquote><p>2.堆排序的使用时机</p><blockquote><p>需要找到最大/小的k个元素,如果用插入排序也是需要遍历一整边,时间复杂度更大。而快排在大量数据中仅找到数个最大最小时,所用的空间复杂度更大。</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="初始化堆"><a href="#初始化堆" class="headerlink" title="初始化堆"></a>初始化堆</h2><blockquote><p>如上方<a href="#堆的存储方式">堆的存储方式</a>中所述,由数组存储的第三个性质得,根堆中相对最后的节点下标为(n-1)/2,因此我们需要从该节点开始,对每一个结点和它的子节点进行对比和替换。</p><p>把当前点和子节点对比,如果子节点有更大的,那么进行替换。同样的,还要把自身比较孙子节点,进行同样的操作,因为无法保证当前节点的值比子节点小/大多少。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大堆的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a:数组指针</span></span><br><span class="line"><span class="comment">//_begin:开始下标</span></span><br><span class="line"><span class="comment">//_end:结束下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHeapMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> _begin,<span class="keyword">int</span> _end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确定开始下标</span></span><br><span class="line">    <span class="keyword">int</span> start=_begin;</span><br><span class="line">    <span class="comment">//当前最大子节点</span></span><br><span class="line">    <span class="keyword">int</span> maxChild;</span><br><span class="line">    <span class="comment">//当前节点的值,用来对比</span></span><br><span class="line">    <span class="keyword">int</span> value=a[start];</span><br><span class="line">    <span class="comment">//我们从当前节点的左子节点开始,即2*i+1</span></span><br><span class="line">    <span class="comment">//如果发现子节点比当前节点还要大/小,那么我们还要对这个子节点以及它的子节点进行一次比较</span></span><br><span class="line">    <span class="keyword">for</span>(maxChild=<span class="number">2</span>*start+<span class="number">1</span>;maxChild&lt;_end;start=maxChild,maxChild=<span class="number">2</span>*maxChild+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果右子节点的值比左子节点的还大,那么就选右子节点,最小堆则改成大于即可</span></span><br><span class="line">        <span class="keyword">if</span>(maxChild&lt;_end<span class="number">-1</span> &amp;&amp; a[maxChild]&lt;a[maxChild+<span class="number">1</span>])</span><br><span class="line">            maxChild++;</span><br><span class="line">        <span class="comment">//如果当前节点的值比子节点的所有值都大,那么说明这一个小堆(相对来说)不需要初始化了</span></span><br><span class="line">        <span class="keyword">if</span>(value&gt;=a[maxChild])<span class="comment">//最小堆则改成小于等于即可</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则,替换</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[start]=a[maxChild];</span><br><span class="line">            a[maxChild]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote><p>我们替换第一个节点和最后一层的右边叶子节点,这时最后一层的右边叶子节点就是最大/最小的,然后把这个节点提取出去,将剩下的再初始化一次,继续这个操作,我们就可以依次提取出最大/小的值放在最后。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a:数组指针</span></span><br><span class="line"><span class="comment">//length:需要排序的长度(第几大/小)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _size=a.size();</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//从最后一个非子节点开始初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(_size<span class="number">-2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        InitHeapMax(a,i,_size);</span><br><span class="line">    <span class="comment">//提取length个增序或者降序的元素</span></span><br><span class="line">    <span class="comment">//for(int i=_size-1;i&gt;=_size-length;i--)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=_size<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//替换操作，让a[i]为当前极值</span></span><br><span class="line">        value=a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>]=a[i];</span><br><span class="line">        a[i]=value;</span><br><span class="line">        <span class="comment">//将第 _size-i 大/小的元素加入b</span></span><br><span class="line">       <span class="comment">//b.push_back(value);</span></span><br><span class="line">        <span class="comment">//重新对剩下的排序</span></span><br><span class="line">        InitHeapMax(a,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果初始化堆的操作是最大堆，那么最后这个数组排序的结果为增序，第一个值为最小值。</p><p>如果是最小堆，那么为降序，第一个值是最大值。</p><p>如果是为了取n个从最小值增序、最大值 降序的元素，应该反过来，在排序的过程中提取，会减少不少时间。</p><p>比如第一个值是最小值的增序序列：</p><p>​    使用最小堆的初始化，排序的时候每次都会取到当前最小的值，添加到新数组中即可，取到一定数量就可以结束了，不需要将剩下的排序。</p><p>​    如果使用最大堆的初始化，那么我们需要整个排序一边，才会得到一个从小到大的序列，再取前面的n个元素达到要求。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《图解TCP/IP》之IP协议</title>
      <link href="/2019/MyLearn-ComputerNetwork-3/"/>
      <url>/2019/MyLearn-ComputerNetwork-3/</url>
      
        <content type="html"><![CDATA[<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><h2 id="网络层的作用"><a href="#网络层的作用" class="headerlink" title="网络层的作用"></a>网络层的作用</h2><blockquote><p>IP协议运作于网络层，它的底层是数据链路层。数据链路层的作用是在两个物理设备之间传输数据，而IP协议就是两台主机之间通信，期间可能会经过很多台物理设备的转发。</p><p>书上用旅游的例子来说明：</p><p>​    去异国旅游，我们去旅行社购买一整套的服务，旅行社说，需要先坐飞机到外国，然后坐火车到某个城市，再坐公交到具体的目的地。</p><p>仔细去揣摩，坐飞机、坐火车、坐公交都某个区间内的移动方式，坐飞机需要的飞机票、坐火车的火车票和公交车的票(当作有)。这些票据上面都注明了目的地和源地点(从x到y)，联想到数据链路层的作用，即在上层的数据中加上自己的首部数据：源和目的MAC地址。</p><p>可以发现，数据链路层都是将整个旅行路线分成一小块，从而执行一小块的任务。</p><p>那么这整个旅行路线(行程表)就是网络层的作用。</p><p><strong>计算机网络中需要数据链路层和网络层这个分层才能实现向最终目的地址的通信。</strong></p></blockquote><h2 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h2><h3 id="面向无连接的ip协议"><a href="#面向无连接的ip协议" class="headerlink" title="面向无连接的ip协议"></a>面向无连接的ip协议</h3><blockquote><p>ip协议不是面向连接的，它不需要两个主机之间建立网络连接。</p><p>为何是面向无连接？</p><ol><li>为了简化，如果每一次调用ip协议都需要建立连接实在太繁琐了。</li><li>为了提速，建立连接必然造成处理速度的下降。</li></ol><p>大家都知道，面向无连接是不可靠且不安全的，如果有需要，就得需要上一层的实现(TCP协议)。</p></blockquote><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><blockquote><p>数据链路层会将数据发给下一个物理设备，但是ip首部数据只有ip地址，数据链路层的首部数据只有目的物理设备的mac地址做为参照，那么数据到达下一个物理设备的时候，谁告诉它相对下一个物理设备在哪呢。</p><p>这就需要路由控制去解决了。</p><p>路由器(物理设备)中的内存存储着路由表，它记录着到达目的地需要转跳的下一个物理设备的位置信息（拓扑结构）。</p><p>数据包到达路由器的时候，路由器分析IP地址，然后找到一条最佳的数据链路，将数据包发过去。</p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><blockquote><p>ip地址属于网络层地址，在数据链路层传输数据的过程中不需要重新设置ip地址，只需要将ip地址转换成比特流或者对帧数据进行转发即可。</p></blockquote><h4 id="ip地址的定义"><a href="#ip地址的定义" class="headerlink" title="ip地址的定义"></a>ip地址的定义</h4><blockquote><p>ipv4地址由32位01整数来表示。然后每8位为一组。通常每组以10进程的形式表示。如常见的本机局域网地址：192.168.1.1。</p><p>2^32很大，所以最多允许2的32次方个计算机连接到网络。当然实际上不会有那么多计算机同时联网。</p></blockquote><h4 id="ip地址的组成"><a href="#ip地址的组成" class="headerlink" title="ip地址的组成"></a>ip地址的组成</h4><blockquote><p>一个ip地址其实是由<strong>网络标识</strong>和<strong>主机标识</strong>组成，简单来说，在同一个网络端下拥有多个主机，这里面的每一个主机的网络标识都是一样的，知识主机标识不一样，在这里通过主机标识区分。</p><p>例如局域网，都是192.168.1.x。x则是主机标识。</p><p>那么用什么来区分一个ip地址的哪一部分是网络标识和主机标识呢。</p></blockquote><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><blockquote><p>子网掩码的格式和ip地址的格式一样，都是32位01整数组成，将子网掩码与ip地址与运算节能得到这个ip地址的网段。</p></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的虚函数表知识总结</title>
      <link href="/2019/MyLearn-VirtualCpp/"/>
      <url>/2019/MyLearn-VirtualCpp/</url>
      
        <content type="html"><![CDATA[<h2 id="为VS中的CPP属性添加一行代码"><a href="#为VS中的CPP属性添加一行代码" class="headerlink" title="为VS中的CPP属性添加一行代码"></a>为VS中的CPP属性添加一行代码</h2><blockquote><p>我们在VS2017中新建一个CPP工程，并新建一个源文件。</p><p>在这个工程中，我们右键属性，在C++那一项的命令行子项中添加以下代码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/d1 reportAllClassLayout</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E8%AE%BE%E7%BD%AE.png" alt=""></p><blockquote><p>加上这行代码，可以在编译时，在<strong>输出</strong>窗口输出内存分布的信息。</p></blockquote><h2 id="有虚函数的类与无虚函数的类对比"><a href="#有虚函数的类与无虚函数的类对比" class="headerlink" title="有虚函数的类与无虚函数的类对比"></a>有虚函数的类与无虚函数的类对比</h2><blockquote><p>我们新建两个类，分别为A和B，他们其中一个类拥有虚函数。</p><p>每一个类中有两个整形成员。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A();</span><br><span class="line">~A();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B();</span><br><span class="line"><span class="keyword">virtual</span> ~B();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其中B类拥有虚析构函数以及一个普通虚函数。我们生成解决方案，查看输出窗口。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E5%AF%B9%E6%AF%941.png" alt=""></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><blockquote><p>从图上往下解释：</p><p>A这个类占用内存中的8个字节。其中有两个成员ab分别占了4个字节，他们的首地址偏移量为0和4。</p><p>B这个类占用内存中的12个字节。其中发现了一个叫vfptr的成员(即虚函数表的指针)占用了4个字节。随后是两个成员ab分别占了4个字节，他们的首地址偏移量为4和8。</p><p>B:: vftavle ，即B作用域中的虚函数表，在这个表中标记了两个虚函数，分别是dtor(destructor析构函数的缩写)，以及fun。</p><p>​    其中，在虚函数表中左边的编号不是占用的字节，而是函数的编号。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ol><li>从内存分布来看，成员函数无论是否是virtual的，都不在类中，而成员变量则在。(类的非静态成员变量信息在栈上，函数在代码区里)</li><li>当类中存在虚函数的时候，系统会给它分配一个虚函数表，里面记录了这个类拥有的虚函数的指针。</li><li>当类中存在虚函数的时候，系统会给它分配一个虚函数表指针，用来指向2中的虚函数表，而这个虚函数表指针位于其内存的首位。(偏移量为0)</li></ol></blockquote><h2 id="有虚函数类的单继承：重写与不重写"><a href="#有虚函数类的单继承：重写与不重写" class="headerlink" title="有虚函数类的单继承：重写与不重写"></a>有虚函数类的单继承：重写与不重写</h2><blockquote><p>我们定一个基类A，拥有两个整形成员ab，以及虚析构函数和普通虚函数fun。</p><p>定义两个派生类SA1和SA2，它们各自拥有一个新整形成员c，其中SA2重写了基类A中的fun以及自己的析构函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~A()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SA1</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SA2</span> :</span><span class="keyword">public</span>  A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~SA2()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>查看输出窗口</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E5%AF%B9%E6%AF%942.png" alt=""></p><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><blockquote><p>从图上往下解释：</p><p>SA1这个类占用内存中的16个字节。其中先排布了基类A的成员信息，与上面第一张图一样，分别是虚函数表指针、成员a、b，分别占用4字节。随后是排布SA1自己的整形成员c，占用字节4。</p><p>随后是SA1的虚函数表，可以看到，虚函数表中的fun函数作用域是基类A。而析构函数是SA1本身。(C++中的类会默认帮你生成四个默认函数：构造、析构、浅拷贝、赋值(返回浅拷贝)，如果你自己实现了，则不会再生成)</p><p>SA2这个类占用内存中的16个字节。内容排版和SA1一样。</p><p>随后是SA1的虚函数表，可以看到，虚函数表中的函数作用域都是是SA2本身。</p><p>因为我们重写了基类的虚函数。</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><ol><li><p>派生类在内存的分布上，首先排布自己的基类成员信息，包含基类的虚函数表指针。基类成员信息的排版顺序和基类自身的一致。    </p><p>​    随后才是自己的成员信息。</p></li><li><p>内存会为拥有虚函数的基类的派生类再生成一个虚函数表，里面指名了虚函数，如果重写了虚函数，则会被覆盖。</p></li><li><p>内存中存储基类信息中的虚函数指针不再指向基类的虚函数表，而是自己的虚函数表。</p></li></ol></blockquote><h2 id="有虚函数基类的多重继承"><a href="#有虚函数基类的多重继承" class="headerlink" title="有虚函数基类的多重继承"></a>有虚函数基类的多重继承</h2><blockquote><p>多重继承就是爷爷-&gt;爸爸-&gt;儿子。简单理解为一条从上到下的线性继承。</p><p>我们定义三个类，也有这样的继承关系：A-&gt;B&gt;C。</p><p>其中A有虚函数fun和fun1。</p><p>B有虚函数fun2并重写虚函数fun1。</p><p>C重写虚函数fun、fun1、fun2.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>因为输出窗口截图太长了，所以直接赋值上来了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1&gt;class Asize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;A::$vftable@:</span><br><span class="line">1&gt;| &amp;A_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;A::fun</span><br><span class="line">1&gt; 1| &amp;A::fun1</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1&gt;class Bsize(12):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class A)</span><br><span class="line">1&gt; 0| | &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| | a</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt; 8| b</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vftable@:</span><br><span class="line">1&gt;| &amp;B_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;A::fun</span><br><span class="line">1&gt; 1| &amp;B::fun1</span><br><span class="line">1&gt; 2| &amp;B::fun2</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1&gt;class Csize(16):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class B)</span><br><span class="line">1&gt; 0| | +--- (base class A)</span><br><span class="line">1&gt; 0| | | &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| | | a</span><br><span class="line">1&gt;| | +---</span><br><span class="line">1&gt; 8| | b</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt;12| c</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vftable@:</span><br><span class="line">1&gt;| &amp;C_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;C::fun</span><br><span class="line">1&gt; 1| &amp;B::fun1</span><br><span class="line">1&gt; 2| &amp;C::fun2</span><br></pre></td></tr></table></figure><h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><blockquote><ol><li><p>基类A占用8个字节，分别是虚函数表指针和成员a。</p><p>​    在虚函数表中，函数fun和fun1作用域都属于自己。</p></li><li><p>派生类B占用12个字节，分别是基类A的虚函数表指针和成员a。加上自己的成员b。其中虚函数表指针指向自己的虚函数表而不是基类A。</p><p>​    在虚函数表中，因为重写了虚函数fun1，并且新增一个虚函数fun2，基类A的虚函数fun的作用域属于A。</p></li><li><p>派生类C占用16个字节，分别是基类A的虚函数表指针和成员a。和基类B的成员b，加上自己的成员c。其中虚函数表指针指向自己的虚函数表而不是基类B。</p><p>​    在虚函数表中，因为重写了基类的所有的虚函数fun、2，作用域都是自己。保留未重写的虚函数fun1。因为fun1来自基类B，而B重写了来自基类A的虚函数fun1，所以在C中，fun1依然属于B类。</p></li></ol></blockquote><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote><ol><li>虚函数表中只会记录基类的虚函数地址(或被重写的)，以及自己的新虚函数地址。</li><li>可以理解虚函数表中记录的虚函数地址都是相对于当前类最新的虚函数(即只要被重写的虚函数，都会替代)。</li></ol></blockquote><h2 id="多继承与虚继承"><a href="#多继承与虚继承" class="headerlink" title="多继承与虚继承"></a>多继承与虚继承</h2><h3 id="多继承的二义性"><a href="#多继承的二义性" class="headerlink" title="多继承的二义性"></a>多继承的二义性</h3><blockquote><p>JAVA中没有多继承，为何？因为多继承容易造成二义性。</p><p>我们来看看下面的代码。</p><p>创建了三个基类ABC，其中ABC都有相同名字的虚函数fun以及相同名字的char类型成员x。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"来自A的fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'B'</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"来自B的fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'C'</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"来自C的fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> A,  B,  C</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funSon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我们再创建了一个派生类Son，多继承于A,B,C。</p><p>这个时候我们通过Son对象去访问fun函数和x成员会发生什么？</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%8D%E6%98%8E%E7%A1%AE.png" alt=""></p><blockquote><p>不说编译器，就算是写出代码的我们，也不知道这个Son到底是指谁。</p><p>那我们向上转换呢，结果是当然，因为我们告诉了编译器，我们想要谁的函数和成员。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E5%90%91%E4%B8%8A%E8%BD%AC%E6%8D%A2%E4%B8%8D%E5%86%8D%E6%8A%A5%E9%94%99.png" alt=""></p><center>向上转换后不再报错</center><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E5%90%91%E4%B8%8A%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BB%93%E6%9E%9C.png" alt=""></p><center>正确输出结果</center><blockquote><p>好，我们已经领略到多继承因同名而引发的二义性。这个时候我们看看这段代码在内存中的分布如何。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">1&gt;class Asize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| x</span><br><span class="line">1&gt;  | &lt;alignment member&gt; (size=3)</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;A::$vftable@:</span><br><span class="line">1&gt;| &amp;A_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;A::fun</span><br><span class="line">1&gt; 1| &amp;A::funA</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1&gt;class Bsize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| x</span><br><span class="line">1&gt;  | &lt;alignment member&gt; (size=3)</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vftable@:</span><br><span class="line">1&gt;| &amp;B_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;B::fun</span><br><span class="line">1&gt; 1| &amp;B::funB</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1&gt;class Csize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| x</span><br><span class="line">1&gt;  | &lt;alignment member&gt; (size=3)</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vftable@:</span><br><span class="line">1&gt;| &amp;C_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;C::fun</span><br><span class="line">1&gt; 1| &amp;C::funC</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1&gt;class Sonsize(24):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class A)</span><br><span class="line">1&gt; 0| | &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| | x</span><br><span class="line">1&gt;  | | &lt;alignment member&gt; (size=3)</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt; 8| +--- (base class B)</span><br><span class="line">1&gt; 8| | &#123;vfptr&#125;</span><br><span class="line">1&gt;12| | x</span><br><span class="line">1&gt;  | | &lt;alignment member&gt; (size=3)</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt;16| +--- (base class C)</span><br><span class="line">1&gt;16| | &#123;vfptr&#125;</span><br><span class="line">1&gt;20| | x</span><br><span class="line">1&gt;  | | &lt;alignment member&gt; (size=3)</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;Son::$vftable@A@:</span><br><span class="line">1&gt;| &amp;Son_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;A::fun</span><br><span class="line">1&gt; 1| &amp;A::funA</span><br><span class="line">1&gt; 2| &amp;Son::funSon</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;Son::$vftable@B@:</span><br><span class="line">1&gt;| -8</span><br><span class="line">1&gt; 0| &amp;B::fun</span><br><span class="line">1&gt; 1| &amp;B::funB</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;Son::$vftable@C@:</span><br><span class="line">1&gt;| -16</span><br><span class="line">1&gt; 0| &amp;C::fun</span><br><span class="line">1&gt; 1| &amp;C::funC</span><br></pre></td></tr></table></figure><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><blockquote><p>基类ABC不再多解释。</p><p>我们直接看派生类Son，在内存中，基类的信息按照多继承时的左到右的顺序排序，也就是A-&gt;B-&gt;C。</p><p>每一个基类成员中，都包含有指向对应虚函数表的指针以及一个char成员x。</p><p>然后有一段  <alignment member=""> (size=3)  的代码。在这里解释一下，是补充了3个字节的意思。</alignment></p><p>(为什么是三个字节，因为在整个基类成员中，占位最大的是虚函数表指针，即4个字节，那么我们就需要按照它去对齐，所以在占有一个字节的char后面补充了三个字节，这是内存对齐的知识点)</p><p>随后是三张虚函数表，偏移量从0到-8再到-16。三张表中的虚函数地址都指对应自己类中的虚函数。</p><p>在第一个虚函数表中，多出了派生类的新虚函数。</p></blockquote><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><blockquote><p>在派生类对象调用相同名字的虚函数时，会产生二义性，编译器无法知道我们到底想调用哪一个虚函数表指针的虚函数。而向上转换后，明确的告诉编译器我们调用的虚函数指针是哪个基类成员中的，这样就能正确调用那个基类的虚函数。</p><p>派生类新增虚函数，放在声明的第一个基类的虚函数表中</p></blockquote><h4 id="重写多继承中的虚函数"><a href="#重写多继承中的虚函数" class="headerlink" title="重写多继承中的虚函数"></a>重写多继承中的虚函数</h4><blockquote><p>我们将上面的代码改成这样：重写Son中对ABC的虚函数fun</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Son : A, B, C</span><br><span class="line">&#123;</span><br><span class="line">virtual void fun()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;来自Son的fun&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>查看内存分布：</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E9%87%8D%E5%86%99%E5%A4%9A%E7%BB%A7%E6%89%BF.png" alt=""></p><blockquote><p>我们发现，派生类中对应基类A的虚表（虚函数表）的fun已经改变，作用域为Son。</p><p>而虚表B、C中的fun虚函数指针已经了一个goto语句，即将内存偏移x位到达虚表A，从A中读取fun函数。(编译器多聪明，不需要另建指针)。</p></blockquote><hr><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><blockquote><p>虚继承就是在继承时候在基类名字前加上 virtual 关键字。</p></blockquote><h4 id="没有虚函数的虚继承多重继承-包含单继承"><a href="#没有虚函数的虚继承多重继承-包含单继承" class="headerlink" title="没有虚函数的虚继承多重继承(包含单继承)"></a>没有虚函数的虚继承多重继承(包含单继承)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1&gt;class Asize(4):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| x</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Bsize(12):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vbptr&#125;</span><br><span class="line">1&gt; 4| y</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt; 8| x</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vbtable@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 8 (Bd(B+0)A)</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A       8       0       4 0</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Csize(20):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vbptr&#125;</span><br><span class="line">1&gt; 4| z</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt; 8| x</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base B)</span><br><span class="line">1&gt;12| &#123;vbptr&#125;</span><br><span class="line">1&gt;16| y</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vbtable@C@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 8 (Cd(C+0)A)</span><br><span class="line">1&gt; 2| 12 (Cd(C+0)B)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vbtable@B@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| -4 (Cd(B+0)A)</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A       8       0       4 0</span><br><span class="line">1&gt;               B      12       0       8 0</span><br></pre></td></tr></table></figure><h6 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h6><blockquote><p>基类A占四个字节，即自身成员x。</p><p>派生类B占8个字节，多了一个vbptr(虚基表指针)的指针，随后是自己的成员y，才到A类中的成员x。</p><p>vbtable字段中的值代表访问某个虚基表的内存偏移量。</p><p>vbi字段：</p><p>class ：虚基表的类名</p><p>offset：内存偏移量</p><p>vbptr：虚基表指针位置</p><p>vbte：母鸡0 0</p><p>fvtorDisp: 下面引用于<a href="https://www.cnblogs.com/fanzhidongyzby/archive/2013/01/14/2860015.html">关于vtordisp知多少？</a></p><hr><p>MSDN给出的解释是：<strong>虚继承中派生类重写了基类的虚函数，并且在构造函数或者析构函数中使用指向基类的指针调用了该函数，编译器会为虚基类添fVtorDisp域。</strong></p><p>然而，经过VS2010的测试，我们发现上述示例代码便会产生vtordisp字段！条件是。</p><ol><li><p>派生类重写了虚基类的虚函数。</p></li><li><p>派生类定义了构造函数或者析构函数。</p></li></ol><hr></blockquote><h6 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h6><blockquote><p>我们看到，只要虚继承于一个基类，就会为其创建一个虚基表，并且在内存首部生成一个虚基表指针。</p><p>而且，派生类的成员变量内存分布永远在前面(在虚基表指针的后面)，其次是基类的基类成员(如果有)，再到基类的成员。</p><p>下面引用于<a href="https://www.cnblogs.com/yanqi0124/p/3830433.html">C++ 继承之虚继承与普通继承的内存分布</a></p><hr><ol><li>普通继承情况下，先父类元素后子类元素，若父类元素本身也是从某个爷爷类继承而来：父类是虚继承而来，则先父后子再爷爷（其实这个分布是满足规则2的）,即爷爷放在最后；父类是普通继承而来，先爷爷后父再子，即爷爷放在前面。</li><li>虚继承情况下，先子类元素后父类元素，如果父类元素本身也是从某个爷爷类继承（不论是虚继承还是普通继承）而来，则父类由类的深到浅依次分布（先爷爷后父，爷爷在子和父之间）。</li></ol><hr></blockquote><h4 id="有虚函数的虚继承多重继承-包含单继承"><a href="#有虚函数的虚继承多重继承-包含单继承" class="headerlink" title="有虚函数的虚继承多重继承(包含单继承)"></a>有虚函数的虚继承多重继承(包含单继承)</h4><blockquote><p>新建三个基类ABC，每个基类拥有自己不同名的成员变量。每个基类都有自己的虚函数。</p><p>ABC父子关系为A-&gt;B-&gt;C。</p><p>其中BC重写A的虚函数fun。</p><p>派生类D重写所有虚函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">virtual</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">1&gt;class Asize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;A::$vftable@:</span><br><span class="line">1&gt;| &amp;A_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;A::fun</span><br><span class="line">1&gt; 1| &amp;A::funA</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Bsize(20):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| &#123;vbptr&#125;</span><br><span class="line">1&gt; 8| b</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt;12| &#123;vfptr&#125;</span><br><span class="line">1&gt;16| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vftable@B@:</span><br><span class="line">1&gt;| &amp;B_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;B::funB</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vbtable@:</span><br><span class="line">1&gt; 0| -4</span><br><span class="line">1&gt; 1| 8 (Bd(B+4)A)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vftable@A@:</span><br><span class="line">1&gt;| -12</span><br><span class="line">1&gt; 0| &amp;B::fun</span><br><span class="line">1&gt; 1| &amp;A::funA</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A      12       4       4 0</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Csize(32):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vfptr&#125;</span><br><span class="line">1&gt; 4| &#123;vbptr&#125;</span><br><span class="line">1&gt; 8| c</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt;12| &#123;vfptr&#125;</span><br><span class="line">1&gt;16| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base B)</span><br><span class="line">1&gt;20| &#123;vfptr&#125;</span><br><span class="line">1&gt;24| &#123;vbptr&#125;</span><br><span class="line">1&gt;28| b</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vftable@:</span><br><span class="line">1&gt;| &amp;C_meta</span><br><span class="line">1&gt;|  0</span><br><span class="line">1&gt; 0| &amp;C::funC</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vbtable@C@:</span><br><span class="line">1&gt; 0| -4</span><br><span class="line">1&gt; 1| 8 (Cd(C+4)A)</span><br><span class="line">1&gt; 2| 16 (Cd(C+4)B)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vftable@A@:</span><br><span class="line">1&gt;| -12</span><br><span class="line">1&gt; 0| &amp;C::fun</span><br><span class="line">1&gt; 1| &amp;A::funA</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vftable@B@:</span><br><span class="line">1&gt;| -20</span><br><span class="line">1&gt; 0| &amp;B::funB</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vbtable@B@:</span><br><span class="line">1&gt; 0| -4</span><br><span class="line">1&gt; 1| -12 (Cd(B+4)A)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A      12       4       4 0</span><br><span class="line">1&gt;               B      20       4       8 0</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Dsize(40):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vbptr&#125;</span><br><span class="line">1&gt; 4| d</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt; 8| &#123;vfptr&#125;</span><br><span class="line">1&gt;12| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base B)</span><br><span class="line">1&gt;16| &#123;vfptr&#125;</span><br><span class="line">1&gt;20| &#123;vbptr&#125;</span><br><span class="line">1&gt;24| b</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base C)</span><br><span class="line">1&gt;28| &#123;vfptr&#125;</span><br><span class="line">1&gt;32| &#123;vbptr&#125;</span><br><span class="line">1&gt;36| c</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vbtable@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 8 (Dd(D+0)A)</span><br><span class="line">1&gt; 2| 16 (Dd(D+0)B)</span><br><span class="line">1&gt; 3| 28 (Dd(D+0)C)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vftable@A@:</span><br><span class="line">1&gt;| -8</span><br><span class="line">1&gt; 0| &amp;D::fun</span><br><span class="line">1&gt; 1| &amp;D::funA</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vftable@B@:</span><br><span class="line">1&gt;| -16</span><br><span class="line">1&gt; 0| &amp;D::funB</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vbtable@B@:</span><br><span class="line">1&gt; 0| -4</span><br><span class="line">1&gt; 1| -12 (Dd(B+4)A)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vftable@:</span><br><span class="line">1&gt;| -28</span><br><span class="line">1&gt; 0| &amp;D::funC</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vbtable@C@:</span><br><span class="line">1&gt; 0| -4</span><br><span class="line">1&gt; 1| -24 (Dd(C+4)A)</span><br><span class="line">1&gt; 2| -16 (Dd(C+4)B)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A       8       0       4 0</span><br><span class="line">1&gt;               B      16       0       8 0</span><br><span class="line">1&gt;               C      28       0      12 0</span><br></pre></td></tr></table></figure><h5 id="解释-5"><a href="#解释-5" class="headerlink" title="解释"></a>解释</h5><blockquote><p>A因为没有虚继承，有虚函数，所以拥有一个虚函数表指针以及虚函数表，</p><p>B因为虚继承于A，拥有虚基表以及虚基表、虚函数表指针以及基类成员，因为是虚继承且有新的虚函数，所以拥有一个自己虚函数表以及指针。</p><p>​    其中基类的虚函数表记录从基类继承的虚函数地址，即使以被自己重写。</p><p>​    自己的虚函数表仅记录自己的新增虚函数地址。</p><p>C因为虚继承于B，拥有虚基表以及虚基表、虚函数表指针以及基类成员，因为是虚继承且有新的虚函数，所以拥有一个自己虚函数表以及指针。</p><p>​    因为B也是虚继承于A，所以在派生类C的内存中B的成员信息中拥有对应的虚基表指针。</p><p>​    其中基类的虚函数表记录从基类继承的虚函数地址，即使以被自己重写。</p><p>​    自己的虚函数表仅记录自己的新增虚函数地址。</p></blockquote><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><blockquote><p>D也如此，但是在VS输出的信息中，D却拥有了自己的虚函数表地址，并且有一个虚函数地址是指向基类C的函数funC。。 (上述的  D::\$vftable@:    ， 不应该是  D::\$vftable@c@:么)</p><p>但是通过VS断点去查看局部变量的地址，发现D是没有自己的虚函数地址的，而D中C类成员的虚函数表指针可以看到funC。所以可能是VS抽风了？</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/VS%E6%8A%BD%E9%A3%8E.png" alt=""></p><h5 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h5><blockquote><p>不难看出，虚继承很智能的把虚函数的起源分开了，也就是很智能的将虚函数指针放在第一个提出某个虚函数的基类虚函数表中。</p></blockquote><h4 id="虚基表的作用：菱形继承问题"><a href="#虚基表的作用：菱形继承问题" class="headerlink" title="虚基表的作用：菱形继承问题"></a>虚基表的作用：菱形继承问题</h4><blockquote><p>有下面的代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">class B :  public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">class C :   public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D :public B, public C</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们尝试访问D类的对象中的a成员，会发生什么事情呢。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98.png" alt=""></p><blockquote><p>很显然产生了二义性，因为B和C都继承有A的成员a，我们多继承于BC，那么这两个a，编译器不知道到底选谁。</p><p>让我们看看内存排布：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1&gt;class Asize(4):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Bsize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class A)</span><br><span class="line">1&gt; 0| | a</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt; 4| b</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Csize(8):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class A)</span><br><span class="line">1&gt; 0| | a</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt; 4| c</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Dsize(16):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class B)</span><br><span class="line">1&gt; 0| | +--- (base class A)</span><br><span class="line">1&gt; 0| | | a</span><br><span class="line">1&gt;| | +---</span><br><span class="line">1&gt; 4| | b</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt; 8| +--- (base class C)</span><br><span class="line">1&gt; 8| | +--- (base class A)</span><br><span class="line">1&gt; 8| | | a</span><br><span class="line">1&gt;| | +---</span><br><span class="line">1&gt;12| | c</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt;+---</span><br></pre></td></tr></table></figure><h5 id="解释-6"><a href="#解释-6" class="headerlink" title="解释"></a>解释</h5><blockquote><p>我们可以看到D类的内存分布，出现了两个a成员，分别来源于B-&gt;A和C-&gt;A。</p></blockquote><h5 id="使用虚继承的虚基表解决问题"><a href="#使用虚继承的虚基表解决问题" class="headerlink" title="使用虚继承的虚基表解决问题"></a>使用虚继承的虚基表解决问题</h5><blockquote><p>改成下面的代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">class B : virtual public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">class C : virtual  public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D :public B, public C</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%99%9A%E5%87%BD%E6%95%B0/%E8%99%9A%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.png" alt=""></p><center>不再报错</center><blockquote><p>查看内存分布</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1&gt;class Asize(4):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Bsize(12):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vbptr&#125;</span><br><span class="line">1&gt; 4| b</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt; 8| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;B::$vbtable@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 8 (Bd(B+0)A)</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A       8       0       4 0</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Csize(12):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| &#123;vbptr&#125;</span><br><span class="line">1&gt; 4| c</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt; 8| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;C::$vbtable@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 8 (Cd(C+0)A)</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A       8       0       4 0</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;class Dsize(20):</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt; 0| +--- (base class B)</span><br><span class="line">1&gt; 0| | &#123;vbptr&#125;</span><br><span class="line">1&gt; 4| | b</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt; 8| +--- (base class C)</span><br><span class="line">1&gt; 8| | &#123;vbptr&#125;</span><br><span class="line">1&gt;12| | c</span><br><span class="line">1&gt;| +---</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;+--- (virtual base A)</span><br><span class="line">1&gt;16| a</span><br><span class="line">1&gt;+---</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vbtable@B@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 16 (Dd(B+0)A)</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;D::$vbtable@C@:</span><br><span class="line">1&gt; 0| 0</span><br><span class="line">1&gt; 1| 8 (Dd(C+0)A)</span><br><span class="line">1&gt;vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">1&gt;               A      16       0       4 0</span><br></pre></td></tr></table></figure><h5 id="解释-7"><a href="#解释-7" class="headerlink" title="解释"></a>解释</h5><blockquote><pre><code>1&gt;class D    size(20):1&gt;    +---1&gt; 0    | +--- (base class B)1&gt; 0    | | {vbptr}//起始偏移量地址为01&gt; 4    | | b1&gt;    | +---1&gt; 8    | +--- (base class C)1&gt; 8    | | {vbptr}//起始偏移量为81&gt;12    | | c1&gt;    | +---1&gt;    +---1&gt;    +--- (virtual base A) //这里存储了A类成员信息1&gt;16    | a//我们想要访问的成员 它在内存的偏移量为161&gt;    +---1&gt;1&gt;D::$vbtable@B@://D中的B虚基表，它记录了访问虚继承基类A的成员信息的内存偏移量1&gt; 0    | 01&gt; 1    | 16 (Dd(B+0)A)//偏移161&gt;1&gt;D::$vbtable@C@://D中的C虚基表，它记录了访问虚继承基类A的成员信息的内存偏移量1&gt; 0    | 01&gt; 1    | 8 (Dd(C+0)A)//偏移16</code></pre></blockquote><blockquote><p>我们看到B的虚基表指针的偏移量为0，而它要访问的虚基表显示偏移量为16。0+16=16。</p><p>C的虚基表指针的偏移量为8，而它要访问的虚基表显示偏移量为8。8+8=16。</p><p>显然他们都指向同一个内存偏移量为16的内容，即A类中的a成员。</p></blockquote><h5 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h5><blockquote><p>虚基表保存了虚继承基类成员的内存偏移量，访问的时候通过偏移访问，保证都是访问同一个数据。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>无虚继承<ol><li>存在新的虚函数时，会创建一个虚函数表和虚函数表指针。</li><li>在多重继承中，最后的派生类只有一个虚函数表和指针。</li><li>在多继承中，有多少个虚继承的基类，就有多少个对应的虚函数表和虚函数表指针。自己的新虚函数地址存放在最左边的基类的虚函数表中。</li></ol></li><li>虚继承多<ol><li>重继承中，有多少个虚继承的基类，就有多少个对应的虚函数表和虚函数表指针。同时如果自己拥有新的虚函数，那么将存在一个自己的虚函数表和虚函数指针。</li><li>内存的排版为先子类成员后父类成员，即当前派生类的成员变量最先，然后按照基类的祖父类成员再到基类成员排序。</li></ol></li><li>派生类重写了父类的虚函数时，对应的虚函数表中的虚函数地址以及作用域会被更改为当前派生类。</li><li>在内存排版中的同一个类的作用域中，虚函数表指针vfptr永远在虚基表指针vbptr的前面，虚基表指针永远在其他成员变量前面。</li><li>虚基表保存了虚继承基类成员的内存偏移量，访问的时候通过偏移访问，保证都是访问同一个数据。</li><li>虚函数真乱啊。。。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同步、通信与死锁</title>
      <link href="/2019/MyLearn-OS-3/"/>
      <url>/2019/MyLearn-OS-3/</url>
      
        <content type="html"><![CDATA[<h2 id="进程互斥与同步"><a href="#进程互斥与同步" class="headerlink" title="进程互斥与同步"></a>进程互斥与同步</h2><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><blockquote><p>即进程需要互斥使用共享资源。进程具有独立性和异步性，而计算机中的资源是有限的，如果让多个进程使用同一个资源，很容易发生资源当前状态不确定的情况。</p><p>或者说，如果是多个单进程/线程顺序对资源进行访问，那么这个资源的情况我们是可以确定的，即可复现。</p><p>但是多进程/线程多同个资源进行交叉访问，如果处理不当，我们无法确定资源的情况，即不可复现。</p><p>为了避免这种问题，需要实现进程互斥。</p></blockquote><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><blockquote><p>为了完成共同任务的进程，并发时需安排好先后执行顺序或给予某个条件来协调活动。</p><p>与互斥的区别是，同步是基于互斥的，只不过同步需要规定需要访问资源的进程/线程的访问顺序，而互斥并不关心访问顺序，只关心资源是不是只被一个进程/线程访问。</p><p>所以同步是一种更为复杂的互斥，而互斥是一种特殊的同步。</p></blockquote><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><blockquote><p>一次只能供一个进程访问的资源。</p></blockquote><h3 id="解决进程同步问题"><a href="#解决进程同步问题" class="headerlink" title="解决进程同步问题"></a>解决进程同步问题</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><blockquote><p>用来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p></blockquote><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><blockquote><p>互斥量可以认为是一种标记或者是一把锁，它只有两种状态，可用和不可用(锁住和开锁)。每一个访问这个资源的进程/线程都要对这个资源的互斥量进行判断。</p><p>如果是不可用的，那么我们无法读取资源进行操作。</p><p>如果可用，我们的这个进程/线程将可以获得资源的使用权利，同时将资源锁住，即互斥量变为不可用，将其他想要访问资源的进程/线程隔绝开。当使用完毕时，再将互斥量解锁。</p></blockquote><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote><p>可以理解为复杂的互斥量。</p><p>互斥量可以用0和1代表两种状态，而信号量则是0~n来代表可用和不可用。它更像是一种资源计数器，能允许多个进程/线程对资源进行访问。</p><p>但是在信号量里，很容易产生疑问，信号量允许多个进程/线程访问资源不是违背了进程互斥么？</p><p>在百度了文章后，将原因简单概括一下：</p><p>信号量控制的资源，不一定是要被锁住的资源，而是需要规定流程去使用的资源。</p><p>比如用信号量去控制一个停车场(共享资源)里的多个停车位，每个车子(进程/线程)可以占用一个停车位，如果还有停车位，即信号量大于0，车子可以进去，否则等待。</p><p>车子进去以后停车，占用了一个停车位，所以信号量减1。车子出停车场时，停车位会空掉，所以信号量加1。</p></blockquote><h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><blockquote><p>PV操作就是对信号量(包含互斥量)的操作。</p><p>P即通过的意思，会对信号量进行减操作。</p><p>V即释放的意思，会对信号量进行加操作。</p></blockquote><h2 id="进程通信方式-仅做了解"><a href="#进程通信方式-仅做了解" class="headerlink" title="进程通信方式(仅做了解)"></a>进程通信方式(仅做了解)</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><blockquote><p>管道分为匿名管道和有名管道。</p><p>管道是<strong>半双工的</strong>，数据只能向一个方向流动；<strong>需要双方通信时，需要建立起两个管道</strong>。</p><p>管道是单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></blockquote><h4 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h4><blockquote><p>因为匿名，只有fork出来的子进程才会拥有它的控制权。</p><p>因此匿名管道只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。</p></blockquote><h4 id="有名管道-fifo"><a href="#有名管道-fifo" class="headerlink" title="有名管道(fifo)"></a>有名管道(fifo)</h4><blockquote><p>因为有名(标识)，所有进程可以通过名字(标识)去访问这个管道。</p><p>因此有名管道可用于任意进程之间（非亲缘关系的进程）。</p></blockquote><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote><p>消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。</p><p>一个队列和有名管道一样拥有自己的标识符。</p><p>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</p><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p></blockquote><h3 id="共享内存-信号量"><a href="#共享内存-信号量" class="headerlink" title="共享内存+信号量"></a>共享内存+信号量</h3><blockquote><p>就是上文所述，将资源位于共享的内存片段中成为临界资源，通过信号量的方式实现进程/线程同步，让他们根据临界资源来通信。</p></blockquote><h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号(signal)"></a>信号(signal)</h3><blockquote><p>信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。</p><p>比如在命令行界面，对任意前台进程执行ctrl+c操作，会导致进程终止。</p><p>这个就是利用了信号机制。linux对信号提供了默认操作，我们也可以在代码中通过绑定自己写的方法来替代linux默认的操作。</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>如果一个进程集合中的每一个进程都在等待只能由此集合中的其他进程才能引发的时间，而无限期陷入僵持的局面成为死锁。</p></blockquote><h3 id="产生的必要条件"><a href="#产生的必要条件" class="headerlink" title="产生的必要条件"></a>产生的必要条件</h3><blockquote><ol><li>互斥条件。</li><li>占有和等待条件：当进程请求不到资源时进行等待，但不释放自己以占有的资源。</li><li>不剥夺(抢占)条件：拥有资源的进程只能自愿释放资源而不是被其他进程剥夺。</li><li>循环等待条件：每一个进程都在等待下一个进程持有的资源，而下一个进程也在等待其他进程持有的资源。</li></ol><p>其中，条件4是条件123的产生结果。</p><p>只要破坏掉任意一个条件就可以解决死锁问题。</p></blockquote><h3 id="条件破坏"><a href="#条件破坏" class="headerlink" title="条件破坏"></a>条件破坏</h3><blockquote><p>条件一无法破坏。</p></blockquote><h4 id="条件二"><a href="#条件二" class="headerlink" title="条件二"></a>条件二</h4><blockquote><p>静态分配资源：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。<br>优点：简单易实施且安全。<br>缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。从而使进程经常发生饥饿现象。</p><p>解决方案：进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。</p></blockquote><h4 id="条件三"><a href="#条件三" class="headerlink" title="条件三"></a>条件三</h4><blockquote><p>一旦进程无法获取资源，那么久释放它以获得的资源，以解决其他进程无法获得资源的问题。</p><p>优点：可以让其他进程得以继续。</p><p>缺点：释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。</p></blockquote><h4 id="条件四"><a href="#条件四" class="headerlink" title="条件四"></a>条件四</h4><blockquote><p>采用层次分配策略，让系统把资源分层次，一个进程只可以持有某层次的资源，只可以申请比该层次更高一层的资源。</p><p>这样只有一个方向的流动，不会产生最高层和最底层的互动。(参考链表和循环链表)。</p><p>优点：不会产生循环等待。</p><p>缺点：资源利用率大大降低。</p></blockquote><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><blockquote><p>只介绍银行家算法。</p></blockquote><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><blockquote><p>假设当前系统拥有部分可用资源。</p><p>我们需要提前知道有那些进程需要判断，并且知道进程当前持有的资源以及所需资源。</p><p>然后通过计算安全序列，只要存在任意一种安全序列，就可以认为这些进程不会产生死锁。</p></blockquote><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><blockquote><p>有一下5个进程。系统中有ABC三种资源。</p></blockquote><table><thead><tr><th>进程</th><th>已有资源</th><th>正常工作时所需资源</th></tr></thead><tbody><tr><td></td><td>A-B-C</td><td>A-B-C</td></tr><tr><td>P0</td><td>0-1-0</td><td>7-5-3</td></tr><tr><td>P1</td><td>2-0-0</td><td>3-2-2</td></tr><tr><td>P2</td><td>3-0-2</td><td>9-0-2</td></tr><tr><td>P3</td><td>2-1-1</td><td>2-2-2</td></tr><tr><td>P4</td><td>0-0-2</td><td>4-3-3</td></tr></tbody></table><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>系统可用资源</td><td>3</td><td>3</td><td>2</td></tr></tbody></table><blockquote><p><strong>第一步，我们先遍历所有进程的申请资源</strong></p></blockquote><table><thead><tr><th>进程</th><th>申请资源=正常工作时所需资源-持有资源</th></tr></thead><tbody><tr><td></td><td>A-B-C</td></tr><tr><td>P0</td><td>7-4-2</td></tr><tr><td>P1</td><td>1-2-2</td></tr><tr><td>P2</td><td>6-0-0</td></tr><tr><td>P3</td><td>0-1-1</td></tr><tr><td>P4</td><td>4-3-1</td></tr></tbody></table><blockquote><p>当前系统可用的资源为3-3-2 ，从上表可以得知，满足条件的有P1和P3，假设我们让P1先进行。</p><p>此时P1拿到了资源，它拥有的资源为3-2-2，当前系统还剩资源为2-1-0。</p><p>P1执行完毕，释放资源，此时系统则有5-3-2的资源。</p><p>我们再看上表，满足条件的有P3。我们让P3持有资源，执行完毕在释放。</p><p>释放后系统资源为7-4-3，我们再对照上表进行判断，发现P2、P4都可以运行，我们随意选择一项，假设P4。</p><p>P4释放资源后，系统可用资源为7-4-5。再让P2持资源和释放，系统资源为10-4-7。</p><p>此时只剩下进程P0，发现申请的资源都小于系统可用资源，所以最后一个进程也可以运行。</p><p>得到安全序列1-3-4-2-0</p><p>因为存在安全序列，所以这些进程不会产生死锁。</p></blockquote><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><blockquote><ol><li>解锁所有进程的执行，然后重启操作系统。</li><li>撤销死锁的所有进程。</li><li>逐个撤销死锁的进程，释放资源直到不死锁。</li><li>剥夺死锁中某进程的资源，但是不撤销该进程，直到死锁解除再归还。</li><li>SL大发，死锁发生时让进程回退直保存点。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《图解TCP/IP》之TCP/IP基础知识</title>
      <link href="/2019/MyLearn-ComputerNetwork-2/"/>
      <url>/2019/MyLearn-ComputerNetwork-2/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP基础知识"><a href="#TCP-IP基础知识" class="headerlink" title="TCP/IP基础知识"></a>TCP/IP基础知识</h1><h2 id="TCP-IP的具体含义"><a href="#TCP-IP的具体含义" class="headerlink" title="TCP/IP的具体含义"></a>TCP/IP的具体含义</h2><blockquote><p>根据不同的使用范围，可以分为两种含义。</p><ol><li>仅TCP和IP两种协议。</li><li>利用IP进行通信时所必须用到的协议群的统称。如IP/ICMP、 TCP/UDP、 TELNET/FTP等等。</li></ol></blockquote><h2 id="TCP-IP协议分层模型"><a href="#TCP-IP协议分层模型" class="headerlink" title="TCP/IP协议分层模型"></a>TCP/IP协议分层模型</h2><blockquote><p>书本第一章介绍了OSI参考模型（<a href="http://confusel.tech/2019/MyLearn-ComputerNetwork-1/">博客也记录了</a>），而TCP/IP也有一个对应的参考模型。</p></blockquote><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554144143456&amp;di=e4800c52402be45f2a526ef57971e844&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.net130.com%2FCMS%2FFiles%2FUploadimages%2F111744de017.jpg" alt=""></p><blockquote><p>可以简单的理解为，TCP/IP参考模型将OSI参考模型的顶上三层，即应用层、 表示层、 会话层概括为应用层，其余层不变。也就从原来的7层变为5层模型。</p><p>这里不多介绍数据链路层和物理层了，直接从网络层的协议讲起。</p></blockquote><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><blockquote><p><strong>让主机与主机之间通信。</strong></p></blockquote><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><blockquote><p>IP是跨越网络传输数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到对方，在发送的期间，以IP地址作为主机的标识符。</p><p>IP包含数据链路层的功能，通过IP可以经过任意的底层数据链路去实现通信。</p><p>IP是分组交换的一种协议，但是不具有重发机制，所以是非可靠性传输协议。</p></blockquote><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><blockquote><p>ICMP用于在IP数据包发送异常时，向发送端发送一个err，可以用来诊断网络的健康状况。</p></blockquote><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><blockquote><p>可以从IP地址 解析出MAC地址。</p></blockquote><hr><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><blockquote><p><strong>让应用和应用之间通信。</strong></p></blockquote><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><blockquote><p>面向连接的传输层协议。</p><p>可靠的传输，能保证两个主机之间的通信可达。</p><p>能够正确处理传输过程的丢包、 传输顺序错乱的异常情况。</p><p>可以有效利用带宽，缓解网络拥堵。</p></blockquote><blockquote><p>为了实现可靠性，定义了很多规范，因此在传输上的数据量就不是很大，因此不适合一些数据量大且频繁传输，例如视频通话。</p></blockquote><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><blockquote><p>面向无连接的传输层协议。</p><p>不可靠的传输，它不会关心对方是否能收到数据。</p><p>如果需要检查，只能在应用中实现而不是协议中。</p></blockquote><blockquote><p>性质与TCP大部分相反，因此它适合用于多播、 广播以及视频通信。</p></blockquote><hr><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote><p>如上面所述，TCP/IP将OSI中的表示层、 会话层、 应用层一起概括为应用层，所以在TCP/IP的应用层中，它要实现OSI三层的功能。</p><p>传输层的 UDP 报文和 TCP 报文段的数据部分就是应用层交付的数据。</p><p>网络管理(<a href="https://baike.baidu.com/item/SNMP/133378?fr=aladdin">SNMP</a>)在这里不介绍，因为本人不是很了解。</p></blockquote><h4 id="WWW功能"><a href="#WWW功能" class="headerlink" title="WWW功能"></a>WWW功能</h4><blockquote><p>即万维网，简称web。一般由web客户端(如浏览器)和web服务器组成。而它们之间传输的数据格式主要是<a href="https://baike.baidu.com/item/HTML/97049?fr=aladdin">HTML</a>，即超文本标记语言，通信使用的协议是<a href="https://baike.baidu.com/item/http">HTTP</a>协议，即超文本传输协议。</p><p>注意：HTTP属于OSI应用层协议，HTML属于表示层协议。</p></blockquote><h4 id="电子邮件功能-E-Mail"><a href="#电子邮件功能-E-Mail" class="headerlink" title="电子邮件功能(E-Mail)"></a>电子邮件功能(E-Mail)</h4><blockquote><p>就是发送电子邮件，使用到的协议叫做<a href="https://baike.baidu.com/item/SMTP">STMP</a>，即简单邮件传输协议，在上一篇博客举例中提到过。</p><p>原来只可以发送文本格式的邮件，在<a href="https://baike.baidu.com/item/MIME/2900607?fr=aladdin">MIME</a>协议出现后，允许发送音频、图像等。甚至能对邮件的文字格式进行更改。</p><p>STMP是传输邮件的协议(还有<a href="https://baike.baidu.com/item/POP3">POP3</a>)，而MIME是邮件格式的协议，不用弄混了。</p></blockquote><h4 id="文件传输功能-FTP"><a href="#文件传输功能-FTP" class="headerlink" title="文件传输功能(FTP)"></a>文件传输功能(FTP)</h4><blockquote><p>允许两个计算机之间相互传输文件，可以选择传输过程是二进制还是文本方式。</p><p>在传输过程中，需要创建两个TCP连接，分别是发出传输请求的控制连接，以及实际的数据连接。</p></blockquote><h4 id="远程登录功能-TELNET-SSH"><a href="#远程登录功能-TELNET-SSH" class="headerlink" title="远程登录功能(TELNET|SSH)"></a>远程登录功能(TELNET|SSH)</h4><blockquote><p>远程登录的作用就不多介绍了，其中telnet是明文发送的数据，而ssh支持加密，所以普遍来说ssh更安全。</p></blockquote><h2 id="TCP-IP分层模型与通信示例"><a href="#TCP-IP分层模型与通信示例" class="headerlink" title="TCP/IP分层模型与通信示例"></a>TCP/IP分层模型与通信示例</h2><blockquote><p>跟着书上的内容，在这里介绍应用层到物理媒介的数据处理流程。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85%E9%A6%96%E9%83%A8.png" alt=""></p><blockquote><p>如上图，我们从下往上看，传输层在上层包装好的数据中添加了自己的TCP首部信息，传递给下一层网络层，网络层也添加了自己的IP首部。</p><p>如同在上一篇博客的发邮件例子的过程中，发送方的邮件数据从表示层开始每一层都为数据添加一个首部信息，代表了它们在这一层的操作规定。</p><p>我们在这里依然和书上一样，使用发邮件的例子介绍它们的封装流程。</p></blockquote><h3 id="邮件样例"><a href="#邮件样例" class="headerlink" title="邮件样例"></a>邮件样例</h3><blockquote><p>当发送方输入好内容，点击发送的时候。</p><ol><li>TCP/IP的应用层开始对邮件进行编码处理，将它变成网络的通用码。(这一步在OSI中是表示层的功能)。邮件开始发送的那一刻，开始建立TCP连接，即从应用层将数据发给下一层传输层的TCP中。</li><li>TCP为了实现可靠性传输的功能，在应用层数据的前端加上了一个TCP首部，上面记录了源端口号和目的端口号，以及数据的序列号和校验和，处理好这些，它将数据发到网络层的IP中。</li></ol><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554802825&amp;di=a59b9bf0b19ce7c3bbf57c595728c19c&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F1653926-8d8b9e2591e664e1.png" alt=""></p><p>​    上图的数据即<strong>应用层数据</strong>。</p><ol start="3"><li>网络层接受到了数据，对于网络层，它把接受到的数据当作一个整体处理，它直接在这些数据的头部上加入IP首部，上面注明了源地址和目的地址。</li></ol><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554208303275&amp;di=6b2e1b41a598f4619c8d71267b5812c2&amp;imgtype=0&amp;src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F11%2F24%2F20%2F44911243%2F10.files%2Ffile0001.png" alt="img"></p><p>​    上图的数据部分即(<strong>应用层数据加上TCP头部信息</strong>)的数据。</p><ol start="4"><li>这个时候，开始把数据发送给数据链路层(如路由器)，这时候我们需要知道接受方的MAC地址(如网卡地址)，我们可以通过ARP协议解析出MAC地址。</li></ol></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP%E4%B8%BE%E4%BE%8B.png" alt=""></p><center>书上的图，该图对包首做了简化</center><h3 id="数据包接收处理"><a href="#数据包接收处理" class="headerlink" title="数据包接收处理"></a>数据包接收处理</h3><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt=""></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><blockquote><p>接收到数据之后，数据链路层先查看接收端MAC地址是不是自己，如果不是则丢弃。</p><p>确定是自己的包以后，开始查找以太网包首部的类型域，以确定传过来的数据类型。当前的例子是IP包，所以我们会把数据传输给网络层的IP模块中，如果是ARP则给ARP。</p></blockquote><h4 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h4><blockquote><p>例子中的网络层的IP模块接受到下一层(数据链路层)的数据，首先判断目的ip地址是不是自己，如果不是则丢弃。</p><p>确定是自己的包以后，开始查找IP包首部的协议，如果是TCP则给传输层的TCP模块，如果是UDP则给传输层的UDP模块。</p></blockquote><h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4><blockquote><p>例子中的传输层TCP模块接受到下一层(网络层)的数据，这个时候已经确定信息就是发送给自己了，因此不需要再确认。但是需要检验一下校验和，避免数据错误，之后查看端口号，将数据传给对应端口号的进程。同时发送一个ACK，代表接受到数据。</p><p>如果校验和不对，也会向发送方要求重发一次数据，或者是没有向发送方发送ACK，发送方也会反复发送。</p></blockquote><h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><blockquote><p>我们接受到了传输层的数据，这个时候开始解析(对应OSI的表示层)数据，如果数据正常，并且磁盘有空间能正常保存，那么会发送一个处理正常的信息给发送方。</p><p>否则：</p><ol><li>如果数据实际上并不是指向接受方，比如邮件的收件人地址并不是接受方，那么会发送一个err给发送方。</li><li>如果接收到了，但是无法正常存储，也会发送一个err。</li></ol></blockquote><blockquote><p>最后接受方打开邮件，看到了发送方发来的信息。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>书上第二章主要就是介绍TCP/IP参考模型以及几个层中相对重要的协议，依然通过发送邮件的例子让读者了解在TCP/IP参考模型中的数据传输流程。</p><p>在发送过程中，传输层，网络层，数据链路层都会在应用层的数据包上加上一层对应的首包，分别标记端口、ip地址、mac地址。</p><p>而接收过程，则逆序解析，一一对正，只要不符合就丢弃。</p><p>最后的解析出原本的数据在应用层上被正确的使用，在这个过程中还回确保信息无误，与发送方确认。</p></blockquote><blockquote><p><strong>书上第三章是数据链路层，个人仅去了解，不会专门总结一篇知识，所以下一次会跳到网络层的ip协议。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>处理器调度</title>
      <link href="/2019/MyLearn-OS-2/"/>
      <url>/2019/MyLearn-OS-2/</url>
      
        <content type="html"><![CDATA[<h2 id="处理器调度层次"><a href="#处理器调度层次" class="headerlink" title="处理器调度层次"></a>处理器调度层次</h2><blockquote><p>本篇基于进程和线程，进程和线程的相关知识可以参考另一篇<a href="http://confusel.tech/2019/MyLearn-ProcessAndThreadAndCoroutine/">文章</a>。</p></blockquote><h3 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p>可称为作业调度、长程调度 ，简单来说，就是从后备作业(可以理解为待安排的程序)中按照一定的调度策略选择若干个作业进入内存，开始为他们创建进程和分配资源。</p><p>同时在作业完成时做好善后工作，比如回收资源。</p></blockquote><h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><blockquote><p>当CPU空闲时间超过一定阀值，此时系统便调用高级调度，开始安排新作业。</p></blockquote><h3 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><blockquote><p>可称为平衡调度、中程调度，简单来说会把暂时不能运行的进程挂起，将它占用的资源释放，当资源充足的时候，解除这个进程的挂起状态，为它恢复资源。</p></blockquote><h4 id="调用时机-1"><a href="#调用时机-1" class="headerlink" title="调用时机"></a>调用时机</h4><blockquote><p>当内存吃紧时调用中级调度。</p></blockquote><h3 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><blockquote><p>可称为进程调度、线程调度、短程调度，简单来说，它会根据某种原则决定在内存中所有进程使用cpu的顺序，可以说它是操作系统最核心的调度，几乎每时每刻都在被执行。</p></blockquote><h4 id="调用时机-2"><a href="#调用时机-2" class="headerlink" title="调用时机"></a>调用时机</h4><blockquote><p>当cpu空闲时，说明这个时候cpu还可以被利用。</p><p>如果有某个进程的优先级别比当前使用cpu的进程还高，而且调度算法允许被抢占时，优先的那个进程将会抢占cpu。</p></blockquote><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554036387852&amp;di=fadc94933d3facd8fa64d7d5ebfea650&amp;imgtype=0&amp;src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F8803909-0db744b9da1a2a2a.png" alt=""></p><h2 id="调度性能指标"><a href="#调度性能指标" class="headerlink" title="调度性能指标"></a>调度性能指标</h2><h3 id="资源利用率"><a href="#资源利用率" class="headerlink" title="资源利用率"></a>资源利用率</h3><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>​    CPU利用率=CPU有效工作时间/CPU总的运行时间<br>​    CPU总的运行时间=CPU有效工作时间+CPU空闲等待时间<br>​    即CPU利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</p><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><blockquote><p>单位时间内cpu处理作业的个数。</p><p>如果处理的作业中，长作业比较多，那么相对来说，单位时间内它能处理的作业就很少，因为长作业一直做不完。此时吞吐率低。</p><p>如果处理的作业中，短作业比较多，那么相对来说，单位时间内它能处理的作业就很多，因为短作业很容易做完。此时吞吐率高。</p><p>作业长短指的是执行这个作业的必要时间的长短。</p><p>是批处理系统的重要衡量指标之一。</p></blockquote><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><blockquote><p>确保每个进程都能得到合理的CPU份额和资源份额。否则会产生进程饥饿。</p><p>进程饥饿：某个进程从创建开始到某个时间，就一直没有使用cpu的权限，那么这个进程是没有存在的意义，也就是进程饥饿。</p></blockquote><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><blockquote><p>从交互式进程提交一个请求到获得响应之间的时间间隔。</p><p>是分时、实时系统的重要衡量指标之一。</p></blockquote><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><blockquote><p>从系统提交作业开始到作业完成为止的时间间隔。</p></blockquote><h4 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h4><ol><li>第i个作业的周转时间ti=作业i的完成时刻f-作业的提交时刻s。<ol><li>ti=tf-ts;</li></ol></li><li>平均周转时间T=所有作业的周转时间相加之合/作业个数n。<ol><li>T=($\sum_{i=1}^N$ti)/n</li></ol></li><li>第i个作业的带权周转时间wi=第i个作业的周转时间ti/第i个作业的必要消耗时间tk<ol><li>wi=ti/tk</li></ol></li><li>平均带权周转时间W=所有作业的带权周转时间相加之合/作业个数n。<ol><li>W=($\sum_{i=1}^N$wi)/n</li></ol></li></ol><h2 id="作业调度和低级调度算法"><a href="#作业调度和低级调度算法" class="headerlink" title="作业调度和低级调度算法"></a>作业调度和低级调度算法</h2><h3 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法(FCFS)"></a>先来先服务算法(FCFS)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>字如其名，谁先到谁先服务，也类似数据结构中的队列，不按权值，先进先出。</p><p>非抢占式。</p></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><blockquote><p>如下标，有三个作业按1 2 3的顺序进入后备作业，这个时候因为作业1先来，所以运行它，随后是2和3。</p></blockquote><table><thead><tr><th>作业名</th><th>所需CPU时间/ms</th></tr></thead><tbody><tr><td>作业1</td><td>28</td></tr><tr><td>作业2</td><td>9</td></tr><tr><td>作业3</td><td>3</td></tr></tbody></table><table><thead><tr><th>0-28s</th><th>28-37s</th><th>37-40s</th></tr></thead><tbody><tr><td>作业1</td><td>作业2</td><td>作业3</td></tr></tbody></table><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!***************************************************</span></span><br><span class="line"><span class="comment"> * @file: FCFS.cpp</span></span><br><span class="line"><span class="comment"> * @brief: 博客-操作系统调度算法-先来先服务</span></span><br><span class="line"><span class="comment"> * @author: ConfuseL</span></span><br><span class="line"><span class="comment"> * @date: 3,31,2019</span></span><br><span class="line"><span class="comment"> * @note:</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//所有作业提交到系统的时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> beginTime=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//系统时间</span></span><br><span class="line"><span class="keyword">double</span> systemTime=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//作业号</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//所需CPU的时间</span></span><br><span class="line">        <span class="keyword">double</span> workTime;</span><br><span class="line">    <span class="comment">//获得CPU运作权限的时间</span></span><br><span class="line">        <span class="keyword">double</span> getCount;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">double</span> finishTime;</span><br><span class="line">    <span class="comment">//进入内存的时间</span></span><br><span class="line">        <span class="keyword">double</span> pushTime;</span><br><span class="line">    <span class="comment">//到达系统的时间</span></span><br><span class="line">    <span class="keyword">double</span> arrival;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Job()&#123;&#125;;</span><br><span class="line">        Job(<span class="keyword">int</span> id,<span class="keyword">double</span> wT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">            workTime=wT;</span><br><span class="line">            getCount=<span class="number">0</span>;</span><br><span class="line">            finishTime=<span class="number">0</span>;</span><br><span class="line">            pushTime=<span class="number">0</span>;</span><br><span class="line">            arrival=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Job &amp;j)</span><br><span class="line">    &#123;</span><br><span class="line">            j.setFinishTime(systemTime);</span><br><span class="line">        out&lt;&lt;<span class="string">"作业"</span>&lt;&lt;j.id&lt;&lt;<span class="string">": 所需CPU时间："</span>&lt;&lt;j.workTime&lt;&lt;<span class="string">"ms，进入时间："</span>&lt;&lt;j.pushTime&lt;&lt;<span class="string">"ms，周转时间："</span>&lt;&lt;j.finishTime-j.arrival&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否以完成</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">//当获取CPU运作权限时间大于等于工作所需要的时间，即完成。</span></span><br><span class="line">         <span class="keyword">return</span> getCount&gt;=workTime;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="comment">//设置结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setFinishTime</span><span class="params">(<span class="keyword">double</span> finishTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;finishTime=finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得CPU运作时间，一次1ms</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">getCPUTime</span><span class="params">(<span class="keyword">double</span>&amp; systemTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         getCount+=<span class="number">1.0</span>;</span><br><span class="line">         systemTime+=<span class="number">1.0</span>;</span><br><span class="line">         finishTime+=<span class="number">1.0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置进入内存时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setPushTime</span><span class="params">(<span class="keyword">double</span> pushTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;pushTime=pushTime;</span><br><span class="line">         <span class="comment">//结束时间从进入内存时间开始累加</span></span><br><span class="line">         finishTime=pushTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getFinishTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得工作时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getWorkTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> workTime;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="comment">//获得提交时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getArrivalTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> arrival;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//平均周转和平均带权周转</span></span><br><span class="line">    <span class="keyword">double</span> T=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//后备作业个数个数</span></span><br><span class="line">    <span class="keyword">int</span> jobNum=<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//后备作业队列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Job&gt; JobPool;</span><br><span class="line">    <span class="comment">//当前运行的作业</span></span><br><span class="line">    Job curJob;</span><br><span class="line">    <span class="comment">//测试，后备作业中有以下几个作业</span></span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">1</span>,<span class="number">28</span>)));</span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">2</span>,<span class="number">9</span>)));</span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">3</span>,<span class="number">3</span>)));</span><br><span class="line">    <span class="comment">//开始取作业，按照先进先出(队列特性)</span></span><br><span class="line">    <span class="keyword">while</span>(!JobPool.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        curJob=JobPool.front();</span><br><span class="line">        JobPool.pop();</span><br><span class="line">        curJob.setPushTime(systemTime);</span><br><span class="line">        <span class="comment">//如果作业没有完成</span></span><br><span class="line">        <span class="keyword">while</span>(!curJob.isDone())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//给它一次运行时间(1ms)</span></span><br><span class="line">            curJob.getCPUTime(systemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;curJob;</span><br><span class="line">        T+=(curJob.getFinishTime()-curJob.getArrivalTime())/jobNum;</span><br><span class="line">        W+=((curJob.getFinishTime()-curJob.getArrivalTime())/curJob.getWorkTime())/jobNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"平均周转时间："</span>&lt;&lt;T&lt;&lt;<span class="string">"ms,"</span>&lt;&lt;<span class="string">"平均带权周转时间："</span>&lt;&lt;W&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/OS/FCFS.png" alt=""></p><h3 id="最短作业优先算法"><a href="#最短作业优先算法" class="headerlink" title="最短作业优先算法"></a>最短作业优先算法</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>每次取所需时间最短的作业，当系统彻底空闲的时候取第一个，随后在第一个执行完毕后，检索等待的作业中所需CPU时间最短的作业，然后执行它。</p><p>非抢占式。</p><p>会造成进程饥饿，所需时间越多的就需要等待越久。</p></blockquote><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><blockquote><p>如下标，有四个作业，它们同时进入后备作业，此时由于作业2所需时间最短，所以先运行作业2。</p><p>其次是作业4，1，3。</p></blockquote><table><thead><tr><th>作业名</th><th>所需CPU时间/ms</th></tr></thead><tbody><tr><td>作业1</td><td>9</td></tr><tr><td>作业2</td><td>4</td></tr><tr><td>作业3</td><td>10</td></tr><tr><td>作业4</td><td>8</td></tr></tbody></table><table><thead><tr><th>0-4s</th><th>4-12s</th><th>12-21s</th><th>21-31s</th></tr></thead><tbody><tr><td>作业2</td><td>作业4</td><td>作业1</td><td>作业3</td></tr></tbody></table><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><blockquote><p>直接把上面FCFS的队列改成最小优先队列就好了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!***************************************************</span></span><br><span class="line"><span class="comment"> * @file: SJF.cpp</span></span><br><span class="line"><span class="comment"> * @brief: 博客-操作系统调度算法-最短作业有限</span></span><br><span class="line"><span class="comment"> * @author: ConfuseL</span></span><br><span class="line"><span class="comment"> * @date: 3,31,2019</span></span><br><span class="line"><span class="comment"> * @note:</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//系统时间</span></span><br><span class="line"><span class="keyword">double</span> systemTime=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//作业号</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//所需CPU的时间</span></span><br><span class="line">        <span class="keyword">double</span> workTime;</span><br><span class="line">    <span class="comment">//获得CPU运作权限的时间</span></span><br><span class="line">        <span class="keyword">double</span> getCount;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">double</span> finishTime;</span><br><span class="line">    <span class="comment">//进入内存的时间</span></span><br><span class="line">        <span class="keyword">double</span> pushTime;</span><br><span class="line">    <span class="comment">//到达系统的时间</span></span><br><span class="line">    <span class="keyword">double</span> arrival;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Job()&#123;&#125;;</span><br><span class="line">        Job(<span class="keyword">int</span> id,<span class="keyword">double</span> wT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">            workTime=wT;</span><br><span class="line">            getCount=<span class="number">0</span>;</span><br><span class="line">            finishTime=<span class="number">0</span>;</span><br><span class="line">            pushTime=<span class="number">0</span>;</span><br><span class="line">            arrival=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Job &amp;j)</span><br><span class="line">    &#123;</span><br><span class="line">            j.setFinishTime(systemTime);</span><br><span class="line">        out&lt;&lt;<span class="string">"作业"</span>&lt;&lt;j.id&lt;&lt;<span class="string">": 所需CPU时间："</span>&lt;&lt;j.workTime&lt;&lt;<span class="string">"ms，进入时间："</span>&lt;&lt;j.pushTime&lt;&lt;<span class="string">"ms，周转时间："</span>&lt;&lt;j.finishTime-j.arrival&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重载小于操作符 让时间小的优先</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Job &amp; a,<span class="keyword">const</span> Job &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.workTime&gt;b.workTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否以完成</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">//当获取CPU运作权限时间大于等于工作所需要的时间，即完成。</span></span><br><span class="line">         <span class="keyword">return</span> getCount&gt;=workTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得CPU运作时间，一次1ms</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">getCPUTime</span><span class="params">(<span class="keyword">double</span>&amp; systemTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         getCount+=<span class="number">1.0</span>;</span><br><span class="line">         systemTime+=<span class="number">1.0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置进入内存时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setPushTime</span><span class="params">(<span class="keyword">double</span> pushTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;pushTime=pushTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">setFinishTime</span><span class="params">(<span class="keyword">double</span> finishTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;finishTime=finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getFinishTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得工作时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getWorkTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> workTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得提交时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getArrivalTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> arrival;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//平均周转和平均带权周转</span></span><br><span class="line">    <span class="keyword">double</span> T=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//后备作业个数个数</span></span><br><span class="line">    <span class="keyword">int</span> jobNum=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//后备作业队列</span></span><br><span class="line">    priority_queue&lt;Job&gt; JobPool;</span><br><span class="line">    <span class="comment">//当前运行的作业</span></span><br><span class="line">    Job curJob;</span><br><span class="line">    <span class="comment">//测试，后备作业中有以下几个作业</span></span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">1</span>,<span class="number">9</span>)));</span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">2</span>,<span class="number">4</span>)));</span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">3</span>,<span class="number">10</span>)));</span><br><span class="line">    JobPool.push(*(<span class="keyword">new</span> Job(<span class="number">4</span>,<span class="number">8</span>)));</span><br><span class="line">    <span class="comment">//开始取作业，按照先进先出(队列特性)</span></span><br><span class="line">    <span class="keyword">while</span>(!JobPool.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        curJob=JobPool.top();</span><br><span class="line">        JobPool.pop();</span><br><span class="line">        curJob.setPushTime(systemTime);</span><br><span class="line">        <span class="comment">//如果作业没有完成</span></span><br><span class="line">        <span class="keyword">while</span>(!curJob.isDone())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//给它一次运行时间(1ms)</span></span><br><span class="line">            curJob.getCPUTime(systemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;curJob;</span><br><span class="line">        T+=(curJob.getFinishTime()-curJob.getArrivalTime())/jobNum;</span><br><span class="line">        W+=((curJob.getFinishTime()-curJob.getArrivalTime())/curJob.getWorkTime())/jobNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"平均周转时间："</span>&lt;&lt;T&lt;&lt;<span class="string">"ms,"</span>&lt;&lt;<span class="string">"平均带权周转时间："</span>&lt;&lt;W&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/OS/SJF.png" alt=""></p><h3 id="最短剩余时间优先算法"><a href="#最短剩余时间优先算法" class="headerlink" title="最短剩余时间优先算法"></a>最短剩余时间优先算法</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><blockquote><p>这个算法其实是上面最短作业优先算法的抢占版，最短优先算法规定了每一次执行最短需求的作业，直到它完毕，但是在最短剩余时间优先算法中，每当一个新作业进入到后备内存时，就得比较当前执行的作业和后备作业中谁的需求时间最短了。</p></blockquote><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><blockquote><p>如下表，四个作业分时到达。作业1最先到达，执行了1ms，随后被到来的作业2抢占，因为作业2只需要4ms，而作业1还需要7ms。</p><p>以此类推。</p></blockquote><table><thead><tr><th>作业名</th><th>到达系统时间</th><th>所需CPU时间/ms</th></tr></thead><tbody><tr><td>作业1</td><td>0</td><td>8</td></tr><tr><td>作业2</td><td>1</td><td>4</td></tr><tr><td>作业3</td><td>2</td><td>9</td></tr><tr><td>作业4</td><td>3</td><td>5</td></tr></tbody></table><table><thead><tr><th>0-1MS</th><th>1-5MS</th><th>5-10MS</th><th>10-17MS</th><th>17-26MS</th></tr></thead><tbody><tr><td>作业1</td><td>作业2</td><td>作业4</td><td>作业1</td><td>作业3</td></tr></tbody></table><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!***************************************************</span></span><br><span class="line"><span class="comment"> * @file: SRTF.cpp</span></span><br><span class="line"><span class="comment"> * @brief: 博客-操作系统调度算法-最短剩余时间优先</span></span><br><span class="line"><span class="comment"> * @author: ConfuseL</span></span><br><span class="line"><span class="comment"> * @date: 4,1,2019</span></span><br><span class="line"><span class="comment"> * @note:</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//系统时间</span></span><br><span class="line"><span class="keyword">double</span> systemTime=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//作业号</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//所需CPU的时间</span></span><br><span class="line">        <span class="keyword">double</span> workTime;</span><br><span class="line">    <span class="comment">//获得CPU运作权限的时间</span></span><br><span class="line">        <span class="keyword">double</span> getCount;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">double</span> finishTime;</span><br><span class="line">    <span class="comment">//第一次进入内存的时间</span></span><br><span class="line">        <span class="keyword">double</span> pushTime;</span><br><span class="line">    <span class="comment">//到达系统的时间</span></span><br><span class="line">        <span class="keyword">double</span> arrival;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Job()&#123;&#125;;</span><br><span class="line">        Job(<span class="keyword">int</span> id,<span class="keyword">double</span> ar,<span class="keyword">double</span> wT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">            workTime=wT;</span><br><span class="line">            arrival=ar;</span><br><span class="line">            getCount=<span class="number">0</span>;</span><br><span class="line">            finishTime=<span class="number">0</span>;</span><br><span class="line">            pushTime=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Job &amp;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当它结束的时候输出，这时候设置结束时间。</span></span><br><span class="line">        j.setFinishTime(systemTime);</span><br><span class="line">        out&lt;&lt;<span class="string">"作业"</span>&lt;&lt;j.id&lt;&lt;<span class="string">": 提交时间："</span>&lt;&lt;j.arrival&lt;&lt;<span class="string">"ms, 所需CPU时间："</span>&lt;&lt;j.workTime&lt;&lt;<span class="string">"ms，进入内存时间："</span>&lt;&lt;j.pushTime&lt;&lt;<span class="string">"ms，周转时间："</span>&lt;&lt;systemTime-j.arrival&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重载小于操作符 让剩余时间小的优先</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Job &amp; a,<span class="keyword">const</span> Job &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.getSurplusTime()&gt;b.getSurplusTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否以完成</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">//当获取CPU运作权限时间大于等于工作所需要的时间，即完成。</span></span><br><span class="line">         <span class="keyword">return</span> getCount&gt;=workTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setFinishTime</span><span class="params">(<span class="keyword">double</span> finishTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;finishTime=finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得CPU运作时间，一次1ms</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">getCPUTime</span><span class="params">(<span class="keyword">double</span>&amp; systemTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         getCount+=<span class="number">1.0</span>;</span><br><span class="line">         systemTime+=<span class="number">1.0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置第一次进入内存时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setPushTime</span><span class="params">(<span class="keyword">double</span> pushTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">//如果小于0代表第一次进</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pushTime&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">this</span>-&gt;pushTime=pushTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得进入内存时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getPushTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> pushTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getFinishTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得提交时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getArrivalTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> arrival;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得工作时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getWorkTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> workTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得剩余工作时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span>  <span class="title">getSurplusTime</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> workTime-getCount;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前运行的作业，在这里用静态指针的原因是因为我们需要对每一次进来的作业和当前的作业进行对比甚至替换，如果在传参中声明并不能更改原来的地址，而引用做为传参却无法指向引用(队列top返回的是引用)。</span></span><br><span class="line">Job *curJob=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(priority_queue&lt;Job&gt; &amp;jobPool,Job &amp;newJob)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果为空并且当前没有作业 代表第一个作业 不用推入队列 直接变成当前作业</span></span><br><span class="line">    <span class="keyword">if</span>(jobPool.empty()&amp;&amp;curJob==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curJob=&amp;newJob;</span><br><span class="line">        <span class="keyword">if</span>(curJob-&gt;getPushTime()&lt;<span class="number">1e8</span>)</span><br><span class="line">            curJob-&gt;setPushTime(systemTime);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则推入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    jobPool.push(newJob);</span><br><span class="line">    <span class="comment">//判断当前和队列头部的那个剩余时间最少，然后替换</span></span><br><span class="line">    <span class="keyword">if</span>(jobPool.top().getSurplusTime()&lt;curJob-&gt;getSurplusTime())</span><br><span class="line">    &#123;</span><br><span class="line">        jobPool.push(*curJob);</span><br><span class="line">        *(curJob)=jobPool.top();</span><br><span class="line">        jobPool.pop();</span><br><span class="line">        <span class="keyword">if</span>(curJob-&gt;getPushTime()&lt;<span class="number">1e8</span>)</span><br><span class="line">        curJob-&gt;setPushTime(systemTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//平均周转和平均带权周转</span></span><br><span class="line">    <span class="keyword">double</span> T=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//后备作业个数个数</span></span><br><span class="line">    <span class="keyword">int</span> jobNum=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//后备作业队列</span></span><br><span class="line">    priority_queue&lt;Job&gt; JobPool;</span><br><span class="line">    <span class="comment">//开始取作业，按照先进先出(队列特性)</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为知道是四个作业 所以直接打表了 如果作业很多 就要另写了</span></span><br><span class="line">        <span class="keyword">switch</span>((<span class="keyword">int</span>)systemTime)</span><br><span class="line">        &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                            judge(JobPool,*(<span class="keyword">new</span> Job(<span class="number">1</span>,<span class="number">0</span>,<span class="number">8</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            judge(JobPool,*(<span class="keyword">new</span> Job(<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            judge(JobPool,*(<span class="keyword">new</span> Job(<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                            judge(JobPool,*(<span class="keyword">new</span> Job(<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给它一次运行时间(1ms)</span></span><br><span class="line">        curJob-&gt;getCPUTime(systemTime);</span><br><span class="line">        <span class="comment">//如果作业完成</span></span><br><span class="line">        <span class="keyword">if</span>(curJob-&gt;isDone())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//输出相关信息</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*curJob;</span><br><span class="line">        T+=(curJob-&gt;getFinishTime()-curJob-&gt;getArrivalTime())/jobNum;</span><br><span class="line">        W+=((curJob-&gt;getFinishTime()-curJob-&gt;getArrivalTime())/curJob-&gt;getWorkTime())/jobNum;</span><br><span class="line">        <span class="comment">//读取新作业</span></span><br><span class="line">        <span class="keyword">if</span>(!JobPool.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        *(curJob)=JobPool.top();</span><br><span class="line">        JobPool.pop();</span><br><span class="line">        curJob-&gt;setPushTime(systemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!curJob-&gt;isDone()||!JobPool.empty());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"平均周转时间："</span>&lt;&lt;T&lt;&lt;<span class="string">"ms,"</span>&lt;&lt;<span class="string">"平均带权周转时间："</span>&lt;&lt;W&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/OS/SRTF.png" alt=""></p><h3 id="最高响应比优先算法"><a href="#最高响应比优先算法" class="headerlink" title="最高响应比优先算法"></a>最高响应比优先算法</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><blockquote><p>一种即考虑作业等待时间，又考虑作业处理时间的非抢占式调度算法。</p><p>以响应比为因素，决定作业的优先情况。</p><p>响应比=作业周转时间/作业处理时间</p><p>​        =(作业等待时间+作业处理时间)/作业处理时间</p><p>​        =1+作业等待时间/作业处理时间</p><p>在代码中，这个1往往可以忽略掉。</p></blockquote><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><blockquote><p>如下表，四个作业分时到达。作业1最先到达，执行了20ms。</p><p>在这个期间，作业234全部到达系统，位于后备作业中。</p><p>当1结束，作业2的等待时间为15ms，作业3的等待时间为10ms，作业4为5ms。</p><p>各自除以各自的所需时间，得响应比为：作业2：1，作业3：2，作业4：0.5。</p><p>因此选中作业3直到执行完毕。</p><p>以此类推。</p></blockquote><table><thead><tr><th>作业名</th><th>到达系统时间</th><th>所需CPU时间/ms</th></tr></thead><tbody><tr><td>作业1</td><td>0</td><td>20</td></tr><tr><td>作业2</td><td>5</td><td>15</td></tr><tr><td>作业3</td><td>10</td><td>5</td></tr><tr><td>作业4</td><td>15</td><td>10</td></tr></tbody></table><table><thead><tr><th>0-20MS</th><th>20-25MS</th><th>25-40MS</th><th>40-50MS</th></tr></thead><tbody><tr><td>作业1</td><td>作业3</td><td>作业2</td><td>作业4</td></tr></tbody></table><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!***************************************************</span></span><br><span class="line"><span class="comment"> * @file: HRRF.cpp</span></span><br><span class="line"><span class="comment"> * @brief: 博客-操作系统调度算法-最高响应比优先</span></span><br><span class="line"><span class="comment"> * @author: ConfuseL</span></span><br><span class="line"><span class="comment"> * @date: 4,3,2019</span></span><br><span class="line"><span class="comment"> * @note:</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//系统时间</span></span><br><span class="line"><span class="keyword">double</span> systemTime=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> dbMin=<span class="number">0.0000001</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//作业号</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//以获得的工作时间</span></span><br><span class="line">        <span class="keyword">double</span> workTime;</span><br><span class="line">    <span class="comment">//获得CPU运作权限的时间</span></span><br><span class="line">        <span class="keyword">double</span> getCount;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">double</span> finishTime;</span><br><span class="line">    <span class="comment">//进入内存的时间</span></span><br><span class="line">        <span class="keyword">double</span> pushTime;</span><br><span class="line">    <span class="comment">//到达系统的时间</span></span><br><span class="line">        <span class="keyword">double</span> arrival;</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        <span class="keyword">double</span> await;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Job()&#123;&#125;;</span><br><span class="line">        Job(<span class="keyword">int</span> id,<span class="keyword">double</span> ar,<span class="keyword">double</span> wT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">            workTime=wT;</span><br><span class="line">            arrival=ar;</span><br><span class="line">            getCount=<span class="number">0</span>;</span><br><span class="line">            finishTime=<span class="number">0</span>;</span><br><span class="line">            pushTime=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Job &amp;j)</span><br><span class="line">    &#123;</span><br><span class="line">            j.setFinishTime(systemTime);</span><br><span class="line">        out&lt;&lt;<span class="string">"作业"</span>&lt;&lt;j.id&lt;&lt;<span class="string">": 所需CPU时间："</span>&lt;&lt;j.workTime&lt;&lt;<span class="string">"ms，进入时间："</span>&lt;&lt;j.pushTime&lt;&lt;<span class="string">"ms，周转时间："</span>&lt;&lt;j.finishTime-j.arrival&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重载小于操作符 让响应比大的优先</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Job &amp; a,<span class="keyword">const</span> Job &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.getAwait()/a.getWorkTime()-b.getAwait()/b.getWorkTime()&gt;dbMin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否以完成</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">//当获取CPU运作权限时间大于等于工作所需要的时间，即完成。</span></span><br><span class="line">         <span class="keyword">return</span> getCount&gt;=workTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得CPU运作时间，一次1ms</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">getCPUTime</span><span class="params">(<span class="keyword">double</span>&amp; systemTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         getCount+=<span class="number">1.0</span>;</span><br><span class="line">         systemTime+=<span class="number">1.0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置进入内存时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setPushTime</span><span class="params">(<span class="keyword">double</span> pushTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;pushTime=pushTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置等待时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setAwaitTime</span><span class="params">(<span class="keyword">double</span> awaitTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;await=awaitTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//设置结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setFinishTime</span><span class="params">(<span class="keyword">double</span> finishTime)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;finishTime=finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得结束时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getFinishTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> finishTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得工作时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getWorkTime</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> workTime;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//获得提交时间</span></span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getArrivalTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> arrival;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">double</span> <span class="title">getAwait</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> await;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//平均周转和平均带权周转</span></span><br><span class="line">    <span class="keyword">double</span> T=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//后备作业个数个数</span></span><br><span class="line">    <span class="keyword">int</span> jobNum=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//后备作业向量 这里不用队列的原因是为了方便每一次的响应比计算</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Job&gt; JobPool;</span><br><span class="line">    <span class="comment">//当前运行的作业</span></span><br><span class="line">    Job curJob=*(<span class="keyword">new</span> Job(<span class="number">1</span>,<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">    curJob.setPushTime(systemTime);</span><br><span class="line">    <span class="comment">//开始取作业，按照先进先出(队列特性)</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为知道是四个作业 所以直接打表了 如果作业很多 就要另写了</span></span><br><span class="line">        <span class="keyword">switch</span>((<span class="keyword">int</span>)systemTime)</span><br><span class="line">        &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                        JobPool.push_back(*(<span class="keyword">new</span> Job(<span class="number">2</span>,<span class="number">5</span>,<span class="number">15</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                        JobPool.push_back(*(<span class="keyword">new</span> Job(<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">                        JobPool.push_back(*(<span class="keyword">new</span> Job(<span class="number">4</span>,<span class="number">15</span>,<span class="number">10</span>)));</span><br><span class="line">            <span class="keyword">break</span>;;</span><br><span class="line">        &#125;</span><br><span class="line">        curJob.getCPUTime(systemTime);</span><br><span class="line">        <span class="keyword">if</span>(curJob.isDone())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;curJob;</span><br><span class="line">            T+=(curJob.getFinishTime()-curJob.getArrivalTime())/jobNum;</span><br><span class="line">            W+=((curJob.getFinishTime()-curJob.getArrivalTime())/curJob.getWorkTime())/jobNum;</span><br><span class="line">            <span class="comment">//为每一个作业刷新等待时间</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;JobPool.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                JobPool[i].setAwaitTime(curJob.getFinishTime()-JobPool[i].getArrivalTime());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排序 取首个 也就是响应比最大的那个</span></span><br><span class="line">            <span class="keyword">if</span>(!JobPool.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                sort(JobPool.begin(),JobPool.end());</span><br><span class="line">                curJob=JobPool[<span class="number">0</span>];</span><br><span class="line">                curJob.setPushTime(systemTime);</span><br><span class="line">                JobPool.erase(JobPool.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">while</span>(!curJob.isDone()||!JobPool.empty());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"平均周转时间："</span>&lt;&lt;T&lt;&lt;<span class="string">"ms,"</span>&lt;&lt;<span class="string">"平均带权周转时间："</span>&lt;&lt;W&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/OS/HRRF.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《图解TCP/IP》之网络基础知识</title>
      <link href="/2019/MyLearn-ComputerNetwork-1/"/>
      <url>/2019/MyLearn-ComputerNetwork-1/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机中的协议"><a href="#计算机中的协议" class="headerlink" title="计算机中的协议"></a>计算机中的协议</h2><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><blockquote><p>简单来说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种约定。</p><p>书中有一段例子，即：</p><ul><li>人们沟通用的语言当作“协议”</li><li>聊天当作“通信”</li><li>说话的内容当作“数据”</li></ul><p>但是计算机并没有人类那么智能  ，人类在聊天(通信)时不需要特别注意就能自然的吐字、发音(写数据)和听懂对方的语言(数据解析)。但是计算机不会，因此需要我们提前指定好这个协议。让计算机根据这个协议，去正确的读取和发送数据。</p></blockquote><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E4%B8%BE%E4%BE%8B.png" alt=""></p><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><blockquote><p>让不同的设备、CPU以及不同的操作系统组成的计算机之间遵循相同的协议以能够实现通信。可以理解为通信时，两个计算机的语言，只有语言相同，两个计算机太能听懂(此语言只是举例，不指编程语言)。</p></blockquote><h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h3><blockquote><p>分组交换是指把大数据分割成多个小的包裹(packet)，随后再进行传输。</p><p>就类似于邮局发货，对于每一个包，都需要标识好发送人的信息和接受人的信息（源地址和目的地址），这样才能保证货物能够在正确的路线上传递。</p><p>原文中翻译为分组交换协议，感觉称为技术更合适，因为觉得这个 协议 两字有一点容易让人把后面学习的TCP/IP协议的 协议 混淆，因为TCP/IP使用的正是分组交换技术，所以在这里改为技术。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.png" alt=""></p><h2 id="协议分层与OSI参考模型"><a href="#协议分层与OSI参考模型" class="headerlink" title="协议分层与OSI参考模型"></a>协议分层与OSI参考模型</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><blockquote><p>国际标准化组织，根据通信协议中必要的功能分层了7个层次，而这个7个层次组成了一个模型。即OSI模型。</p><p>在这个模型中，每一层次都要接受它下一层提供的服务，同时为自己上一层提供服务。</p><p>不同层次交互时遵行的约定叫做“接口”，相同层次交互式的约定叫做“协议”。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE.png" alt=""></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><blockquote><p>如上所述，国际标准化组织将协议分为了7个层次，从底层到上层，为别是：</p><p>物理层-&gt;数据链路层-&gt;网络层层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层。</p><p>其中七层的作用如下图。</p></blockquote><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E4%B8%83%E5%B1%82%E4%BD%9C%E7%94%A8.png" alt=""></p><blockquote><p>发送方调用的顺序是从上到下，接受方则相反，从下到上。</p><p>以发送邮件简单举例，发送方A想对接受方B发送一封信，那么发送方在写完信，在邮箱网页上点击了发送按钮的那一刻，我们的信件便进入了应用层。</p><ol><li>应用层：我们的应用层知道这是一封电子邮件，选择一个适合的应用层协议:SMTP协议(先不用管它，知道它是一个发送邮件的协议就好了)，然后把这封电子邮件变成一个包裹，包的首部写了邮件的信息以及收件人。随后开始调用下一层的接口。</li><li>表示层：接受到应用层的调用，表示层先将包裹分析一边，为了保证数据格式一致性，把邮件中的信息转换为网络通用的标准数据格式，同时加上一段首部信息，标识这个数据原来的格式。转换好之后，调用下一层的接口。</li><li>会话层：会话层拿到包裹后，开始决定采用哪一种链接方式，对多个邮件是连续发呢还是一次性发完呢。在首部也添加了该层的信息：数据传输的顺序。随后调用下一层的接口。</li><li>传输层：这应该就是这本书的重点啦，这一层有TCP和UDP协议，如果选择了TCP协议，我们将建立起双方的可靠链接，反之UDP将不面向连接。此外还要进行传输前的错误检测和流控。随后数据开始经过网络层。</li><li>网络层：网络层的主要功能即是提供路由，即选择到达目标主机的最佳路径，并沿该路径传送数据包。除此之外，网络层还要能够消除网络拥挤，具有流量控制和拥挤控制的能力。选择了最佳的线路之后，开始进入数据链路层。</li><li>数据链路层：该层的数据传输单位是帧，将经过上面五层操作后的邮件的数据组合成一帧一帧的数据，开始传递给物理层。</li><li>物理层：这是最低的一层了，在这里我们把帧数据编程0101的比特，然后经过光纤啊、电缆啊、wifi啊等物理设施传输到对方对应的物理设施中。</li></ol><p>在发送方A点击发送后的几秒内，以上操作很可能已经完成了，而接受方B的物理层也开始接受到0101的比特数据，然后从下层到上层逐个分析，在传输层使用了对应的TCP/UDP接受数据，在会话层按顺序排序数据，在表示层解码数据，在应用层把邮件放到接受方B的邮箱中，如果邮箱满了，这时候我们又会发送一条错误给发送方A，这个时候又类似发送了一封邮件，只不过发送者不再是A而是B了。</p></blockquote><h2 id="传输方式的种类"><a href="#传输方式的种类" class="headerlink" title="传输方式的种类"></a>传输方式的种类</h2><h3 id="面向连接与面向无连接"><a href="#面向连接与面向无连接" class="headerlink" title="面向连接与面向无连接"></a>面向连接与面向无连接</h3><h4 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h4><blockquote><p>即双方的通信要建立在连接上。比如打电话，需要向对方拨号，而对方也必须在接通之后，两个人才能通话，这个过程就是建立连接。如果两个人其中一个人挂了电话，那么就无法在通讯，也就是连接被切断了。</p><p>TCP协议就是面向链接。</p></blockquote><h4 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h4><blockquote><p>双方的通信不需要连接。比如寄快递，我只需要将货物给邮寄公司，填写好对方信息就好了，当包裹到对方地址的时候，对方去查收就好。</p><p>UDP协议就是面向无连接。</p></blockquote><h3 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><blockquote><p>从名字上很容易理解，也就是发送方和接受方通过一条电路传递数据，如果停止传递，那么电路断开（不要和上面的面向连接搞混了，这里的电路是单独的物理通路)。</p><p>及时通信电路空闲，其他用户无法使用。</p><p>举个例子，看过一些记录背景为上时代的电影，会有过打电话的不少镜头，主角打电话给某人，然后某中继接通了电话，主角说，帮我接通B，然后中继将线路搭给了B，这时候两个人才能通话。</p></blockquote><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><blockquote><p>上面介绍过分组交换，这里不再介绍，在此说一下它的好处。</p><p>电路交换缺点很明显，两个人只要通信就占用一条物理道路，多不方便啊。但是分组交换的话，让每个人的通信数据变成一段一段的，大家一起使用一条或者多条物理道路(分组流水线)，这样道路的利用率就大大提高了。</p></blockquote><h3 id="单播，广播，多播，任播"><a href="#单播，广播，多播，任播" class="headerlink" title="单播，广播，多播，任播"></a>单播，广播，多播，任播</h3><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><blockquote><p>一对一的通信，就如上面的固定电话。</p></blockquote><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><blockquote><p>一对多的通信，比如电视观看节目，信号源向各家各户发送。</p></blockquote><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><blockquote><p>和广播类似，但是接受方是指定的，不是广播距离的看电视一样，想看就能看，在多播中，是被规定好接受方的。比如群内视频，是由群里的成员可以加入。</p></blockquote><h4 id="任播"><a href="#任播" class="headerlink" title="任播"></a>任播</h4><blockquote><p>一台发送方主机从台接受方主机中选择接送方。与多播不同的是，它只能选择一个而不是多个。</p><p>看似一对多，其实还是一对一，只不过拥有了选择的对象。</p><p>就像老师(发送方)叫同学们(多个主机)回答问题，一般选择睡觉(指定的接受方)的那个。。。</p><p>域名解析就是任播，我们解析域名，从ip表中找到它真正对应的ip地址。</p></blockquote><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="什么是地址"><a href="#什么是地址" class="headerlink" title="什么是地址"></a>什么是地址</h3><blockquote><p>地址当然是记录某个事物当前处于的位置啦，在通信传输中，地址是具有唯一性的，一个地址只能指明一个事物，这其实和变成里的指针一个性质。</p><p>但是指名的事物并不代表只是一个个体，也有可能是一个团体，就像C++中某个指针指向了一个类的对象，而这个对象中又有各个成员变量。这个指针指向了一个对象，尽管这个对象中有多个成员，但这个对象依然是唯一的。</p><p>如下图，书上举了一个老师点名的例子。虽然地址指向的都可能是个群体，但是这些群体依然是唯一的。</p></blockquote><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%B0%E5%9D%80%E5%94%AF%E4%B8%80%E6%80%A7.png" alt=""></p><h3 id="地址的分类"><a href="#地址的分类" class="headerlink" title="地址的分类"></a>地址的分类</h3><blockquote><p>这里的分类不是编程中的int指针、char指针，而是不同协议的使用的地址。</p></blockquote><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><blockquote><p>简单理解为电脑里网卡的唯一标识符。</p></blockquote><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><blockquote><p>一个网络对应一台主机的地址，一个ip对应一个主机。各运营商有各自的ip范围。</p></blockquote><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><blockquote><p>你的电脑分配给某个进程的通信号，其他电脑可以通过端口号，与你电脑中对应的进程进行通信。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>第一章主要是介绍了通信的协议、还有数据传输的几种类型以及地址。</p><p>其实还有网关和中继器、交换机等一些偏物理的知识，只不过我就不总结了，因为做软件比较偏向传输层以上，这里仅仅看过当作了解。</p><p>这一章只是进入计网世界的预热。下一章的内容是TCP/IP的基础知识，即将进入这本书的正题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程、 协程、 进程的简单理解</title>
      <link href="/2019/MyLearn-ProcessAndThreadAndCoroutine/"/>
      <url>/2019/MyLearn-ProcessAndThreadAndCoroutine/</url>
      
        <content type="html"><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><blockquote><p>​    在了解协程之前，我们先了解一下操作系统中的堆、 栈。</p><p>​    再谈谈进程和线程。其中暂不介绍上下文。</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>​    在数据结构中，栈具有先进后出的特性，也就是说，将1,2,3按顺序添加到栈结构中，再依次取出数据时，数据顺序是这样的：3,2,1。</p><p>​    而在操作系统中，它是内存分配的一种方式，即动态分配内存。它由编译器自动分配和释放，主要用于存放函数的参数值，局部变量等等，而它的性质也遵循先进后出。</p><p>​    栈存放在一级缓存中，在被调用结束后会被立即释放。</p></blockquote><hr><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>​    在数据结构中，是一种树形结构，即完全二叉树，它的特性是某节点的值都不会比父节点的值大或者小，所以常常用来实现优先队列。</p><p>​    而在操作系统中，它和栈一样是动态分配内存，不同的是，它由我们分配和释放，如果我们没有主动释放，会在程序结束时被回收。</p><p>​    <strong>重点来了，它与数据结构的堆并不具有同种特性，它的性质更接近于链表。</strong></p><p>​    堆存放在二级缓存中，调用完毕并不会被系统直接回收。</p></blockquote><hr><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>​    进程即可并发执行的程序在某个数据集合上的一切计算活动。</p><p>​    可以简单的认为，在电脑上打开了一个软件，运行了一款游戏，就是开启了一个进程。</p></blockquote><h4 id="进程性质"><a href="#进程性质" class="headerlink" title="进程性质"></a>进程性质</h4><blockquote><ol><li>有生命周期</li><li><strong>拥有系统资源的基本单位</strong></li><li>进程之间可以对等的，也可以是父子结构。</li></ol></blockquote><h4 id="进程属性"><a href="#进程属性" class="headerlink" title="进程属性"></a>进程属性</h4><blockquote><ol><li>动态性：拥有生命周期</li><li>共享性：多个进程可以执行同个程序</li><li>独立性：每个进程都是OS中的一个操作实体，拥有自己的独立栈、 堆</li><li>制约性：共享资源的制约关系</li><li>并发性：单处理器可并发执行，多处理器可并行执行</li></ol></blockquote><h4 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h4><blockquote><ol><li>控制块：英文缩写PCB，每一个进程捆绑一个，用来存储进程的标识、 现场、 控制信息 ，同进程创建、 回收。</li><li>程序块：即进程执行的程序</li><li>核心栈： 进程在内核模式下运行时使用的堆栈， 中断或系统过程使用；</li><li>数据块：进程处理的数据空间， 包括数据、 处理函数的用户栈（用户态）和可修改的程序；</li></ol></blockquote><h4 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h4><blockquote><p>​    在进程列表中增加一项，然后从PCB池里申请一个空闲的PCB然后为新进程分配唯一的标识符，同时分配地址空间等等各种资源。随后初始化PCB，如标识符、 进程优先级等，然后设置就绪态，加入就绪队列。</p></blockquote><h4 id="进程的撤销过程"><a href="#进程的撤销过程" class="headerlink" title="进程的撤销过程"></a>进程的撤销过程</h4><blockquote><p>​    可分为正常和非正常撤销，也就是类似进程运行结束、 执行非法命令、 被中断等</p><p>​    根据被撤销进程的标识符从相应的队列中查找并移除，并把资源归还给上一级（父进程或者是OS），如果这个进程拥有子进程，那么先对子进程同样的操作，最后将PCB回收。</p></blockquote><h4 id="进程拥有的进程状态"><a href="#进程拥有的进程状态" class="headerlink" title="进程拥有的进程状态"></a>进程拥有的进程状态</h4><h5 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h5><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554482916&amp;di=e7971789a22228da570fc73db668aee5&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F14257988-35ecc363f4919af0.png" alt=""></p><h5 id="七态"><a href="#七态" class="headerlink" title="七态"></a>七态</h5><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=839532373,3126445145&amp;fm=26&amp;gp=0.jpg" alt=""></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>​    上面介绍了进程，可以看出进程的功能十分强大，那么为什么还需要线程呢？</p><p>​    首先需要明确一个概念，Linux系统中甚至没有真正的线程。不过，可以认为Linux是系统的线程是内核线程，所以调度是基于线程的。</p></blockquote><h4 id="引入线程的原因"><a href="#引入线程的原因" class="headerlink" title="引入线程的原因"></a>引入线程的原因</h4><blockquote><ol><li>进程切换开销大</li><li>进程通信代价大</li><li>进程间的并发性力度较粗，并发度不高，并发的本质是在时间上重叠的多个逻辑流，也就是说同时运行的多个逻辑流。并发编程要解决的一个很重要的问题就是对资源的并发访问的问题，也就是共享资源的问题。而两个进程恰恰很难在逻辑上表示共享资源。</li><li>不适应并行计算和分部并行的计算需求</li><li>不适合C/S计算的要求</li></ol></blockquote><h4 id="线程性质"><a href="#线程性质" class="headerlink" title="线程性质"></a>线程性质</h4><blockquote><ol><li>在引入线程这个概念之后，线程成为了CPU<strong>调度和分配的最小单位</strong>。</li><li>线程是进程的组成部分，是能够并发的实体。</li><li>线程<strong>不是拥有资源</strong>的单位，所以挂起状态对于线程没有任何意义。因此挂起操作不是线程级而是进程级状态。</li><li>线程可以创建另一个线程。但都是对等结构不是父子结构。</li></ol></blockquote><h4 id="线程结构"><a href="#线程结构" class="headerlink" title="线程结构"></a>线程结构</h4><blockquote><ol><li>线程控制块：英文缩写TCB，与进程的控制块相似，但是由进程操控。</li><li>线程用户栈</li><li>线程核心栈</li></ol></blockquote><hr><h4 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9832170bbc315c60579863bdecd8a076/b8014a90f603738dd1bbb73cb31bb051f819ec3f.jpg" alt="img"></h4><blockquote><p>​    可以理解为线程是进程的一部分。一个线程只能属于一个进程，而一个进程可以有多个线程。线程是进程的一部分，所以线程有的时候被称为是轻权进程或者<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B">轻量级进程</a>。</p><p>​    线程可以分为两部分：<strong>资源集合</strong>和<strong>线程集合</strong>。进程要支持线程的运行，并为线程提供虚拟地址空间和各种资源。</p></blockquote><h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><blockquote><ol><li>进程之间的通信，只能通过管道、 信号的方式通信。而线程使用的资源来源于进程的共享，通信起来并没有进程这么麻烦。</li><li>一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。</li><li>进程有自己的不共享堆，不共享栈，线程有自己的不共享栈和共享堆。</li><li>进程是拥有资源的单位，线程是调度和分配的最小单位。</li></ol></blockquote><h4 id="多线程容易引发的问题"><a href="#多线程容易引发的问题" class="headerlink" title="多线程容易引发的问题"></a>多线程容易引发的问题</h4><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><blockquote><p>​    我们都知道线程共享使用的是来自进程的资源，那么在多个线程同时访问资源时，同时对某个资源进行操作，就会发生一些错误。</p><p>​    比如买票，就剩最后一张票了，两个线程同时买票，都发现了最后一张，都买掉了它，那么这个时候，系统还剩-1张票。</p><p>​    显然这不是我们想看到的情况。</p><p>​    为了解决这种问题，出现了互斥锁、信号量的等等解决方案。因为介绍这些内容篇幅过长可以自行百度。</p></blockquote><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><blockquote><p>​    死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），经典的问题如<a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin">哲学家就餐问题</a>,因为死锁问题可以另开篇幅，在这里同样不再描述。</p></blockquote><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><h4 id="引入协程的原因"><a href="#引入协程的原因" class="headerlink" title="引入协程的原因"></a>引入协程的原因</h4><blockquote><p>​    线程其实并没有提高CPU的运行速率，而只是提高了运行效率，同时会很吃CPU的性能。</p><ol><li><p>涉及到同步、异步、互斥锁。</p></li><li><p>涉及到线程阻塞状态和可运行状态之间的切换。</p></li><li><p>涉及到线程上下文的切换。</p><p>可见一个进程内多个线程运作的时候进行以上操作会非常消耗性能。</p></li></ol></blockquote><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg" alt=""></p><h4 id="协程性质"><a href="#协程性质" class="headerlink" title="协程性质"></a>协程性质</h4><blockquote><ol><li>如同操作系统拥有多个进程，进程拥有多个线程一样，线程拥有多个协程。</li><li>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</li><li>协程是在一个线程中，每个协程对CPU进行分时处理。</li><li>协程即与多线程情况下的线程比较类似：有自己的堆栈，自己的局部变量，有自己的指令指针，但与其它协同程序共享全局变量等很多信息。</li><li>协程造成阻塞是，会影响整个线程。</li></ol></blockquote><h4 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h4><blockquote><ol><li>协程 :同一时间只能执行某个协程。开辟多个协程开销不大。协程适合对某任务进行分时处理。</li><li>线程: 同一时间可以同时执行多个线程。开辟多条线程开销很大。线程适合多任务同时处理。</li><li>线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。</li><li>协程需要保证是非堵塞的且没有相互依赖，协程基本上不能同步通讯，多采用一步的消息通讯，效率比较高。</li></ol></blockquote><h3 id="Unity3D中的线程、协程"><a href="#Unity3D中的线程、协程" class="headerlink" title="Unity3D中的线程、协程"></a>Unity3D中的线程、协程</h3><h4 id="创建的线程无法调用UnityAPI"><a href="#创建的线程无法调用UnityAPI" class="headerlink" title="创建的线程无法调用UnityAPI"></a>创建的线程无法调用UnityAPI</h4><blockquote><p>​    Unity是单线程设计的游戏引擎(很多都是，因为游戏大部分都是主循环结构)，它有一个负责主循环的主线程。基于MonoBehavior，因此游戏脚本拥有严格的生命周期。</p><p>​    尝试在Unity中创建线程后，很容易发现，在我们创建的线程运行函数中，无法调用Unity引擎提供的各种API，以及它提供的特殊对象。例如组件，但是常用的如int、struct类型是允许使用的。</p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><blockquote><p>​    为了保证逻辑和画面按照严格的顺序更新。</p></blockquote><h4 id="无法使用UnityAPI，那么创建线程还有什么用"><a href="#无法使用UnityAPI，那么创建线程还有什么用" class="headerlink" title="无法使用UnityAPI，那么创建线程还有什么用"></a>无法使用UnityAPI，那么创建线程还有什么用</h4><blockquote><p>​    如果不是画面更新，也不是常规的逻辑更新（指包括AI、物理碰撞、角色控制这些），而是一些其他后台任务，比如网络传输：</p><p>​    正如TCP或者UDP协议的传输，在TCP中，我们需要确保长链接，需要一直接受发送端发送过来的数据，如果我们把它写在主线程下，会发生什么。我们在游戏拥有聊天服务这个功能，假设使用阻塞式TCP协议，那么我们打开与某玩家的聊天窗口，向其发送数据，然后就没有然后了，因为我们必须等待对方的回复。</p><p>​    而我们使用多线程就可以解决了。新增线程专门用于网络通讯，而主线程根据接受到的信息负责更新逻辑以及画面。</p></blockquote><h4 id="可我想对我的游戏进行调用UnityAPI的并发或者异步操作，怎么办——使用协程"><a href="#可我想对我的游戏进行调用UnityAPI的并发或者异步操作，怎么办——使用协程" class="headerlink" title="可我想对我的游戏进行调用UnityAPI的并发或者异步操作，怎么办——使用协程"></a>可我想对我的游戏进行调用UnityAPI的并发或者异步操作，怎么办——使用协程</h4><blockquote><p>​    协程，即协作式程序，其思想是一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CUP进行分时，协程可以访问和使用unity的所有方法和component.</p><p>​    协程一般都是在一次Update之后被使用，协程在每次使用后会被挂起，等待下一次的使用。那么它的作用是什么呢。</p><p>​    比如，我们需要异步加载场景上的所有预置体，比如制作了一款关卡场景中物体比较多的游戏，我们需要在关卡开始前加载所有预置体(为了更能提现协程的作用，在这里先不考虑缓存池优化)，假设预置体真的很多，把加载都放在Start中执行，那么玩家可能会卡顿一段时间才能进入到游戏循环中，而我们使用协程，协程每次加载部分预置体，在Start中开启协程，那么协程会被执行一次，这个时候加载了部分预置体，再进行一次Update循环后，协程又一次被调用，又加载了部分预置体，而一秒中调用的Update次数足够多，所以并不会产生卡顿的感觉。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>进程是操作系统拥有资源的单位，一个操作系统可拥有多个进程，拥有独立的栈和堆。通常对应一个运行的程序。</p><p>线程是CPU调度和分配的最小单位，一个进程可以拥有多个线程。拥有独立的栈和共享的堆(来自进程)。通常对应一个程序中的主要功能和并发功能。</p><p>协程可以说是用户态的轻量级线程，一个线程可以拥有多个协程。拥有用户栈和共享的堆(来自线程)。通常应用于异步中。</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;常用算法的C++实现&gt;图论</title>
      <link href="/2019/MyAlgorithm-edge/"/>
      <url>/2019/MyAlgorithm-edge/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><blockquote><p>从文字上理解，就是求哪到哪儿的路径最短，题目会给多个点，点与点之间是否相连，权值是多少。一般来说需要我们计算一个节点到其他所有节点的最短路径。然后输出源点到某点的最短路径。</p></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><blockquote><p>能解决的问题：无负边的单源最短路</p></blockquote><blockquote><p>在带权图 G = (V, E) 中，每条边都有一个权值w[i]。路径的长度为路径上所有边权之和。</p><p>求源点 s到图中其余各顶点的最短路径。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>解决单源最短路径问题常用 Dijkstra 算法，用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算法的主要特点是以起点为中心，逐层向外扩展，每次都会取一个最近点继续扩展，直到取完所有点为止。</p></blockquote><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><blockquote><p>我们定义带权图 G所有顶点的集合为V，接着我们再定义已确定从源点出发的最短路径的顶点集合为 U，初始集合 U 为空，记从源点 s 出发到每个顶点 vv 的距离为 dist_v，初始 dist_s=0。接着执行以下操作：</p><ol><li>从 V-U 中找出一个距离源点最近的顶点 v，将 v 加入集合 U，并用 dist_v 和顶点 v 连出的边来更新和 v 相邻的、不在集合 U 中的顶点的 dist；</li><li>重复第一步操作，直到 V=U或找不出一个从 s出发有路径到达的顶点，算法结束。<br>如果最后V≠U，说明有顶点无法从源点到达；否则每个 dist_i表示从 出发到顶点i 的最短距离。</li></ol></blockquote><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><blockquote><p>Dijkstra最简单的版本就是使用一个数组当作上述的集合U，每一次遍历，找出目前最新且最短的边权，以它为新的源点，同时更新与它相关的最短路径的值。</p><p>我们可以使用一个优先队列去代替数组承担集合U，这样可以保证每次取出队列头部的边权当前最小的。省去了遍历和对比的时间。</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="http://wiki.mbalib.com/w/images/6/65/Dijkstra%E7%AE%97%E6%B3%95%E5%9B%BE.jpg" alt=""></p><blockquote><p>如上图 ，源点为左上角，黄色点内的数字代表源点到他们的距离。初始值都是无穷大99。</p><p>先push源点，然后开始探索图，取得队列头，即源点，开始遍历，源点到右边的点边权为2，比之前的99要小，那么更新距离，同时把这个点push进去，同理对其他连接的两个点进行操作。更新后的最新距离分别为9和6，当前优先队列的值为：2,6,9。这个时候发现没有连接其他点了，结束当前循环。此时的图为第一行第二列。</p><p>因为是优先队列，我们取得的头部是源点距离为2的点，也是除了源点到自身以外当前最短的点。同样进行上述操作。</p><p>因为每一次循环，已经确定过最短路径的点不会再被push到优先队列中，所以在优先队列为空的时候，我们已经获得了源点到各点的最短距离。</p><p>如果发现到某点的最短距离为99(无穷大)，说明无法到达这个点。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//存储from点,to点,和权值</span></span><br><span class="line"><span class="comment">//pair是std中的一种数据结构，存储两个数据，分别用first、second取得。</span></span><br><span class="line"><span class="comment">//可以用结构体代替</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;Edge[maxn];</span><br><span class="line"><span class="comment">//存储路径长度。</span></span><br><span class="line"><span class="keyword">int</span> s[maxn];</span><br><span class="line"><span class="comment">//根据节点数初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge[i].clear();</span><br><span class="line">        <span class="comment">//因为求的是最小，所以初始值应该是无穷大，方便对比</span></span><br><span class="line">        s[i]=<span class="number">1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstraByQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//点数目，边数目，源点</span></span><br><span class="line">    <span class="keyword">int</span> n,e,sourse;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e&gt;&gt;sourse;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    init(n);</span><br><span class="line">    <span class="comment">//from,to,worth</span></span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="comment">//x-&gt;y=w</span></span><br><span class="line">        Edge[x].push_back(make_pair(y,w));</span><br><span class="line">        <span class="comment">//如果是无向图，那么反过来添加一次。</span></span><br><span class="line">        <span class="comment">//Edge[y].push_back(make_pair(x,w));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//源点到自身的路径肯定为0</span></span><br><span class="line">    s[sourse]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//优先队列 ，存储边权，目标点(to)，优先队列会默认按照边权从大到小排序</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">    <span class="comment">//把源点到自身的距离(0)，以及自己的节点push到优先队列中</span></span><br><span class="line">    Q.push(make_pair(<span class="number">0</span>,sourse));</span><br><span class="line">    <span class="comment">//开始探索地图</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取当前相对最新点，然后从优先队列中弹出</span></span><br><span class="line">        <span class="keyword">int</span> cur=Q.top().second; Q.pop();</span><br><span class="line">        <span class="comment">//遍历当前点所连接的点(to)，判断他们之间的边权</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Edge[cur].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取得点</span></span><br><span class="line">            <span class="keyword">int</span> target=Edge[cur][i].first;</span><br><span class="line">            <span class="comment">//判断当前记录的 源点到目标点的距离s[target] 和当前最新点与目标点的距离Edge[cur][i].second+s[cur]长度关系</span></span><br><span class="line">            <span class="keyword">if</span>(s[target]&gt;Edge[cur][i].second+s[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果发现当前记录并不是最短距离，那么就更新它</span></span><br><span class="line">                s[target]=Edge[cur][i].second+s[cur];</span><br><span class="line">                <span class="comment">//把到达这个点的边权和点下标push到优先队列中，因为优先队列默认是按大到小排序，我们的需求是小到大，所以推入-1*边权就可以了。</span></span><br><span class="line">                <span class="comment">//如果使用自定义的结构体，可以另写一个cmp。</span></span><br><span class="line">                Q.push(make_pair(<span class="number">-1</span>*s[target],target));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当上面的队列为空的时候，说明我们以及探索完整个图了，此时我们的s[]储存的就是源点到其他点的最短距离了。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><blockquote><p>能解决的问题：有负边的单源最短路</p></blockquote><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>其实 SPFA 本质是 Bellman-ford 算法的队列优化。由国内段凡丁教授发表，大家可以自行百度查阅相关信息。</p><p>如果没有负权边的情况下还是使用堆/优先队列优化的dijkstra吧。</p></blockquote><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><blockquote><p>在 SPFA 算法中，使用 d_i表示从源点到顶点 i 的最短路，额外用一个队列来保存即将进行拓展的顶点列表，并用 inq_i 来标识顶点 i是不是在队列中。</p><ol><li>初始队列中仅包含源点，且源点 s 的 d_s=0。</li><li>取出队列头顶点 u，扫描从顶点 u 出发的每条边，设每条边的另一端为 v，边 &lt;u,v&gt; 权值为 w，若 d_u+w&lt;d_v，则</li></ol><ul><li>将 d_v修改为 d_u+w</li><li>若 vv不在队列中，则将 v入队</li></ul><ol><li>重复步骤 2 直到队列为空<br>最终 dd数组就是从源点出发到每个顶点的最短路距离。如果一个顶点从没有入队，则说明没有从源点到该顶点的路径。</li></ol></blockquote><h3 id="负环判断"><a href="#负环判断" class="headerlink" title="负环判断"></a>负环判断</h3><blockquote><p>在进行 SPFA 时，用一个数组 cnt_i 来标记每个顶点入队次数。如果一个顶点入队次数 cnt_i大于顶点总数 n，则表示该图中包含负环。</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote><p>在这里贴下最简单的spfa实现，至于lll和slf优化在日后了解后再更新。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;Edge[maxn];</span><br><span class="line"><span class="comment">//多出的inQueue是为了判断某点是否在队列中。</span></span><br><span class="line"><span class="keyword">int</span> s[maxn],inQueue[maxn];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge[i].clear();</span><br><span class="line">        s[i]=<span class="number">1e9</span>;</span><br><span class="line">        inQueue[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e,source;</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="comment">//记录被推入队列的次数，如果超过点数目n，说明有负环。</span></span><br><span class="line">    <span class="keyword">int</span> pushCount[maxn];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e&gt;&gt;source;</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        Edge[x].push_back(make_pair(y,w));</span><br><span class="line">        <span class="comment">//初始化推入次数为0</span></span><br><span class="line">        pushCount[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里使用的是队列不是优先队列，lll和slf优化可以使用deque</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="comment">//到自身距离为0</span></span><br><span class="line">    s[source]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//推入次数更新</span></span><br><span class="line">    pushCount[source]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//推入</span></span><br><span class="line">    Q.push(source);</span><br><span class="line">    <span class="comment">//开始探索</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取队头</span></span><br><span class="line">        <span class="keyword">int</span> cur=Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="comment">//此时队头对应的点已经不在队列里了。</span></span><br><span class="line">        inQueue[cur]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//和上面的dijkstra算法一样进行松弛处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Edge[cur].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> target=Edge[cur][i].first;</span><br><span class="line">            <span class="keyword">if</span>(s[target]&gt;Edge[cur][i].second+s[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最短路径</span></span><br><span class="line">                s[target]=Edge[cur][i].second+s[cur];</span><br><span class="line">                <span class="comment">//如果这个点依然在队列里，那么就不需要推入</span></span><br><span class="line">                <span class="keyword">if</span>(inQueue[target])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">               <span class="comment">//如果推入此时大于点的数目n，说明有负环</span></span><br><span class="line">                <span class="keyword">if</span>(++pushCount[target]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                                     <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                     <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再此将它推入</span></span><br><span class="line">                inQueue[target]=<span class="number">1</span>;</span><br><span class="line">                Q.push(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出最短距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><blockquote><p>能解决的问题：多源点最短路径</p><p>时间复杂度很高，毕竟要求出所有点到其他点的最短距离。</p></blockquote><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Floyd 算法是一种利用动态规划的思想、计算给定的带权图中任意两个顶点之间最短路径的算法。相比于重复执行多次单源最短路算法，Floyd 具有高效、代码简短的优势，在解决图论最短路题目时比较常用。</p></blockquote><h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><blockquote><p>Floyd 的基本思想是：对于一个顶点个数为 n 的有向图，并有一个n×n 的E[][]，其中矩阵横列下标相等，代表自身到自身，对应的值应为0<br>对于其余任意两个顶点 i,j若它们之间存在有向边，则以此边权上的权值作为E[i][j]=w；<br>若两个顶点i,j 之间不存在有向边，则E[i][j]=INF。<br>对于循环阶段 ，尝试增加一个中继点 k，如果通过中间顶点使得最短路径变短了，就更新结果。<br>累加 k，重复遍历所有可能成为中继的点下标，直到 k=n。<br>算法结束后，矩阵 E[][]中的元素就代表着图中任意两点之间的最短路径长度。</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//用矩阵存储距离</span></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="comment">//到自身的距离为0</span></span><br><span class="line">                g[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//初始化为无穷大</span></span><br><span class="line">                g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e;</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        <span class="comment">//x到y的边权为w</span></span><br><span class="line">        g[x][y]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三重循环，分别代表中继点k、当前点i(from)，目标点j(to)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">//如果i到k+k到j的距离比原来i直接到j的距离还短，就更新</span></span><br><span class="line">                <span class="keyword">if</span> (g[i][k] + g[k][j] &lt; g[i][j]) &#123;</span><br><span class="line">                    g[i][j] = g[i][k] + g[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h1><blockquote><p>一个有 n 个结点的<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p><p>一般常见题目是求道路如何建设，使得各个位置能够互通，并且花费最少。</p></blockquote><h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Prim算法求最小生成树的时候和边数无关，和顶点数有关，所以适合求解稠密网的最小生成树。</p><p>每一次从已经纳入最小生成树的点出发，找到所连接的未纳入的最短边权点，将其纳入生成树中，直到遍历所有点。</p></blockquote><h3 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h3><blockquote><ol><li><p>将一个图分为两部分，一部分归为点集U，一部分归为点集V，U的初始集合为{V1}，V的初始集合为{ALL-V1}。</p></li><li><p>针对U开始找U中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到U中，并且从V中删除（注意不能形成环）。</p></li><li><p>递归执行步骤2，直到V中的集合为空。</p></li><li><p>U中所有节点构成的树就是最小生成树。</p></li></ol></blockquote><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553341419376&amp;di=6ec4836b72efa5b6776dbb8bd54b0e37&amp;imgtype=0&amp;src=http%3A%2F%2Fpic002.cnblogs.com%2Fimages%2F2011%2F282432%2F2011052215540276.jpg" alt=""></p><blockquote><p>如上图，我们以点为单位，从V1点出发，找到它连接的点V2、V3、V4，其中最短边权为V1-&gt;V3=1，所以我们将V3纳入最小生成树(算法流程所述的集合U)，此时U为{V1、V3}。</p><p>然后从V1、V3这个最小生成树所连接的点继续寻找，找到V3-&gt;V6的边权最小，为4，那么纳入最小生成树，继续以上操作，直到遍历完毕。</p><p>如果遍历结束后，发现有些点没被访问，就说明无法构成生成树。</p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e+1</span>;</span><br><span class="line"><span class="comment">//和前面的算法一样使用vector&lt;pair&lt;int,int&gt; &gt;</span></span><br><span class="line"><span class="comment">//pair存储to,value</span></span><br><span class="line"><span class="comment">//G[i]的i代表from</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;G[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,e,x,y,z;</span><br><span class="line">    <span class="comment">//最小生成树的权值</span></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//输入点、边的数目</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="comment">//一般都是求无向图的最小生成树，有向图可以使用最小树形图。</span></span><br><span class="line">        <span class="comment">//-1*z 是因为优先队列默认从大到小，我们需要从小到大，随意推入取负的值。</span></span><br><span class="line">        <span class="comment">//自己实现结构体可以自己另写cmp</span></span><br><span class="line">G[x].push_back(make_pair(y,<span class="number">-1</span>*z));</span><br><span class="line">G[y].push_back(make_pair(x,<span class="number">-1</span>*z));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//从第一个点开始，下标为0，或者定义为1，后面也要从1开始。</span></span><br><span class="line">vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; Q;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[<span class="number">0</span>].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//遍历连接到的点，推入优先队列中，会自动按边权值排序。</span></span><br><span class="line">Q.push(G[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//开始探索</span></span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//取得队头的点的连接目标点to和权值value</span></span><br><span class="line"><span class="keyword">int</span> to=Q.top().first;</span><br><span class="line"><span class="keyword">int</span> value=Q.top().second;</span><br><span class="line">        <span class="comment">///弹出</span></span><br><span class="line">Q.pop();</span><br><span class="line">        <span class="comment">//如果已经访问过，也就是说，已经在当前的生成树中/集合U中</span></span><br><span class="line"><span class="keyword">if</span>(vis[to])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//否则标记以访问/纳入</span></span><br><span class="line">vis[to]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//加入最小生成树的权值，因为之前我们把每条边的权值当作负数推入，这里减到而不是加上，--得+</span></span><br><span class="line">res-=value;</span><br><span class="line">        <span class="comment">//遍历当前点可以到达的所有点，推入优先队列。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[to].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">Q.push(G[to][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果有点没访问，说明无法构成最小生成树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//输出花费</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><blockquote><p>与prim相反，kruskal算法的注重点是边而不是点，它每次取图中相对权值最小的边，然后将边的两端点纳入集合中。而它基于并查集的思想。（<a href="https://blog.csdn.net/qq_41593380/article/details/81146850">什么是并查集</a>)</p></blockquote><h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><blockquote><p>创建一个数组，为每个节点存储自身的父节点，初始化为自身。也就是刚开始，每个人只指向自己。</p><p>我们将边权按从小到大的顺序，排序好边权和对应的两端点。</p><p>我们取当前最小边权，把其两端点合并，也就是让他们的存储父节点的数组对应的值指向同一个节点，换句话说，这就是一个两个点组合成的子树了。</p><p>一直到所有点都纳入那个子树。</p><p>注意的是，合并两个点时，不是简单的赋值点下标，而是应该找到点的最终父节点，再把其赋值给另一端点的数组索引中。</p></blockquote><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553341419376&amp;di=6ec4836b72efa5b6776dbb8bd54b0e37&amp;imgtype=0&amp;src=http%3A%2F%2Fpic002.cnblogs.com%2Fimages%2F2011%2F282432%2F2011052215540276.jpg" alt=""></p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553344343733&amp;di=3c4090aa5fbe76c7819d0577bcc38f64&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.xdwy.com.cn%2FDOWN%2Fcourse%2Fsffxysj%2Fmnst%2Fmnst1.files%2Fimage011.gif" alt=""></p><blockquote><p>下图是kruskal算法，因为和prim算法用的是同一个原图，所以一起展示。</p><p>将边权排序得：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5-&gt;5-&gt;6-&gt;6</p><p>这里采用按秩合并。</p><p>我们取1，它的两端点是V1、V3 ，将他们合并 {V1,V3}，他们此时记录父节点的数组f[V1]=f[V3]=V1;</p><p>同理取2，它的两端点是V4、V6， 将他们合并{V4，V6},他们此时记录父节点的数组f[V4]=f[V6]=V4;</p><p>同理取3，它的两端点是V2、V5， 将他们合并{V2，V5},他们此时记录父节点的数组f[V2]=f[V5]=V2;</p><p>同理取4，它的两端点是V3、V6， 将他们合并{V3，V6},注意，这时候，V3的父节点即f[V3]的值为V1，而V6的父节点即f[V6]的值为V4，将其赋值，得f[V3]=f[V4]=V1,而V6的父节点依然为V4，但是V6的祖父节点f[V4]是V1了。合并的集合也成{V1、V3 、V6、V4}</p><p>此时树为：V1-&gt;V3</p><p>​            \-&gt;V4-&gt;V6</p><p>同理取5，把端点V3的祖父节点赋值给另一个断点的祖父节点f[V2]，最后得树：</p><p>V1-&gt;V3-&gt;V2-&gt;V5</p><p>​     \-&gt;V4-&gt;V6</p></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//记录父亲节点</span></span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="comment">//因为我们需要对边权排序，并且需要获得两端点的下标，那么之前的vector&lt;pair&lt;,&gt;&gt; 在这里就用处不大了。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="comment">//重写操作符，让它进入优先队列时自动按从小到大排序</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge x,<span class="keyword">const</span> Edge y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.value&gt;y.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//初始化，让所有点的父节点为自身</span></span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找组父节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果父节点是自身，说明已经到头了，也就是找到祖父了。</span></span><br><span class="line">    <span class="keyword">return</span> father[target]==target ?target:findRoot(father[target]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两个点x和y是不是指向同一个父亲节点，也就是是否在同一个集合中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnion</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findRoot(x)==findRoot(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comeTogeter</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isUnion(x,y)) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//把x的祖父节点的父节点设置为y的祖父节点。</span></span><br><span class="line">    father[findRoot(x)]=findRoot(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//点、边</span></span><br><span class="line">    <span class="keyword">int</span> n,e;</span><br><span class="line"><span class="comment">//to from worth</span></span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="comment">//花费</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//临时Edge对象</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    init(n);</span><br><span class="line">    priority_queue&lt;Edge&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        Edge temp;</span><br><span class="line">        temp.from=x;</span><br><span class="line">        temp.to=y;</span><br><span class="line">        temp.value=w;</span><br><span class="line">        Q.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    Edge temp;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//取队列头，C++提供浅拷贝，直接赋值就好了</span></span><br><span class="line">        temp=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="comment">//判断是否在同个集合里，如果在就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(isUnion(temp.from,temp.to))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">         <span class="comment">//不在，那么整合</span></span><br><span class="line">        comeTogeter(temp.from,temp.to);</span><br><span class="line">        <span class="comment">//加入边权</span></span><br><span class="line">        res+=temp.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是不是所有点都在一个集合/生成树中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!isUnion(<span class="number">0</span>,i))</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="最大匹配问题"><a href="#最大匹配问题" class="headerlink" title="最大匹配问题"></a>最大匹配问题</h1><blockquote><p>把所有点分成两个左右集合，左右集合里的点可以与对面集合的多个点有边，但不与同集合的点有边。</p><p>那么一般会问你求最大匹配和完美匹配。</p><p>什么是最大匹配？</p><p>​    上面谈到一个点可以与对面多个点有边，所以有可能出现左集合中的两点与对面集合的某点都有一条边，那么怎么分配，才能尽量让左右集合里的点一一对应且不重复呢。</p><p>​    网上很多都是拿男女生牵手的例子，每个男生都对自己心仪的女生们发出牵手请求，如何安排使得尽量满足每个男生都能牵到心仪女生的手，并且不会出现两个男生抢一个女生的 情况。求能牵手成功的最大数量，就是最大匹配。</p><p>​        </p><p>什么时完美匹配？</p><p>​    基于最大匹配，左右集合的所有点都与对面集合有且只有一条边。</p><p>​    如图Fig.4 ，1-7；2-5；3-6‘4-8；一一对应且不占用同个右边的点。</p></blockquote><p><img src="https://img.renfei.org/2013/08/2.png" alt=""></p><p><img src="https://img.renfei.org/2013/08/4.png" alt="Maximum Matching"></p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><blockquote><p>发现概述不起来，直接看算法流程吧0 0</p></blockquote><h3 id="算法流程-5"><a href="#算法流程-5" class="headerlink" title="算法流程"></a>算法流程</h3><blockquote><p>假设有集合UX、UY，其中UX有多个点连接UY中的n个点，n&gt;=1</p><p>从UX的点xi开始遍历，找到它连接的第一个对面点yj，如果这个对面点yj没有被连接，那么我们将该点xi和对面点yi连接。</p><p>如果对面点yj被连接了，这时候并不是直接放弃，我们获取对面点yj所连接的点xk,这时候我们对xk进行上述操作，也就是说，我们要找到xk能连接的下一个对面点(抛开yj)</p><p>​    1.如果找不到，说明xk只能连接yj，那么xi只能找它的下一个可连接点。</p><p>​    2.如果找得到，那么让xk放弃yj，连接其他的点，让xi与yj连接。</p><p>OK，这就是主要流程，我们对所有UX中的点按顺序进行上述操作，直到最后一个点，我们就可以找出最大匹配的数量了。</p></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵 值为1 代表i和j可以连接</span></span><br><span class="line"><span class="keyword">int</span> e[maxn][maxn];</span><br><span class="line"><span class="comment">//记录当前X集合和Y集合里某点连接的点下标</span></span><br><span class="line"><span class="keyword">int</span> fromX[maxn],fromY[maxn];</span><br><span class="line"><span class="comment">//是否访问过</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="comment">//X集合的数目和Y的</span></span><br><span class="line"><span class="keyword">int</span> nX,nY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试搜寻连接 </span></span><br><span class="line"><span class="comment">//x：尝试连接的点下标</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">line</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从1到nY遍历，也可以从0到ny-1，看输入情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=nY;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果他们可以连接 并且 Y集合的y点没有被访问过(被连接过)</span></span><br><span class="line">        <span class="keyword">if</span>(e[x][y]&amp;&amp;!vis[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//访问y</span></span><br><span class="line">            vis[y]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果y连接的点=-1，-1代表还没和任何点连接</span></span><br><span class="line">            <span class="comment">//或者连接了某点 调用line为这个点递归查找是否可以连接其他点</span></span><br><span class="line">            <span class="keyword">if</span>(fromY[y]==<span class="number">-1</span>||line(fromY[y]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//让x和y连接，并在fromX/Y中登记连接对象的下标</span></span><br><span class="line">                fromX[x]=y;</span><br><span class="line">                fromY[y]=x;</span><br><span class="line">                <span class="comment">//返回可以连接</span></span><br><span class="line">                <span class="comment">//注意 如果这个点y是第一次被访问，此时返回true代表它第一次被连接</span></span><br><span class="line">                <span class="comment">//如果是被递归调用，则代表它以被允许连接的下一个点连接</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回不可以连接||不可以被下一个点连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大匹配</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//连接数n x集合数 y集合数</span></span><br><span class="line">    <span class="keyword">int</span> n,x,y;</span><br><span class="line">    <span class="comment">//最大匹配的数值</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(fromX,<span class="number">-1</span>,<span class="keyword">sizeof</span>(fromX));</span><br><span class="line">    <span class="built_in">memset</span>(fromY,<span class="number">-1</span>,<span class="keyword">sizeof</span>(fromY));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;nX&gt;&gt;xY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="comment">//可以连接 为1</span></span><br><span class="line">        e[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果x集合中的i还没有和对面连接</span></span><br><span class="line">        <span class="keyword">if</span>(fromX[i]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//格式化访问数组vis 这个是精髓 因为每一次调用line，都可能造成第一次连接的那个点的重新连接，所以vis数组是要被格式化的。</span></span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="comment">//如果可以连接 那么数目加1</span></span><br><span class="line">            <span class="keyword">if</span>(line(i)) sum++;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果sum=nX||sum=nY  （看题目要求，以X集合为主还是Y集合为主）</span></span><br><span class="line">    <span class="comment">//如果X/Y集合的所有点都成功连接了唯一的对面集合的点 那么就是完美匹配~</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;常用算法的C++实现&gt;大整数字符串的加减乘(含负数)</title>
      <link href="/2019/MyAlgorithm-bigNum/"/>
      <url>/2019/MyAlgorithm-bigNum/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是大数"><a href="#什么是大数" class="headerlink" title="什么是大数"></a>什么是大数</h2><blockquote><p>首先计算机的数据类型所能表示的范围都是有限的。</p></blockquote><center>表数据来源于网络</center><table><thead><tr><th>Type</th><th>Size</th><th>数值范围</th></tr></thead><tbody><tr><td>无值型void</td><td>0 byte</td><td>无值域</td></tr><tr><td>布尔型bool</td><td>1 byte</td><td>true   false</td></tr><tr><td>有符号短整型short [int] /signed short [int]</td><td>2 byte</td><td>-32768~32767</td></tr><tr><td>无符号短整型unsigned short [int]</td><td>2 byte</td><td>0~65535</td></tr><tr><td>有符号整型int /signed [int]</td><td>4 byte</td><td>-2147483648~2147483647</td></tr><tr><td>无符号整型unsigned [int]</td><td>4 byte</td><td>0~4294967295</td></tr><tr><td>有符号长整型long [int]/signed long [int]</td><td>4 byte</td><td>-2147483648~2147483647</td></tr><tr><td>无符号长整型unsigned long [int]</td><td>4 byte</td><td>0~4294967295</td></tr><tr><td>long long</td><td>8 byte</td><td>0~18446744073709552000</td></tr><tr><td>有符号字符型char/signed char</td><td>1 byte</td><td>-128~127</td></tr><tr><td>无符号字符型unsigned char</td><td>1 byte</td><td>0~255</td></tr><tr><td>宽字符型wchar_t (unsigned short.)</td><td>2 byte</td><td>0~65535</td></tr><tr><td>单精度浮点型float</td><td>4 byte</td><td>-3.4E-38~3.4E+38</td></tr><tr><td>双精度浮点型double</td><td>8 byte</td><td>1.7E-308~1.7E+308</td></tr><tr><td>long double</td><td>8 byte</td></tr></tbody></table><blockquote><p>而比这些数值范围更大、或者是计算之后超出数值范围的数值都可以成为大数，当我们要对位数达到上百位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。</p></blockquote><h2 id="正数加法"><a href="#正数加法" class="headerlink" title="正数加法"></a>正数加法</h2><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><blockquote><p>思想是采用用字符串表示大数。末尾逐位相加，超十进位。</p></blockquote><h4 id="计算前"><a href="#计算前" class="headerlink" title="计算前"></a>计算前</h4><h5 id="被加数比加数长度短"><a href="#被加数比加数长度短" class="headerlink" title="被加数比加数长度短"></a>被加数比加数长度短</h5><blockquote><p>为了方便计算，我们在接受到两个需要相加的正整数时，应该将更长位数的大数置上，短的置下。</p></blockquote><h4 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h4><h5 id="1-长度不扩充情况"><a href="#1-长度不扩充情况" class="headerlink" title="1.长度不扩充情况"></a>1.长度不扩充情况</h5><center>197+13计算</center><blockquote><p>面向下面的大数，从末位开始与上置位的每一位对应数值相加。即表中的下标2。</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>a</td><td>1</td><td>9</td><td>7</td></tr><tr><td>b</td><td></td><td>1</td><td>3</td></tr></tbody></table><blockquote><p>​    a[2]+b[2] =&gt; 7+3=10，发现计算点相加后大于等于10而造成了进位，那么我们应该自身减10，通过为上置位的进位点加1，即9+1=10。至于处理后进位点是否也大于10，我们无需处理，因为我们只需要关心当前位的运算，以及对前一位的影响（即表中的计算点和进位点）。 假设进位点同时也大于10，那么我们在它变成当前点时再进行计算进位就好了。</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th>进位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>9-&gt;10</td><td>7-&gt;10-&gt;0</td></tr><tr><td>b</td><td></td><td>1</td><td>3</td></tr></tbody></table><blockquote><p>​    计算点计算，10+1=11，  计算点自身减10，发现需要进位，进位点加1。得到结果210。</p><p>如果进位时，发现进位点不存在，那么意味着相加后，长度发生了变化，这个时候，如果只是相加运算，我们只需要在上置位字符串a前方加一个’1’就好了，<strong>为什么就是’1’呢，因为保证计算点的数值是个数位，无论再怎么大也不会产生进位点进2位的情况。</strong></p><p><strong>但是，如果需要被大数相乘的函数调用，就不能简单的加1了，因为相乘后可能出现进位点的数值超过1.当然是为了以防万一，但感觉似乎不会产生进位+2以上的情况。。。</strong></p></blockquote><table><thead><tr><th>当前游标</th><th>进位点</th><th>计算点</th><th></th></tr></thead><tbody><tr><td>a</td><td>1-&gt;2</td><td>10-&gt;11-&gt;1</td><td>0</td></tr><tr><td>b</td><td></td><td>1</td><td>3</td></tr></tbody></table><h5 id="2-长度扩充情况"><a href="#2-长度扩充情况" class="headerlink" title="2.长度扩充情况"></a>2.长度扩充情况</h5><center>99+1计算</center><table><thead><tr><th>当前游标</th><th>进位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td>9</td><td>9</td></tr><tr><td>b</td><td></td><td>1</td></tr></tbody></table><blockquote><p>a[1]+b[1]=&gt;9+1=10，计算点自身减10，进位点进位，9+1=10，10-10=0</p></blockquote><table><thead><tr><th>当前游标</th><th>进位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td>9-&gt;10</td><td>9-&gt;10-&gt;0</td></tr><tr><td>b</td><td></td><td>1</td></tr><tr><td></td></tr></tbody></table><blockquote><p>计算点a[0]+b[0]=&gt; 10+0=0,，计算点自身减10，10-10=0,进位点进位，发现超出长度，此时在字符串首加’1’，得到结果100。</p></blockquote><table><thead><tr><th>当前游标</th><th>进位点</th><th>计算点</th><th></th></tr></thead><tbody><tr><td>a</td><td>1</td><td>10-&gt;0</td><td>0</td></tr><tr><td>b</td><td></td><td></td><td>1</td></tr></tbody></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">bigNumAdd</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把长的字符串上置位，即换成a</span></span><br><span class="line">    <span class="keyword">if</span>(a.length()&lt;b.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        swap(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算点下标从长度-1开始，取两个i、j变量指向计算点，是为了判断是否结束以及是否超出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length()<span class="number">-1</span>,j=b.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//j是字符串b的计算点下标，如果依然大于0，说明还在长度内，可以正常计算</span></span><br><span class="line">        <span class="comment">//正常计算的时候利用ascii码性质-'0'获得实际上增加的数值</span></span><br><span class="line">        <span class="comment">//如果超出了就加0，即不变</span></span><br><span class="line">        a[i]+=(j&gt;=<span class="number">0</span>?b[j]-<span class="string">'0'</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//发现计算点大于10，需要进位</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]-<span class="string">'0'</span>&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;           </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果计算点在a中的位置不是首位，那么进位点正常加上进位数</span></span><br><span class="line">            <span class="keyword">if</span>(i)</span><br><span class="line">                a[i<span class="number">-1</span>]+=((a[i]-<span class="string">'0'</span>)/<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果是首位，也就是说，进位点超出了原本的长度，那么我们在a字符串这里加上进位的值就好了</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a=(<span class="keyword">char</span>)(((a[i]-<span class="string">'0'</span>)/<span class="number">10</span>)+<span class="string">'0'</span>)+a;</span><br><span class="line">             <span class="comment">//自身余10</span></span><br><span class="line">            a[i]=((a[i]-<span class="string">'0'</span>)%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><h3 id="大体思路-1"><a href="#大体思路-1" class="headerlink" title="大体思路"></a>大体思路</h3><blockquote><p>关键思路和加法差别不大，只需要在对应的操作更改以下就好了，当然，在这之前需要对被减数和减数。</p></blockquote><h4 id="计算前-1"><a href="#计算前-1" class="headerlink" title="计算前"></a>计算前</h4><h5 id="1-被减数为负数"><a href="#1-被减数为负数" class="headerlink" title="1.被减数为负数"></a>1.被减数为负数</h5><blockquote><p>由 -a-b = -(a+b) ，其中a&gt;0 得</p><p>我们将被减数的负号去掉，然后把被减数和减数当作两个正整数相加，得到的结果加上符号即可。</p><p>直接调用上面写的相加函数就好了。</p></blockquote><h5 id="2-被减数是正数"><a href="#2-被减数是正数" class="headerlink" title="2.被减数是正数"></a>2.被减数是正数</h5><blockquote><p>这时候我们要考虑被减数和减数他们的长度关系了,如果被减数长度比减数小，那么结果必然是负数。</p><p>由 a-b = –(b-a)，其中a&gt;0 得</p><p>我们将被减数和减数交换，让长的减数成为被减数，然后在结果前加上负号。</p></blockquote><h4 id="计算过程-1"><a href="#计算过程-1" class="headerlink" title="计算过程"></a>计算过程</h4><center>100-1计算</center><table><thead><tr><th>当前游标</th><th></th><th>借位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>0</td><td>0</td></tr><tr><td>b</td><td></td><td></td><td>1</td></tr></tbody></table><blockquote><p>a[2]-b[2]=&gt;0-1=-1,，计算点发现小于0，将自身取绝对值,，借位点借位，借位点减1;</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th>借位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>0-&gt;-9</td><td>0-&gt;-9-&gt;9</td></tr><tr><td>b</td><td></td><td></td><td>1</td></tr></tbody></table><blockquote><p>a[1]-b[1]=&gt;9-0=-9,，计算点发现小于0，将自身取绝对值,，借位点借位，借位点减1;</p></blockquote><table><thead><tr><th>当前游标</th><th>借位点</th><th>计算点</th><th></th></tr></thead><tbody><tr><td>a</td><td>1-&gt;0</td><td>-9-&gt;9</td><td>9</td></tr><tr><td>b</td><td></td><td></td><td>0</td></tr></tbody></table><blockquote><p>这个时候，发现结果的有效长度应该由3变为2，那么我们将第一个字符串元素去掉即可。</p></blockquote><table><thead><tr><th>当前游标</th><th>借位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td>9</td><td>9</td></tr><tr><td>b</td><td></td><td>0</td></tr></tbody></table><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">bigNumDel</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断结果是不是负数，根据这个来判断是否在字符串前面加'-'</span></span><br><span class="line">    <span class="keyword">bool</span> isFushu=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//情况1，被减数是负数，我们将其取正，两数相加，再加上负号</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a.erase(a.begin());</span><br><span class="line">        isFushu=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-'</span>+bigNumAdd(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况2，判断长度，如果被减数短，那么交换，结果必为负数</span></span><br><span class="line">    <span class="keyword">if</span>(a.length()&lt;b.length())</span><br><span class="line">    &#123;</span><br><span class="line">        isFushu=<span class="literal">true</span>;</span><br><span class="line">        swap(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与加法的遍历方法一致</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length()<span class="number">-1</span>,j=b.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//与加法的运算一致</span></span><br><span class="line">        a[i]-=(j&gt;=<span class="number">0</span>?b[j]-<span class="string">'0'</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果小于0</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取正数，为什么是加10呢？ 举个例子</span></span><br><span class="line">            <span class="comment">//a[i]='0'-1 即 数值结果为-9  取正应该得9</span></span><br><span class="line">            <span class="comment">//a[i]+=10 -&gt;'0'-1+10= '0'+9 ='9'</span></span><br><span class="line">             a[i]=a[i]+<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//如果还在有效长度内</span></span><br><span class="line">            <span class="keyword">if</span>(i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//借位</span></span><br><span class="line">                a[i<span class="number">-1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则不在有效长度内</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//结果为负数</span></span><br><span class="line">                isFushu=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始去首位0操作</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(a[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a.erase(a.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否负数来加符号</span></span><br><span class="line">        <span class="keyword">return</span> isFushu?<span class="string">'-'</span>+a:a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h3 id="大体思路-2"><a href="#大体思路-2" class="headerlink" title="大体思路"></a>大体思路</h3><blockquote><p>相信大部分人首算乘法的时候，都习惯从末尾开始乘，然后进位，但是要仔细考虑，进位之后，得到的数据应该缓存起来，最后相加而不是直接在原字符串上改变进位点的数值。也就是说 567 * 3 =21+180+1500 . </p><p>上面这种末尾相乘方法其实效率并不高，每个数字之间相乘的结果都要缓存一次，而其实我们只需要首位相乘就可以解决多次缓存的问题了，即从a<em>b 中，对a的首位开始进行乘法运算，因为从前往后运算，计算点影响的值只会是前一位进位点，后面的都不会被影响到，所以只需要新建一个临时字符串c赋值a的元素，然后直接在c上更改就好。 也就是 567 </em> 3 =1701</p></blockquote><h3 id="计算过程-2"><a href="#计算过程-2" class="headerlink" title="计算过程"></a>计算过程</h3><h4 id="计算前-2"><a href="#计算前-2" class="headerlink" title="计算前"></a>计算前</h4><blockquote><p> 乘法运算也需要和前两种运算一样，要求长度更长的置上方。</p></blockquote><h5 id="1-统计两个乘数是否为负数"><a href="#1-统计两个乘数是否为负数" class="headerlink" title="1.统计两个乘数是否为负数"></a>1.统计两个乘数是否为负数</h5><blockquote><p>负负得正，正负得负，将负号统计并且移除，在最后结果上根据情况加负号。</p></blockquote><h5 id="2-非特殊情况"><a href="#2-非特殊情况" class="headerlink" title="2.非特殊情况"></a>2.非特殊情况</h5><blockquote><p>新建一个字符串res，用于存储结果，然后在b的每位数字开始相乘时，新建一个临时字符串，存储这个数值对a乘法后的结果，然后加入res中。</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>res</td><td></td><td></td><td></td></tr><tr><td>a</td><td>4</td><td>5</td><td>7</td></tr><tr><td>b</td><td>3</td><td>4</td><td></td></tr><tr><td>temp</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><blockquote><p>为了方便演示，我们从b的首位开始逐个对照a的首位开始算，3*4=12，先把2存储在temp的对应位置中。</p><p>在代码中，无论从b的首位还是末位开始遍历，只要从a的首位开始计算就行，只要加’0’的次数正确，结果不变。</p></blockquote><table><thead><tr><th>当前游标</th><th>进位点</th><th>计算点</th><th></th><th></th></tr></thead><tbody><tr><td>a</td><td></td><td>4</td><td>5</td><td>6</td></tr><tr><td>b</td><td></td><td>3</td><td>4</td><td></td></tr><tr><td>temp</td><td></td><td>4-&gt;2</td><td>5</td><td>6</td></tr></tbody></table><blockquote><p>然后12是大于10的，这时候我们需要在temp字符串前加入需要进位的数值 ，即 ‘1’。</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th>进位点</th><th>计算点</th><th></th></tr></thead><tbody><tr><td>a</td><td></td><td>4</td><td>5</td><td>7</td></tr><tr><td>b</td><td></td><td>3</td><td>4</td><td></td></tr><tr><td>temp</td><td>1</td><td>2</td><td>5</td><td>6</td></tr></tbody></table><blockquote><p>接着对a的下一位进行运算，即3*5=15，对应计算点的temp数值改成5，进位点进位1。</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th>进位点</th><th>计算点</th><th></th></tr></thead><tbody><tr><td>a</td><td></td><td>4</td><td>5</td><td>7</td></tr><tr><td>b</td><td></td><td>3</td><td>4</td><td></td></tr><tr><td>temp</td><td>1</td><td>2-&gt;3</td><td>5-&gt;5</td><td>6</td></tr></tbody></table><blockquote><p>同理，对a的下一位继续运算，即3*7=21，对应计算点的temp数值改成1，进位点进位2。</p></blockquote><table><thead><tr><th>当前游标</th><th></th><th></th><th>进位点</th><th>计算点</th></tr></thead><tbody><tr><td>a</td><td></td><td>4</td><td>5</td><td>7</td></tr><tr><td>b</td><td></td><td>3</td><td>4</td><td></td></tr><tr><td>temp</td><td>1</td><td>3</td><td>5-&gt;7</td><td>6-&gt;1</td></tr></tbody></table><blockquote><p>此时temp字符串的值应为’1’ ‘3’ ‘7’ ‘1‘，重点来了，我们应该记住在b字符串运算位距离末位的值，随后根据这个值，对temp末位逐个加’0’</p><p>因为例子中b长度为2，当前从首位开始算， 所以相差1位，那么在temp末尾加1个‘0’</p><p>temp=”13710”,把他加入res,用上述的大数相加运算。</p></blockquote><blockquote><p>同理把4和457进行一次运算，得到的新temp也加入到res中</p><p>最后根据前面统计的负号个数，对结果进行加负号处理。</p></blockquote><h5 id="3-特殊情况"><a href="#3-特殊情况" class="headerlink" title="3.特殊情况"></a>3.特殊情况</h5><blockquote><p>如果按照首位逐个相乘，如果遇到如69<em>9这样，即第一次运算  60 </em> 9=540  , 随后运算 9 * 9 =81 ,发现进位点4+8 超过10 这个时候怎么处理呢。</p><p>很简单，无视就好，它会在被调用大数相加运算的时候，自动向前进位的。</p><p>此时temp=’5’ ‘12’ ‘1’。</p><p>我们bigNumAdd(res,temp)。</p><p>在内循环中，因为12&gt;10 ，会把1加到5身上。结果为621</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">bigNumMul</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//统计负数个数</span></span><br><span class="line">    <span class="keyword">int</span> fushu=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> resStr;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fushu++;</span><br><span class="line">        a.erase(a.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fushu++;</span><br><span class="line">        b.erase(b.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.length()&lt;b.length())</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//面向b的末尾开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=b.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//新建临时字符串</span></span><br><span class="line">        <span class="built_in">string</span> tempStr;</span><br><span class="line">        <span class="comment">//复制严肃，这里其实只要长度相等就可以了，不需要元素一致</span></span><br><span class="line">        tempStr.assign(a);</span><br><span class="line">        <span class="comment">//计算当前b的计算位距离末尾的长度，决定加0次数</span></span><br><span class="line">        <span class="keyword">int</span> zeroB=b.length()-i<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//从a的首位开始，因为这里复制了a的元素，直接从temp上索引</span></span><br><span class="line">        <span class="comment">//如果上面的temp只复制了长度，那么就要从a本身索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tempStr.length();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相乘</span></span><br><span class="line">            <span class="keyword">int</span> res=(tempStr[j]-<span class="string">'0'</span>)*(b[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="comment">//自身更正</span></span><br><span class="line">            tempStr[j]=res%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//相乘结果大于10</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;=<span class="number">10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">//计算点在temp/a的首位，也就说进位点会超出范围</span></span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//在temp前加上进位的值的ascii码</span></span><br><span class="line">                        tempStr=(<span class="keyword">char</span>)((res/<span class="number">10</span>)%<span class="number">10</span>+<span class="string">'0'</span>)+tempStr;</span><br><span class="line">                        <span class="comment">//长度加1，我们的j也要相对后移</span></span><br><span class="line">                        ++j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//否则正常进位</span></span><br><span class="line">                        tempStr[j<span class="number">-1</span>]+=(res/<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加'0'操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;zeroB;k++)</span><br><span class="line">            tempStr+=<span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">//与res相加 如果出现了特殊情况，会在其中被进位修正。</span></span><br><span class="line">        resStr=bigNumAdd(resStr,tempStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断负数情况，加负号</span></span><br><span class="line">    <span class="keyword">return</span> fushu==<span class="number">1</span> ? <span class="string">'-'</span>+resStr:resStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>加法减法从被加/被减末尾开始算。</li><li>减法/乘法需要考虑负数情况。</li><li>乘法从被乘数的首位开始算。</li><li>加法运算要注意进位操作，减法要记得减0操作，乘法要加0操作。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity Anima2D编辑器的轻量骨骼动画和换装使用</title>
      <link href="/2019/MyLearn-Anima2D/"/>
      <url>/2019/MyLearn-Anima2D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="lt-学习记录-gt-Unity-Anima2D编辑器的轻量骨骼动画和换装使用"><a href="#lt-学习记录-gt-Unity-Anima2D编辑器的轻量骨骼动画和换装使用" class="headerlink" title="&lt;学习记录&gt;Unity Anima2D编辑器的轻量骨骼动画和换装使用"></a>&lt;学习记录&gt;Unity Anima2D编辑器的轻量骨骼动画和换装使用</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    前不久觉得骨骼动画难弄而选择帧动画，现在发现，一个人制作帧动画的工作量真的大，特别是发现需要换肤功能的时候，目前没有找到可以让同一个帧动画替换特定像素达到换肤效果的简易方法（<del>shader可以简单换色，但是如果要有特别的形状图案就很复杂了</del>），于是乎找到了一些关于Unity5.x版本之后自带的anima2D骨骼动画系统的一些文档，决定弃用帧动画使用骨骼动画。</p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-25/9150e4e5gy1fygz3nlw8bj20qo0qo3zr.jpg" alt=""></p><p>​    这篇来做一个简易演示。</p><h4 id="图片准备"><a href="#图片准备" class="headerlink" title="图片准备"></a>图片准备</h4><p>​    将精灵图拖到Unity之后设置属性，因为画的时候是以1像素为单位，所以选择了FilterMode为Point。随后通过SpriteEditor将图片切割好，注意这里一定要<strong>规定好切割区域的大小</strong>，也就是规定如所有头部、身体精灵图的共同切割大小，以便骨骼的绑定不会产生换肤的图片偏移，对碰撞体有要求的同样可以设置得精细一点。</p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png" alt=""></p><h4 id="精灵网格和骨骼设置"><a href="#精灵网格和骨骼设置" class="headerlink" title="精灵网格和骨骼设置"></a>精灵网格和骨骼设置</h4><p>​    将必要的头、身体、腿的图片拖入视图后，摆好位置，创建父物体Player，对其一一设置精灵网格，右键2D Object-&gt;SpriteMesh</p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E8%AE%BE%E7%BD%AE%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%B1%82.png" alt=""></p><p>​    随后可以在父物体Player下创建骨骼，右键2D Object-&gt;Bone</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E8%AE%BE%E7%BD%AE%E9%AA%A8%E9%AA%BC.png" alt=""></p><p>​    将创建的骨骼与摆好的图片对齐，如果在骨骼下创建骨骼，会生成子骨骼，子骨骼会随着父骨骼移动。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E5%8F%B3%E6%89%8B%E9%AA%A8%E9%AA%BC.png" alt=""></p><p>​    </p><h4 id="骨骼绑定"><a href="#骨骼绑定" class="headerlink" title="骨骼绑定"></a>骨骼绑定</h4><p>​    设置好骨骼，图片也对应好之后，将网格与骨骼绑定，点击视图中的头，查看监视面板，创建了网格会绑定的两个组件分别是SpriteMeshInstance和SpriteMeshRenderer，本篇只讲解SpriteMeshInstance的用法，SpriteMesh是精灵网格，可以在面板上设置，也可以在代码上设置，这也是本篇换装的重要途径，随后是颜色、材质、层级、Set bones骨骼设置，我们将对应的骨骼拖入这里，<strong>注意，拖入带有子骨骼的骨骼，会将子骨骼一起绑定，若子骨骼需要与其他图片绑定，请删除掉，以免冲突。</strong></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E7%BB%91%E5%AE%9A%E9%AA%A8%E9%AA%BC.png" alt=""></p><p>​    拖入以后并没有直接绑定成功，这时候我们需要通过Anima2D编辑器绑定骨骼，菜单栏Winodws-&gt;Anima2D-&gt;SpriteMesh Editor，点击Bind按钮将自动的计算骨骼的权重。点击Apply即可绑定，也可以通过Weight Editor设置影响程度，在此之前也可以在编辑器上通过鼠标来划分你的蒙皮需求。如果一张图片上有多个骨骼，那么你就要设置每个骨骼在某些三角形上的权重，让骨骼动作时图片动作的更逼真。而个人不需要过于精细，因此本篇没有特定设置蒙皮划分。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E5%BA%94%E7%94%A8%E9%AA%A8%E9%AA%BC.png" alt=""></p><p>​    绑定骨骼以后，可以在视图界面控制骨骼，查看是否绑定成功。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E9%AA%A8%E9%AA%BC%E7%A7%BB%E5%8A%A8%E9%A2%84%E8%A7%88.gif" alt=""></p><h4 id="IK绑定"><a href="#IK绑定" class="headerlink" title="IK绑定"></a>IK绑定</h4><p>​    反向力学系统，一般我们是通过骨骼的动作去控制图片，设置IK并绑定骨骼的话，通过操作IK控件，骨骼也会随着移动。这样我们可以更方便的做一些动画了。（展示图没有绑定武器，所以效果并不明显，但是骨骼效果随着IK的移动而移动很直白）</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/IK%E7%A7%BB%E5%8A%A8%E9%A2%84%E8%A7%88.gif" alt=""></p><p>​    IK动画分两种:IK CCD、IK Limb。<br>​    IK Limb适合肢体骨骼动画。IK CCD适合更长的骨骼。本篇使用Limb，在父物体Player下创建IK，右键2D Object-&gt;IK Limb ，在视图将IK部件移动到合适的位置之后，监视面板绑定骨骼，在这里，我们可以想像IK为关节，我们人体控制关节，骨骼也会随之移动，所以将IK绑定到对应的骨骼就好了。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E5%8F%B3%E6%89%8BIK.png" alt=""></p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/IK%E7%BB%91%E5%AE%9A%E9%AA%A8%E9%AA%BC.png" alt=""></p><h4 id="骨骼动画和换装"><a href="#骨骼动画和换装" class="headerlink" title="骨骼动画和换装"></a>骨骼动画和换装</h4><p>​    利用Animation编辑器，新建anim动画，对骨骼进行操作录制即可，然后播放的时候，通过改变对应SpriteMeshInstance的精灵网格即可。</p><p><img src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/19-2-26/%E6%8D%A2%E8%82%A4%E9%A2%84%E8%A7%88.gif" alt=""></p><p>​    <strong>注意，你要对所有提供换装的精灵网格对它对应骨骼进行单独的绑定！</strong></p><p>​    以下为本篇的换装样例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using Anima2D;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class DebugBone : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    private SpriteMeshInstance body;</span><br><span class="line">    private Object[] clothesMesh;</span><br><span class="line">    int key = 0;</span><br><span class="line">    // Use this for initialization</span><br><span class="line">    void Start () &#123;</span><br><span class="line">        body = GameObject.Find(&quot;身体&quot;).GetComponent&lt;SpriteMeshInstance&gt;();</span><br><span class="line">        clothesMesh = Resources.LoadAll(&quot;SpriteMesh/clothes&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// Update is called once per frame</span><br><span class="line">void Update () &#123;</span><br><span class="line">        if (Input.GetKeyDown(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            key++;</span><br><span class="line">            key = key % 6;</span><br><span class="line">            body.spriteMesh = (SpriteMesh)clothesMesh[key];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考文章和视频"><a href="#参考文章和视频" class="headerlink" title="参考文章和视频"></a>参考文章和视频</h4><p>​    视频： <a href="https://www.bilibili.com/video/av20868780/?spm_id_from=333.788.videocard.0">【游戏美术难于上青天】 系列</a></p><p>​    文章： <a href="https://blog.csdn.net/hibernateplus/article/details/79060311">Anima2D官方中文使用手册（对应Anima2D1.1.4）</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题以及解决方案 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Unity3D引用某些DLL发布之后可能出现的错误</title>
      <link href="/2018/MyIssue-Solution-DLL/"/>
      <url>/2018/MyIssue-Solution-DLL/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h5 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h5><p>在肝专业课设的时候，需要用的EPPLSUE.DLL写表格文件时，以及想用IRONPYTHON调用pyhton脚本时遇到了这些问题，在这里总结一下</p><h4 id="主要问题："><a href="#主要问题：" class="headerlink" title="主要问题："></a>主要问题：</h4><p>1.引用第三方类库之后，无法发布。提示引用的类库不支持。</p><p>2.发布之后，使用到对应第三方类库内容时，发生错误，但是在编辑器里却没错误。</p><h4 id="问题可能原因和解决方法："><a href="#问题可能原因和解决方法：" class="headerlink" title="问题可能原因和解决方法："></a>问题可能原因和解决方法：</h4><h5 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h5><h6 id="可能原因："><a href="#可能原因：" class="headerlink" title="可能原因："></a>可能原因：</h6><p>目前遇到的大部分是都是因为Unity的NET版本和要使用的类库不一致导致的，虽然目前Unity的设置中支持3.5和4.X，但实际上使用那些4.0以上NET支持的类库，大部分就会出现VS编译器里无报错，但Unity编辑器里报错的问题，或者如问题1那样，无法发布。</p><h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>1.尽量使用非4.XNET支持的第三方类库，总能找到课替代的或者低版本(最后我还是没用上iron Python ,选择把python写成web后端了= =)。</p><p>2.在发布页面的Player Setting中设置使用的NET版本，更改Unity为.NET 4.X ，但大部分第三方库依然不支持</p><p>3.老老实实使用.NET3.5，并选择API为.NET2.0而不是它的子集2.0 Subset</p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/18-12-31/57526107.jpg" alt="1546254086424"></p><p><em>据说后面4.X会支持的更好，3.5也会被移除，希望能完全支持这些类库吧。</em></p><h5 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h5><h6 id="可能原因：-1"><a href="#可能原因：-1" class="headerlink" title="可能原因："></a>可能原因：</h6><p>我遇到的是在Unity编辑器里生成表格是可以的,但是发布之后，却失败了，通过异常捕获发现出现不支持IBM347编码，其实是缺少Unity编辑器里自带的一些文件。</p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/18-12-31/93937234.jpg" alt="1546253003361"></p><h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>把Unity\Editor\Data\Mono\lib\mono\unity下的L18N相关的所有.dll赋值到当前项目的Assets文件夹下，保存再发布就可以解决了。</p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/18-12-31/26360741.jpg" alt="1546254852807"></p><p><img src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/18-12-31/87144357.jpg" alt="1546253429555"></p><p>以上大部分分析来源于自己，因此可能不是百分百正确，勿在意。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题以及解决方案 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
