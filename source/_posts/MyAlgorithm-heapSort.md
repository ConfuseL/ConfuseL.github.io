---
title: <常用算法的C++实现>堆排序
date: 2019-4-18 13:22:21
tags: 算法学习
categories: C++
copyright: false
keywords: [C++,排序,算法]
description: 刷笔试题发现自己对堆排序这一块不是很熟悉，赶紧复习下。
---
# 理论

## 堆

### 概述

> 这里的堆指的是数据结构的堆,不是操作系统中内存的堆。
>
> 堆是一种特殊的完全二叉树,特殊之处在于它的每一个点都比自身的子节点的值更大或者更小(区别于搜索树,搜索树是左子节点比右子节点更大或更小)。
>
> 而我们常说的小根堆和大根堆,指的就是上述中每个点都比自身的子节点值更大(最大堆)/更小(最小堆)。

<img width=400 src="http://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%B9%E5%A0%86%E5%9B%BE.png" >

<img width=400 src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%9B%BE.png" >



## 堆排序

> 简单的了解了一下什么是堆之后,我们来了解一下什么是堆排序。

### 堆的存储方式

> 我们知道二叉树的存储方式可以是连续式的数组array,和连接式的树tree。
>
> 不过对于堆排序,通常都是用数组来存储数据,因为我们可以随机访问数据,并且进行快速交换。
>
> 对于下标从0开始的数组中,我们有以下三种性质:
>
> 1. 索引为i的左孩子的索引是 (2*i+1);
> 2. 索引为i的左孩子的索引是 (2*i+2);
> 3. 索引为i的父结点的索引是 ((i-1)/2);

<img width=600 src="https://confusel-images.oss-cn-shenzhen.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%93/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%A0%B9%E5%A0%86.png" >

<center>数组上面的箭头代表右节点,下面的箭头代表左节点</center>

### 堆排序的思想

> 1. 我们先把需要排序的数据进行初始化堆的操作,也就是把它们变成最大堆或者最小堆的形式。
> 2. 每一次我们让根节点值[0]和最后一层的最右节点[n]的值交换,之后最右子节点的值[n]绝对是当前最大或者最小的。因为性质决定根节点的值是最大或者最小。
> 3. 重新对0到n-1进行初始化堆操作。
> 4. 重新2操作,3操作,直到0>n-1。

### 一些可能出现的疑问

1.初始化的时候就是最大/小堆了,为何不能直接输出呢?

> 因为根堆只能保证节点比子节点大或者小,但是不能保证子节点两个的大小顺序。

2.堆排序的使用时机

> 需要找到最大/小的k个元素,如果用插入排序也是需要遍历一整边,时间复杂度更大。而快排在大量数据中仅找到数个最大最小时,所用的空间复杂度更大。

# 代码

## 初始化堆

> 如上方[堆的存储方式](#堆的存储方式)中所述,由数组存储的第三个性质得,根堆中相对最后的节点下标为(n-1)/2,因此我们需要从该节点开始,对每一个结点和它的子节点进行对比和替换。
>
> 把当前点和子节点对比,如果子节点有更大的,那么进行替换。同样的,还要把自身比较孙子节点,进行同样的操作,因为无法保证当前节点的值比子节点小/大多少。

```C++
//最大堆的初始化

//a:数组指针
//_begin:开始下标
//_end:结束下标

void InitHeapMax(vector<int> &a,int _begin,int _end)
{
    //确定开始下标
    int start=_begin;
    //当前最大子节点
    int maxChild;
    //当前节点的值,用来对比
    int value=a[start];
    //我们从当前节点的左子节点开始,即2*i+1
    //如果发现子节点比当前节点还要大/小,那么我们还要对这个子节点以及它的子节点进行一次比较
    for(maxChild=2*start+1;maxChild<_end;start=maxChild,maxChild=2*maxChild+1)
    {
        //如果右子节点的值比左子节点的还大,那么就选右子节点,最小堆则改成大于即可
        if(maxChild<_end-1 && a[maxChild]<a[maxChild+1])
            maxChild++;
        //如果当前节点的值比子节点的所有值都大,那么说明这一个小堆(相对来说)不需要初始化了
        if(value>=a[maxChild])//最小堆则改成小于等于即可
            break;
        //否则,替换
        else
        {
            a[start]=a[maxChild];
            a[maxChild]=value;
        }
    }
}
```

## 排序

> 我们替换第一个节点和最后一层的右边叶子节点,这时最后一层的右边叶子节点就是最大/最小的,然后把这个节点提取出去,将剩下的再初始化一次,继续这个操作,我们就可以依次提取出最大/小的值放在最后。

```C++
//排序

//a:数组指针
//length:需要排序的长度(第几大/小)

void HeapSort(vector<int> &a,vector<int> &b,int length)
{
    int _size=a.size();
    int value;
    //从最后一个非子节点开始初始化
    for(int i=(_size-2)/2;i>=0;i--)
        InitHeapMax(a,i,_size);
    //提取length个增序或者降序的元素
    //for(int i=_size-1;i>=_size-length;i--)
    for(int i=_size-1;i>=0;i--)
    {
        //替换操作，让a[i]为当前极值
        value=a[0];
        a[0]=a[i];
        a[i]=value;
        //将第 _size-i 大/小的元素加入b
       	//b.push_back(value);
        //重新对剩下的排序
        InitHeapMax(a,0,i);
    }
}
```

> 如果初始化堆的操作是最大堆，那么最后这个数组排序的结果为增序，第一个值为最小值。
>
> 如果是最小堆，那么为降序，第一个值是最大值。
>
> 如果是为了取n个从最小值增序、最大值 降序的元素，应该反过来，在排序的过程中提取，会减少不少时间。
>
> 比如第一个值是最小值的增序序列：
>
> ​	使用最小堆的初始化，排序的时候每次都会取到当前最大的值，添加到新数组中即可，取到一定数量就可以结束了，不需要将剩下的排序。
>
> ​	如果使用最大堆的初始化，那么我们需要整个排序一边，才会得到一个从小到大的序列，再取前面的n个元素达到要求。