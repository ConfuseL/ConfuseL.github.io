---
title: <常用算法的C++实现>大整数字符串的加减乘(含负数)
date: 2019-3-20 19:26:51
tags: 算法学习
categories: C++
copyright: false
keywords: [C++,大数,算法]
description: 大整数经常在算法比赛、面试中被考到，在这里详细总结一下通过字符串处理大整数的加法、 减法、 乘法方法。不定期更新除法。
---



## 什么是大数

> 首先计算机的数据类型所能表示的范围都是有限的。

<center>表数据来源于网络</center>

| Type                                        | Size   | 数值范围               |
| ------------------------------------------- | ------ | ---------------------- |
| 无值型void                                  | 0 byte | 无值域                 |
| 布尔型bool                                  | 1 byte | true   false           |
| 有符号短整型short [int] /signed short [int] | 2 byte | -32768~32767           |
| 无符号短整型unsigned short [int]            | 2 byte | 0~65535                |
| 有符号整型int /signed [int]                 | 4 byte | -2147483648~2147483647 |
| 无符号整型unsigned [int]                    | 4 byte | 0~4294967295           |
| 有符号长整型long [int]/signed long [int]    | 4 byte | -2147483648~2147483647 |
| 无符号长整型unsigned long [int]             | 4 byte | 0~4294967295           |
| long long                                   | 8 byte | 0~18446744073709552000 |
| 有符号字符型char/signed char                | 1 byte | -128~127               |
| 无符号字符型unsigned char                   | 1 byte | 0~255                  |
| 宽字符型wchar_t (unsigned short.)           | 2 byte | 0~65535                |
| 单精度浮点型float                           | 4 byte | -3.4E-38~3.4E+38       |
| 双精度浮点型double                          | 8 byte | 1.7E-308~1.7E+308      |
| long double                                 | 8 byte |                        |

> 而比这些数值范围更大、或者是计算之后超出数值范围的数值都可以成为大数，当我们要对位数达到上百位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。



## 正数加法

### 大体思路

> 思想是采用用字符串表示大数。末尾逐位相加，超十进位。
>

#### 计算前

##### 被加数比加数长度短

> 为了方便计算，我们在接受到两个需要相加的正整数时，应该将更长位数的大数置上，短的置下。

#### 计算过程

##### 1.长度不扩充情况

<center>197+13计算</center>

> 面向下面的大数，从末位开始与上置位的每一位对应数值相加。即表中的下标2。

| 当前游标 |      |      |      |
| -------- | ------ | --------- | ---- |
| a     | 1    | 9    | 7    |
| b     |      | 1    | 3    |

> ​	a[2]+b[2] => 7+3=10，发现计算点相加后大于等于10而造成了进位，那么我们应该自身减10，通过为上置位的进位点加1，即9+1=10。至于处理后进位点是否也大于10，我们无需处理，因为我们只需要关心当前位的运算，以及对前一位的影响（即表中的计算点和进位点）。 假设进位点同时也大于10，那么我们在它变成当前点时再进行计算进位就好了。


| 当前游标 |      | 进位点 | 计算点   |
| -------- | ------ | --------- | ---- |
| a     | 1    | 9->10  | 7->10->0 |
| b     |      | 1      | 3        |


> ​	计算点计算，10+1=11，  计算点自身减10，发现需要进位，进位点加1。得到结果210。
>
> 如果进位时，发现进位点不存在，那么意味着相加后，长度发生了变化，这个时候，如果只是相加运算，我们只需要在上置位字符串a前方加一个'1'就好了，**为什么就是'1'呢，因为保证计算点的数值是个数位，无论再怎么大也不会产生进位点进2位的情况。**
>
> **但是，如果需要被大数相乘的函数调用，就不能简单的加1了，因为相乘后可能出现进位点的数值超过1.当然是为了以防万一，但感觉似乎不会产生进位+2以上的情况。。。**

| 当前游标 | 进位点 | 计算点    |      |
| -------- | ------ | --------- | ---- |
| a     | 1->2   | 10->11->1 | 0    |
| b     |        | 1         | 3    |

##### 2.长度扩充情况

<center>99+1计算</center>

| 当前游标 | 进位点 | 计算点 |
| -------- | ------ | ------ |
| a     | 9      | 9      |
| b     |        | 1      |


> a[1]+b[1]=>9+1=10，计算点自身减10，进位点进位，9+1=10，10-10=0

| 当前游标 | 进位点 | 计算点   |
| -------- | ------ | -------- |
| a     | 9->10  | 9->10->0 |
| b     |        | 1        |
|

> 计算点a[0]+b[0]=> 10+0=0,，计算点自身减10，10-10=0,进位点进位，发现超出长度，此时在字符串首加'1'，得到结果100。

| 当前游标 | 进位点 | 计算点 |      |
| -------- | ------ | ------ | ---- |
| a     | 1      | 10->0  | 0    |
| b     |        |        | 1    |

### 代码


```C++
string bigNumAdd(string a,string b)
{
    //把长的字符串上置位，即换成a
    if(a.length()<b.length())
    {
        //交换
        swap(a,b);
    }
    //计算点下标从长度-1开始，取两个i、j变量指向计算点，是为了判断是否结束以及是否超出
    for(int i=a.length()-1,j=b.length()-1;i>=0;i--,j--)
    {
        //j是字符串b的计算点下标，如果依然大于0，说明还在长度内，可以正常计算
        //正常计算的时候利用ascii码性质-'0'获得实际上增加的数值
        //如果超出了就加0，即不变
        a[i]+=(j>=0?b[j]-'0':0);
        //发现计算点大于10，需要进位
        if(a[i]-'0'>=10)
        {           
            
            //如果计算点在a中的位置不是首位，那么进位点正常加上进位数
            if(i)
                a[i-1]+=((a[i]-'0')/10);
            //如果是首位，也就是说，进位点超出了原本的长度，那么我们在a字符串这里加上进位的值就好了
            else
                a=(char)(((a[i]-'0')/10)+'0')+a;
             //自身余10
            a[i]=((a[i]-'0')%10)+'0';
        }
    }
    return a;
}
```

---

## 减法

### 大体思路

> 关键思路和加法差别不大，只需要在对应的操作更改以下就好了，当然，在这之前需要对被减数和减数。

#### 计算前

##### 1.被减数为负数

> 由 -a-b = -(a+b) ，其中a>0 得
>
> 我们将被减数的负号去掉，然后把被减数和减数当作两个正整数相加，得到的结果加上符号即可。
>
> 直接调用上面写的相加函数就好了。

##### 2.被减数是正数

> 这时候我们要考虑被减数和减数他们的长度关系了,如果被减数长度比减数小，那么结果必然是负数。
>
> 由 a-b = --(b-a)，其中a>0 得
>
> 我们将被减数和减数交换，让长的减数成为被减数，然后在结果前加上负号。

#### 计算过程

<center>100-1计算</center>

| 当前游标 |  |借位点  |   计算点   |
| -------- | ------ | ------ | ---- |
| a    | 1      | 0      |   0   |
| b     |        |      |     1 |


> a[2]-b[2]=>0-1=-1,，计算点发现小于0，将自身取绝对值,，借位点借位，借位点减1;

| 当前游标 |  |借位点  |   计算点   |
| -------- | ------ | ------ | ---- |
| a    | 1      | 0->-9     |   0->-9->9   |
| b     |        |      |     1 |


> a[1]-b[1]=>9-0=-9,，计算点发现小于0，将自身取绝对值,，借位点借位，借位点减1;

| 当前游标 | 借位点 | 计算点 |      |
| -------- | ------ | ------ | ---- |
| a    | 1->0      | -9->9    |   9   |
| b     |        |      |     0 |


> 这个时候，发现结果的有效长度应该由3变为2，那么我们将第一个字符串元素去掉即可。

| 当前游标 | 借位点 | 计算点 |
| -------- | ------ | ------ |
| a     | 9      | 9      |
| b     |        | 0      |




### 代码

```C++
string bigNumDel(string a,string b)
{
	//判断结果是不是负数，根据这个来判断是否在字符串前面加'-'
    bool isFushu=false;
    //情况1，被减数是负数，我们将其取正，两数相加，再加上负号
    if(a[0]=='-')
    {
        a.erase(a.begin());
        isFushu=true;
        return '-'+bigNumAdd(a,b);
    }
    //情况2，判断长度，如果被减数短，那么交换，结果必为负数
    if(a.length()<b.length())
    {
        isFushu=true;
        swap(a,b);
    }
    //与加法的遍历方法一致
    for(int i=a.length()-1,j=b.length()-1;i>=0;i--,j--)
    {
    	//与加法的运算一致
        a[i]-=(j>=0?b[j]-'0':0);
        //如果小于0
        if(a[i]<'0')
        {
            //取正数，为什么是加10呢？ 举个例子
            //a[i]='0'-1 即 数值结果为-9  取正应该得9
            //a[i]+=10 ->'0'-1+10= '0'+9 ='9'
             a[i]=a[i]+10;
        	//如果还在有效长度内
            if(i)
            {
                //借位
                a[i-1]--;
            }
            //否则不在有效长度内
            else if(j==0)
            {
                //结果为负数
                isFushu=true;
            }
        }
    }
    //开始去首位0操作
    if(a[0]=='0')
    {
    while(a[0]=='0')
    {
        a.erase(a.begin());
    }
    }
    //判断是否负数来加符号
        return isFushu?'-'+a:a;
}
```

---

## 乘法

### 大体思路

> 相信大部分人首算乘法的时候，都习惯从末尾开始乘，然后进位，但是要仔细考虑，进位之后，得到的数据应该缓存起来，最后相加而不是直接在原字符串上改变进位点的数值。也就是说 567 * 3 =21+180+1500 . 
>
> 上面这种末尾相乘方法其实效率并不高，每个数字之间相乘的结果都要缓存一次，而其实我们只需要首位相乘就可以解决多次缓存的问题了，即从a*b 中，对a的首位开始进行乘法运算，因为从前往后运算，计算点影响的值只会是前一位进位点，后面的都不会被影响到，所以只需要新建一个临时字符串c赋值a的元素，然后直接在c上更改就好。 也就是 567 * 3 =1701

### 计算过程

#### 计算前

>  乘法运算也需要和前两种运算一样，要求长度更长的置上方。

##### 1.统计两个乘数是否为负数

> 负负得正，正负得负，将负号统计并且移除，在最后结果上根据情况加负号。

##### 2.非特殊情况

> 新建一个字符串res，用于存储结果，然后在b的每位数字开始相乘时，新建一个临时字符串，存储这个数值对a乘法后的结果，然后加入res中。

| 当前游标 |      |      |      |
| -------- | ---- | ---- | ---- |
| res      |      |      |      |
| a        | 4    | 5    | 7    |
| b        | 3    | 4    |      |
| temp     | 4    | 5    | 6    |

> 为了方便演示，我们从b的首位开始逐个对照a的首位开始算，3*4=12，先把2存储在temp的对应位置中。
>
> 在代码中，无论从b的首位还是末位开始遍历，只要从a的首位开始计算就行，只要加'0'的次数正确，结果不变。

| 当前游标 | 进位点 | 计算点 |      |      |
| -------- | ------ | ------ | ---- | ---- |
| a        |        | 4      | 5    | 6    |
| b        |        | 3      | 4    |      |
| temp     |        | 4->2   | 5    | 6    |

> 然后12是大于10的，这时候我们需要在temp字符串前加入需要进位的数值 ，即 ‘1’。

| 当前游标 |      | 进位点 | 计算点 |      |
| -------- | ---- | ------ | ---- | ---- |
| a        |      | 4      | 5    | 7   |
| b        |      | 3      | 4    |      |
| temp     | 1    | 2      | 5    | 6    |

> 接着对a的下一位进行运算，即3*5=15，对应计算点的temp数值改成5，进位点进位1。

| 当前游标 |      | 进位点 | 计算点 |      |
| -------- | ---- | ------ | ------ | ---- |
| a        |      | 4      | 5      | 7    |
| b        |      | 3      | 4      |      |
| temp     | 1    | 2->3   | 5->5   | 6    |

> 同理，对a的下一位继续运算，即3*7=21，对应计算点的temp数值改成1，进位点进位2。

| 当前游标 |      |      | 进位点 | 计算点 |
| -------- | ---- | ---- | ------ | ---- |
| a        |      | 4    | 5      | 7    |
| b        |      | 3    | 4      |      |
| temp     | 1    | 3 | 5->7 | 6->1 |

> 此时temp字符串的值应为'1' '3' '7' '1‘，重点来了，我们应该记住在b字符串运算位距离末位的值，随后根据这个值，对temp末位逐个加'0'
>
> 因为例子中b长度为2，当前从首位开始算， 所以相差1位，那么在temp末尾加1个‘0’
>
> temp="13710",把他加入res,用上述的大数相加运算。

> 同理把4和457进行一次运算，得到的新temp也加入到res中
>
> 最后根据前面统计的负号个数，对结果进行加负号处理。

##### 3.特殊情况

> 如果按照首位逐个相乘，如果遇到如69*9这样，即第一次运算  60 * 9=540  , 随后运算 9 * 9 =81 ,发现进位点4+8 超过10 这个时候怎么处理呢。
>
> 很简单，无视就好，它会在被调用大数相加运算的时候，自动向前进位的。
>
> 此时temp='5' '12' '1'。
>
> 我们bigNumAdd(res,temp)。
>
> 在内循环中，因为12>10 ，会把1加到5身上。结果为621

### 代码

```C++
string bigNumMul(string a,string b)
{
    //统计负数个数
    int fushu=0;
    string resStr;
    if(a[0]=='-')
    {
        fushu++;
        a.erase(a.begin());
    }
    if(b[0]=='-')
    {
        fushu++;
        b.erase(b.begin());
    }
    if(a.length()<b.length())
    {
        swap(a,b);
    }
    //面向b的末尾开始
    for(int i=b.length()-1;i>=0;i--)
    {
        //新建临时字符串
        string tempStr;
        //复制严肃，这里其实只要长度相等就可以了，不需要元素一致
        tempStr.assign(a);
        //计算当前b的计算位距离末尾的长度，决定加0次数
        int zeroB=b.length()-i-1;
        //从a的首位开始，因为这里复制了a的元素，直接从temp上索引
        //如果上面的temp只复制了长度，那么就要从a本身索引
        for(int j=0;j<tempStr.length();j++)
        {
            //相乘
            int res=(tempStr[j]-'0')*(b[i]-'0');
            //自身更正
            tempStr[j]=res%10+'0';
            //相乘结果大于10
            if(res>=10)
                {
                //计算点在temp/a的首位，也就说进位点会超出范围
                    if(j==0)
                    {
                        //在temp前加上进位的值的ascii码
                        tempStr=(char)((res/10)%10+'0')+tempStr;
                        //长度加1，我们的j也要相对后移
                        ++j;
                    }
                    else
                    {
                        //否则正常进位
                        tempStr[j-1]+=(res/10)%10;
                    }
                }
        }
        //加'0'操作
        for(int k=0;k<zeroB;k++)
            tempStr+='0';
        //与res相加 如果出现了特殊情况，会在其中被进位修正。
        resStr=bigNumAdd(resStr,tempStr);
    }
    //判断负数情况，加负号
    return fushu==1 ? '-'+resStr:resStr;
}
```

## 总结

> 1. 加法减法从被加/被减末尾开始算。
> 2. 减法/乘法需要考虑负数情况。
> 3. 乘法从被乘数的首位开始算。
> 4. 加法运算要注意进位操作，减法要记得减0操作，乘法要加0操作。