---
title: <学习记录>同步、通信与死锁
date: 2019-4-4 16:39:43
tags: 知识总结
categories: 操作系统
copyright: true
keywords: [操作系统,进程通信,死锁]
description: 先总结进程同步、互斥、通信和死锁的知识点，今后有时间再补上一些典型问题的算法实现。
---
## 进程互斥与同步

### 进程互斥

> 即进程需要互斥使用共享资源。进程具有独立性和异步性，而计算机中的资源是有限的，如果让多个进程使用同一个资源，很容易发生资源当前状态不确定的情况。
>
> 或者说，如果是多个单进程/线程顺序对资源进行访问，那么这个资源的情况我们是可以确定的，即可复现。
>
> 但是多进程/线程多同个资源进行交叉访问，如果处理不当，我们无法确定资源的情况，即不可复现。
>
> 为了避免这种问题，需要实现进程互斥。

### 进程同步

> 为了完成共同任务的进程，并发时需安排好先后执行顺序或给予某个条件来协调活动。
>
> 与互斥的区别是，同步是基于互斥的，只不过同步需要规定需要访问资源的进程/线程的访问顺序，而互斥并不关心访问顺序，只关心资源是不是只被一个进程/线程访问。
>
> 所以同步是一种更为复杂的互斥，而互斥是一种特殊的同步。

### 临界资源

> 一次只能供一个进程访问的资源。

### 解决进程同步问题

#### 临界区

> 用来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。

#### 互斥量

> 互斥量可以认为是一种标记或者是一把锁，它只有两种状态，可用和不可用(锁住和开锁)。每一个访问这个资源的进程/线程都要对这个资源的互斥量进行判断。
>
> 如果是不可用的，那么我们无法读取资源进行操作。
>
> 如果可用，我们的这个进程/线程将可以获得资源的使用权利，同时将资源锁住，即互斥量变为不可用，将其他想要访问资源的进程/线程隔绝开。当使用完毕时，再将互斥量解锁。

#### 信号量

> 可以理解为复杂的互斥量。
>
> 互斥量可以用0和1代表两种状态，而信号量则是0~n来代表可用和不可用。它更像是一种资源计数器，能允许多个进程/线程对资源进行访问。
>
> 但是在信号量里，很容易产生疑问，信号量允许多个进程/线程访问资源不是违背了进程互斥么？
>
> 在百度了文章后，将原因简单概括一下：
>
> 信号量控制的资源，不一定是要被锁住的资源，而是需要规定流程去使用的资源。
>
> 比如用信号量去控制一个停车场(共享资源)里的多个停车位，每个车子(进程/线程)可以占用一个停车位，如果还有停车位，即信号量大于0，车子可以进去，否则等待。
>
> 车子进去以后停车，占用了一个停车位，所以信号量减1。车子出停车场时，停车位会空掉，所以信号量加1。

#### PV操作

> PV操作就是对信号量(包含互斥量)的操作。
>
> P即通过的意思，会对信号量进行减操作。
>
> V即释放的意思，会对信号量进行加操作。

## 进程通信方式(仅做了解)

### 管道

> 管道分为匿名管道和有名管道。
>
> 管道是**半双工的**，数据只能向一个方向流动；**需要双方通信时，需要建立起两个管道**。
>
> 管道是单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

#### 匿名管道(pipe)

> 因为匿名，只有fork出来的子进程才会拥有它的控制权。
>
> 因此匿名管道只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。

#### 有名管道(fifo)

> 因为有名(标识)，所有进程可以通过名字(标识)去访问这个管道。
>
> 因此有名管道可用于任意进程之间（非亲缘关系的进程）。

### 消息队列

> 消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。
>
> 一个队列和有名管道一样拥有自己的标识符。
>
> 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
>
> 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。

### 共享内存+信号量

> 就是上文所述，将资源位于共享的内存片段中成为临界资源，通过信号量的方式实现进程/线程同步，让他们根据临界资源来通信。

### 信号(signal)

> 信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。
>
> 比如在命令行界面，对任意前台进程执行ctrl+c操作，会导致进程终止。
>
> 这个就是利用了信号机制。linux对信号提供了默认操作，我们也可以在代码中通过绑定自己写的方法来替代linux默认的操作。

## 死锁

### 概述

> 如果一个进程集合中的每一个进程都在等待只能由此集合中的其他进程才能引发的时间，而无限期陷入僵持的局面成为死锁。

### 产生的必要条件

> 1. 互斥条件。
> 2. 占有和等待条件：当进程请求不到资源时进行等待，但不释放自己以占有的资源。
> 3. 不剥夺(抢占)条件：拥有资源的进程只能自愿释放资源而不是被其他进程剥夺。
> 4. 循环等待条件：每一个进程都在等待下一个进程持有的资源，而下一个进程也在等待其他进程持有的资源。
>
> 其中，条件4是条件123的产生结果。
>
> 只要破坏掉任意一个条件就可以解决死锁问题。

### 条件破坏

> 条件一无法破坏。

#### 条件二

> 静态分配资源：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。
> 优点：简单易实施且安全。
> 缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。从而使进程经常发生饥饿现象。
>
> 解决方案：进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。

#### 条件三

> 一旦进程无法获取资源，那么久释放它以获得的资源，以解决其他进程无法获得资源的问题。
>
> 优点：可以让其他进程得以继续。
>
> 缺点：释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。

#### 条件四

> 采用层次分配策略，让系统把资源分层次，一个进程只可以持有某层次的资源，只可以申请比该层次更高一层的资源。
>
> 这样只有一个方向的流动，不会产生最高层和最底层的互动。(参考链表和循环链表)。
>
> 优点：不会产生循环等待。
>
> 缺点：资源利用率大大降低。

### 死锁避免

> 只介绍银行家算法。

#### 银行家算法

> 假设当前系统拥有部分可用资源。
>
> 我们需要提前知道有那些进程需要判断，并且知道进程当前持有的资源以及所需资源。
>
> 然后通过计算安全序列，只要存在任意一种安全序列，就可以认为这些进程不会产生死锁。

##### 样例

> 有一下5个进程。系统中有ABC三种资源。

| 进程 | 已有资源 | 正常工作时所需资源 |
| ---- | -------- | ------------------ |
|      | A-B-C    | A-B-C              |
| P0   | 0-1-0    | 7-5-3              |
| P1   | 2-0-0    | 3-2-2              |
| P2   | 3-0-2    | 9-0-2              |
| P3   | 2-1-1    | 2-2-2              |
| P4   | 0-0-2    | 4-3-3              |

|              | A    | B    | C    |
| ------------ | ---- | ---- | ---- |
| 系统可用资源 | 3    | 3    | 2    |



> **第一步，我们先遍历所有进程的申请资源**

| 进程 | 申请资源=正常工作时所需资源-持有资源 |
| ---- | ------------------------------------ |
|      | A-B-C                                |
| P0   | 7-4-2                                |
| P1   | 1-2-2                                |
| P2   | 6-0-0                                |
| P3   | 0-1-1                                |
| P4   | 4-3-1                                |

> 当前系统可用的资源为3-3-2 ，从上表可以得知，满足条件的有P1和P3，假设我们让P1先进行。
>
> 此时P1拿到了资源，它拥有的资源为3-2-2，当前系统还剩资源为2-1-0。
>
> P1执行完毕，释放资源，此时系统则有5-3-2的资源。
>
> 我们再看上表，满足条件的有P3。我们让P3持有资源，执行完毕在释放。
>
> 释放后系统资源为7-4-3，我们再对照上表进行判断，发现P2、P4都可以运行，我们随意选择一项，假设P4。
>
> P4释放资源后，系统可用资源为7-4-5。再让P2持资源和释放，系统资源为10-4-7。
>
> 此时只剩下进程P0，发现申请的资源都小于系统可用资源，所以最后一个进程也可以运行。
>
> 得到安全序列1-3-4-2-0
>
> 因为存在安全序列，所以这些进程不会产生死锁。

### 死锁恢复

> 1. 解锁所有进程的执行，然后重启操作系统。
> 2. 撤销死锁的所有进程。
> 3. 逐个撤销死锁的进程，释放资源直到不死锁。
> 4. 剥夺死锁中某进程的资源，但是不撤销该进程，直到死锁解除再归还。
> 5. SL大发，死锁发生时让进程回退直保存点。