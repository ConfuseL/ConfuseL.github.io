---
title: <学习记录>线程、 协程、 进程的简单理解
date: 2019-3-28 15:45:51
tags: 知识总结
categories: 操作系统
copyright: true
keywords: [进程,协程,线程]
description: 线程、 协程、 进程的理论总结，简单介绍他们的作用以及区别。
---


## 理论

> ​	在了解协程之前，我们先了解一下操作系统中的堆、 栈。
>
> ​	再谈谈进程和线程。其中暂不介绍上下文。

### 栈

> ​	在数据结构中，栈具有先进后出的特性，也就是说，将1,2,3按顺序添加到栈结构中，再依次取出数据时，数据顺序是这样的：3,2,1。
>
> ​	而在操作系统中，它是内存分配的一种方式，即动态分配内存。它由编译器自动分配和释放，主要用于存放函数的参数值，局部变量等等，而它的性质也遵循先进后出。
>
> ​	栈存放在一级缓存中，在被调用结束后会被立即释放。

------

### 堆

> ​	在数据结构中，是一种树形结构，即完全二叉树，它的特性是某节点的值都不会比父节点的值大或者小，所以常常用来实现优先队列。
>
> ​	而在操作系统中，它和栈一样是动态分配内存，不同的是，它由我们分配和释放，如果我们没有主动释放，会在程序结束时被回收。
>
> ​	**重点来了，它与数据结构的堆并不具有同种特性，它的性质更接近于链表。**
>
> ​	堆存放在二级缓存中，调用完毕并不会被系统直接回收。

------

### 进程

> ​	进程即可并发执行的程序在某个数据集合上的一切计算活动。
>
> ​	可以简单的认为，在电脑上打开了一个软件，运行了一款游戏，就是开启了一个进程。

#### 进程性质

> 1. 有生命周期
> 2. **拥有系统资源的基本单位**
> 3. 进程之间可以对等的，也可以是父子结构。

#### 进程属性

> 1. 动态性：拥有生命周期
> 2. 共享性：多个进程可以执行同个程序
> 3. 独立性：每个进程都是OS中的一个操作实体，拥有自己的独立栈、 堆
> 4. 制约性：共享资源的制约关系
> 5. 并发性：单处理器可并发执行，多处理器可并行执行

#### 进程结构

> 1. 控制块：英文缩写PCB，每一个进程捆绑一个，用来存储进程的标识、 现场、 控制信息 ，同进程创建、 回收。
> 2. 程序块：即进程执行的程序
> 3. 核心栈： 进程在内核模式下运行时使用的堆栈， 中断或系统过程使用；
> 4. 数据块：进程处理的数据空间， 包括数据、 处理函数的用户栈（用户态）和可修改的程序；

#### 进程的创建过程

> ​	在进程列表中增加一项，然后从PCB池里申请一个空闲的PCB然后为新进程分配唯一的标识符，同时分配地址空间等等各种资源。随后初始化PCB，如标识符、 进程优先级等，然后设置就绪态，加入就绪队列。

#### 进程的撤销过程

> ​	可分为正常和非正常撤销，也就是类似进程运行结束、 执行非法命令、 被中断等
>
> ​	根据被撤销进程的标识符从相应的队列中查找并移除，并把资源归还给上一级（父进程或者是OS），如果这个进程拥有子进程，那么先对子进程同样的操作，最后将PCB回收。

#### 进程拥有的进程状态

##### 三态

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1554482916&di=e7971789a22228da570fc73db668aee5&imgtype=jpg&er=1&src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F14257988-35ecc363f4919af0.png)

##### 七态

![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=839532373,3126445145&fm=26&gp=0.jpg)



### 线程

> ​	上面介绍了进程，可以看出进程的功能十分强大，那么为什么还需要线程呢？
>
> ​	首先需要明确一个概念，Linux系统中甚至没有真正的线程。不过，可以认为Linux是系统的线程是内核线程，所以调度是基于线程的。

#### 引入线程的原因

> 1. 进程切换开销大
> 2. 进程通信代价大
> 3. 进程间的并发性力度较粗，并发度不高，并发的本质是在时间上重叠的多个逻辑流，也就是说同时运行的多个逻辑流。并发编程要解决的一个很重要的问题就是对资源的并发访问的问题，也就是共享资源的问题。而两个进程恰恰很难在逻辑上表示共享资源。
> 4. 不适应并行计算和分部并行的计算需求
> 5. 不适合C/S计算的要求

#### 线程性质

> 1. 在引入线程这个概念之后，线程成为了CPU**调度和分配的最小单位**。
> 2. 线程是进程的组成部分，是能够并发的实体。
> 3. 线程**不是拥有资源**的单位，所以挂起状态对于线程没有任何意义。因此挂起操作不是线程级而是进程级状态。
> 4. 线程可以创建另一个线程。但都是对等结构不是父子结构。

#### 线程结构

> 1. 线程控制块：英文缩写TCB，与进程的控制块相似，但是由进程操控。
> 2. 线程用户栈
> 3. 线程核心栈

------

#### 线程与进程的关系

#### ![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9832170bbc315c60579863bdecd8a076/b8014a90f603738dd1bbb73cb31bb051f819ec3f.jpg)

> ​	可以理解为线程是进程的一部分。一个线程只能属于一个进程，而一个进程可以有多个线程。线程是进程的一部分，所以线程有的时候被称为是轻权进程或者[轻量级进程](https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B)。
>
> ​	线程可以分为两部分：**资源集合**和**线程集合**。进程要支持线程的运行，并为线程提供虚拟地址空间和各种资源。

#### 线程与进程的区别

> 1. 进程之间的通信，只能通过管道、 信号的方式通信。而线程使用的资源来源于进程的共享，通信起来并没有进程这么麻烦。
> 2. 一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。
> 3. 进程有自己的不共享堆，不共享栈，线程有自己的不共享栈和共享堆。
> 4. 进程是拥有资源的单位，线程是调度和分配的最小单位。

#### 多线程容易引发的问题

##### 线程安全

> ​	我们都知道线程共享使用的是来自进程的资源，那么在多个线程同时访问资源时，同时对某个资源进行操作，就会发生一些错误。
>
> ​	比如买票，就剩最后一张票了，两个线程同时买票，都发现了最后一张，都买掉了它，那么这个时候，系统还剩-1张票。
>
> ​	显然这不是我们想看到的情况。
>
> ​	为了解决这种问题，出现了互斥锁、信号量的等等解决方案。因为介绍这些内容篇幅过长可以自行百度。

##### 死锁

> ​	死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），经典的问题如[哲学家就餐问题](<https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin>),因为死锁问题可以另开篇幅，在这里同样不再描述。

### 协程

#### 引入协程的原因

> ​	线程其实并没有提高CPU的运行速率，而只是提高了运行效率，同时会很吃CPU的性能。
>
> 1. 涉及到同步、异步、互斥锁。
>
> 2. 涉及到线程阻塞状态和可运行状态之间的切换。
>
> 3. 涉及到线程上下文的切换。
>
>    可见一个进程内多个线程运作的时候进行以上操作会非常消耗性能。

![](http://5b0988e595225.cdn.sohucs.com/images/20180622/6765e36cc4604fba897976638af03524.jpeg)

#### 协程性质

> 1. 如同操作系统拥有多个进程，进程拥有多个线程一样，线程拥有多个协程。
> 2. 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。
> 3. 协程是在一个线程中，每个协程对CPU进行分时处理。
> 4. 协程即与多线程情况下的线程比较类似：有自己的堆栈，自己的局部变量，有自己的指令指针，但与其它协同程序共享全局变量等很多信息。
> 5. 协程造成阻塞是，会影响整个线程。

#### 线程和协程的区别

> 1. 协程 :同一时间只能执行某个协程。开辟多个协程开销不大。协程适合对某任务进行分时处理。
> 2. 线程: 同一时间可以同时执行多个线程。开辟多条线程开销很大。线程适合多任务同时处理。
> 3. 线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。
> 4. 协程需要保证是非堵塞的且没有相互依赖，协程基本上不能同步通讯，多采用一步的消息通讯，效率比较高。

### Unity3D中的线程、协程

#### 创建的线程无法调用UnityAPI

> ​	Unity是单线程设计的游戏引擎(很多都是，因为游戏大部分都是主循环结构)，它有一个负责主循环的主线程。基于MonoBehavior，因此游戏脚本拥有严格的生命周期。
>
> ​	尝试在Unity中创建线程后，很容易发现，在我们创建的线程运行函数中，无法调用Unity引擎提供的各种API，以及它提供的特殊对象。例如组件，但是常用的如int、struct类型是允许使用的。

#### 原因

> ​	为了保证逻辑和画面按照严格的顺序更新。

#### 无法使用UnityAPI，那么创建线程还有什么用

> ​	如果不是画面更新，也不是常规的逻辑更新（指包括AI、物理碰撞、角色控制这些），而是一些其他后台任务，比如网络传输：
>
> ​	正如TCP或者UDP协议的传输，在TCP中，我们需要确保长链接，需要一直接受发送端发送过来的数据，如果我们把它写在主线程下，会发生什么。我们在游戏拥有聊天服务这个功能，假设使用阻塞式TCP协议，那么我们打开与某玩家的聊天窗口，向其发送数据，然后就没有然后了，因为我们必须等待对方的回复。
>
> ​	而我们使用多线程就可以解决了。新增线程专门用于网络通讯，而主线程根据接受到的信息负责更新逻辑以及画面。

#### 可我想对我的游戏进行调用UnityAPI的并发或者异步操作，怎么办——使用协程

> ​	协程，即协作式程序，其思想是一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CUP进行分时，协程可以访问和使用unity的所有方法和component.
>
> ​	协程一般都是在一次Update之后被使用，协程在每次使用后会被挂起，等待下一次的使用。那么它的作用是什么呢。
>
> ​	比如，我们需要异步加载场景上的所有预置体，比如制作了一款关卡场景中物体比较多的游戏，我们需要在关卡开始前加载所有预置体(为了更能提现协程的作用，在这里先不考虑缓存池优化)，假设预置体真的很多，把加载都放在Start中执行，那么玩家可能会卡顿一段时间才能进入到游戏循环中，而我们使用协程，协程每次加载部分预置体，在Start中开启协程，那么协程会被执行一次，这个时候加载了部分预置体，再进行一次Update循环后，协程又一次被调用，又加载了部分预置体，而一秒中调用的Update次数足够多，所以并不会产生卡顿的感觉。

### 总结

> 进程是操作系统拥有资源的单位，一个操作系统可拥有多个进程，拥有独立的栈和堆。通常对应一个运行的程序。
>
> 线程是CPU调度和分配的最小单位，一个进程可以拥有多个线程。拥有独立的栈和共享的堆(来自进程)。通常对应一个程序中的主要功能和并发功能。
>
> 协程可以说是用户态的轻量级线程，一个线程可以拥有多个协程。拥有用户栈和共享的堆(来自线程)。通常应用于异步中。

### 参考文献

[游戏引擎Unity中的单线程与多线程]: http://www.360doc.com/content/17/0604/18/40005136_659856903.shtml
[unity 协程 详细说明]: https://blog.csdn.net/fengya1/article/details/79386936
[多线程的同步锁和死锁]: https://www.cnblogs.com/lyjblogs/p/7888646.html
[几张图看懂进程、线程和锁]: https://blog.csdn.net/afei__/article/details/80468265
[漫画：什么是协程？]: &lt;http://www.sohu.com/a/237171690_465221&gt;



