<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图论]]></title>
    <url>%2F2019%2FMyAlgorithm-edge%2F</url>
    <content type="text"><![CDATA[最短路径问题 从文字上理解，就是求哪到哪儿的路径最短，题目会给多个点，点与点之间是否相连，权值是多少。一般来说需要我们计算一个节点到其他所有节点的最短路径。然后输出源点到某点的最短路径。 Dijkstra算法 能解决的问题：无负边的单源最短路 在带权图 G = (V, E) 中，每条边都有一个权值w[i]。路径的长度为路径上所有边权之和。 求源点 s到图中其余各顶点的最短路径。 概述 解决单源最短路径问题常用 Dijkstra 算法，用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算法的主要特点是以起点为中心，逐层向外扩展，每次都会取一个最近点继续扩展，直到取完所有点为止。 算法流程 我们定义带权图 G所有顶点的集合为V，接着我们再定义已确定从源点出发的最短路径的顶点集合为 U，初始集合 U 为空，记从源点 s 出发到每个顶点 vv 的距离为 dist_v，初始 dist_s=0。接着执行以下操作： 从 V-U 中找出一个距离源点最近的顶点 v，将 v 加入集合 U，并用 dist_v 和顶点 v 连出的边来更新和 v 相邻的、不在集合 U 中的顶点的 dist； 重复第一步操作，直到 V=U或找不出一个从 s出发有路径到达的顶点，算法结束。如果最后V≠U，说明有顶点无法从源点到达；否则每个 dist_i表示从 出发到顶点i 的最短距离。 算法优化 Dijkstra最简单的版本就是使用一个数组当作上述的集合U，每一次遍历，找出目前最新且最短的边权，以它为新的源点，同时更新与它相关的最短路径的值。 我们可以使用一个优先队列去代替数组承担集合U，这样可以保证每次取出队列头部的边权当前最小的。省去了遍历和对比的时间。 例子 如上图 ，源点为左上角，黄色点内的数字代表源点到他们的距离。初始值都是无穷大99。 先push源点，然后开始探索图，取得队列头，即源点，开始遍历，源点到右边的点边权为2，比之前的99要小，那么更新距离，同时把这个点push进去，同理对其他连接的两个点进行操作。更新后的最新距离分别为9和6，当前优先队列的值为：2,6,9。这个时候发现没有连接其他点了，结束当前循环。此时的图为第一行第二列。 因为是优先队列，我们取得的头部是源点距离为2的点，也是除了源点到自身以外当前最短的点。同样进行上述操作。 因为每一次循环，已经确定过最短路径的点不会再被push到优先队列中，所以在优先队列为空的时候，我们已经获得了源点到各点的最短距离。 如果发现到某点的最短距离为99(无穷大)，说明无法到达这个点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int maxn=1e4+1;//存储from点,to点,和权值//pair是std中的一种数据结构，存储两个数据，分别用first、second取得。//可以用结构体代替vector&lt;pair&lt;int,int&gt; &gt;Edge[maxn];//存储路径长度。int s[maxn];//根据节点数初始化。void init(int n)&#123; for(int i=0;i&lt;=n;i++) &#123; Edge[i].clear(); //因为求的是最小，所以初始值应该是无穷大，方便对比 s[i]=1e9; &#125;&#125;void dijkstraByQueue()&#123; //点数目，边数目，源点 int n,e,sourse; cin&gt;&gt;n&gt;&gt;e&gt;&gt;sourse; //初始化 init(n); //from,to,worth int x,y,w; for(int i=0;i&lt;e;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; //x-&gt;y=w Edge[x].push_back(make_pair(y,w)); //如果是无向图，那么反过来添加一次。 //Edge[y].push_back(make_pair(x,w)); &#125; //源点到自身的路径肯定为0 s[sourse]=0; //优先队列 ，存储边权，目标点(to)，优先队列会默认按照边权从大到小排序 priority_queue&lt;pair&lt;int,int&gt;&gt; Q; //把源点到自身的距离(0)，以及自己的节点push到优先队列中 Q.push(make_pair(0,sourse)); //开始探索地图 while(!Q.empty()) &#123; //获取当前相对最新点，然后从优先队列中弹出 int cur=Q.top().second; Q.pop(); //遍历当前点所连接的点(to)，判断他们之间的边权 for(int i=0;i&lt;Edge[cur].size();i++) &#123; //取得点 int target=Edge[cur][i].first; //判断当前记录的 源点到目标点的距离s[target] 和当前最新点与目标点的距离Edge[cur][i].second+s[cur]长度关系 if(s[target]&gt;Edge[cur][i].second+s[cur]) &#123; //如果发现当前记录并不是最短距离，那么就更新它 s[target]=Edge[cur][i].second+s[cur]; //把到达这个点的边权和点下标push到优先队列中，因为优先队列默认是按大到小排序，我们的需求是小到大，所以推入-1*边权就可以了。 //如果使用自定义的结构体，可以另写一个cmp。 Q.push(make_pair(-1*s[target],target)); &#125; &#125; &#125; //当上面的队列为空的时候，说明我们以及探索完整个图了，此时我们的s[]储存的就是源点到其他点的最短距离了。 for(int i=1;i&lt;=n;i++) cout&lt;&lt;s[i]&lt;&lt;endl;&#125; SPFA算法 能解决的问题：有负边的单源最短路 概述 其实 SPFA 本质是 Bellman-ford 算法的队列优化。由国内段凡丁教授发表，大家可以自行百度查阅相关信息。 如果没有负权边的情况下还是使用堆/优先队列优化的dijkstra吧。 算法流程 在 SPFA 算法中，使用 d_i表示从源点到顶点 i 的最短路，额外用一个队列来保存即将进行拓展的顶点列表，并用 inq_i 来标识顶点 i是不是在队列中。 初始队列中仅包含源点，且源点 s 的 d_s=0。 取出队列头顶点 u，扫描从顶点 u 出发的每条边，设每条边的另一端为 v，边 &lt;u,v&gt; 权值为 w，若 d_u+w&lt;d_v，则 将 d_v修改为 d_u+w 若 vv不在队列中，则将 v入队 重复步骤 2 直到队列为空最终 dd数组就是从源点出发到每个顶点的最短路距离。如果一个顶点从没有入队，则说明没有从源点到该顶点的路径。 负环判断 在进行 SPFA 时，用一个数组 cnt_i 来标记每个顶点入队次数。如果一个顶点入队次数 cnt_i大于顶点总数 n，则表示该图中包含负环。 代码 在这里贴下最简单的spfa实现，至于lll和slf优化在日后了解后再更新。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273vector&lt;pair&lt;int,int&gt; &gt;Edge[maxn];//多出的inQueue是为了判断某点是否在队列中。int s[maxn],inQueue[maxn];//初始化void init(int n)&#123; for(int i=0;i&lt;=n;i++) &#123; Edge[i].clear(); s[i]=1e9; inQueue[i]=0; &#125;&#125;void spfa()&#123; int n,e,source; int x,y,w; //记录被推入队列的次数，如果超过点数目n，说明有负环。 int pushCount[maxn]; cin&gt;&gt;n&gt;&gt;e&gt;&gt;source; init(n); for(int i=0;i&lt;e;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; Edge[x].push_back(make_pair(y,w)); //初始化推入次数为0 pushCount[x]=0; &#125; //在这里使用的是队列不是优先队列，lll和slf优化可以使用deque queue&lt;int&gt; Q; //到自身距离为0 s[source]=0; //推入次数更新 pushCount[source]=1; //推入 Q.push(source); //开始探索 while(!Q.empty()) &#123; //取队头 int cur=Q.front(); Q.pop(); //此时队头对应的点已经不在队列里了。 inQueue[cur]=0; //和上面的dijkstra算法一样进行松弛处理 for(int i=0;i&lt;Edge[cur].size();i++) &#123; int target=Edge[cur][i].first; if(s[target]&gt;Edge[cur][i].second+s[cur]) &#123; //更新最短路径 s[target]=Edge[cur][i].second+s[cur]; //如果这个点依然在队列里，那么就不需要推入 if(inQueue[target]) continue; //如果推入此时大于点的数目n，说明有负环 if(++pushCount[target]&gt;=n) &#123; cout&lt;&lt;"-1"&lt;&lt;endl; return; &#125; //再此将它推入 inQueue[target]=1; Q.push(target); &#125; &#125; &#125; //输出最短距离 for(int i=0;i&lt;n;i++) cout&lt;&lt;s[i]&lt;&lt;endl;&#125; Floyd算法 能解决的问题：多源点最短路径 时间复杂度很高，毕竟要求出所有点到其他点的最短距离。 概述 Floyd 算法是一种利用动态规划的思想、计算给定的带权图中任意两个顶点之间最短路径的算法。相比于重复执行多次单源最短路算法，Floyd 具有高效、代码简短的优势，在解决图论最短路题目时比较常用。 算法流程 Floyd 的基本思想是：对于一个顶点个数为 n 的有向图，并有一个n×n 的E[][]，其中矩阵横列下标相等，代表自身到自身，对应的值应为0对于其余任意两个顶点 i,j若它们之间存在有向边，则以此边权上的权值作为E[i][j]=w；若两个顶点i,j 之间不存在有向边，则E[i][j]=INF。对于循环阶段 ，尝试增加一个中继点 k，如果通过中间顶点使得最短路径变短了，就更新结果。累加 k，重复遍历所有可能成为中继的点下标，直到 k=n。算法结束后，矩阵 E[][]中的元素就代表着图中任意两点之间的最短路径长度。 代码1234567891011121314151617181920212223242526272829303132333435363738394041const int inf = 0x3f3f3f3f;const int maxn=1e4+1;//用矩阵存储距离int g[maxn][maxn]; // 初始化void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (i == j) &#123; //到自身的距离为0 g[i][j] = 0; &#125; else &#123; //初始化为无穷大 g[i][j] = inf; &#125; &#125; &#125;&#125;void floyd() &#123; int n,e; int x,y,w; cin&gt;&gt;n&gt;&gt;e; for(int i=0;i&lt;e;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; //x到y的边权为w g[x][y]=w; &#125; //三重循环，分别代表中继点k、当前点i(from)，目标点j(to) for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; //如果i到k+k到j的距离比原来i直接到j的距离还短，就更新 if (g[i][k] + g[k][j] &lt; g[i][j]) &#123; g[i][j] = g[i][k] + g[k][j]; &#125; &#125; &#125; &#125;&#125; 最小生成树问题 一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 一般常见题目是求道路如何建设，使得各个位置能够互通，并且花费最少。 prim算法概述 Prim算法求最小生成树的时候和边数无关，和顶点数有关，所以适合求解稠密网的最小生成树。 每一次从已经纳入最小生成树的点出发，找到所连接的未纳入的最短边权点，将其纳入生成树中，直到遍历所有点。 算法流程 将一个图分为两部分，一部分归为点集U，一部分归为点集V，U的初始集合为{V1}，V的初始集合为{ALL-V1}。 针对U开始找U中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到U中，并且从V中删除（注意不能形成环）。 递归执行步骤2，直到V中的集合为空。 U中所有节点构成的树就是最小生成树。 例子 如上图，我们以点为单位，从V1点出发，找到它连接的点V2、V3、V4，其中最短边权为V1-&gt;V3=1，所以我们将V3纳入最小生成树(算法流程所述的集合U)，此时U为{V1、V3}。 然后从V1、V3这个最小生成树所连接的点继续寻找，找到V3-&gt;V6的边权最小，为4，那么纳入最小生成树，继续以上操作，直到遍历完毕。 如果遍历结束后，发现有些点没被访问，就说明无法构成生成树。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const int maxn = 4e+1;//和前面的算法一样使用vector&lt;pair&lt;int,int&gt; &gt;//pair存储to,value//G[i]的i代表fromvector&lt;pair&lt;int,int&gt; &gt;G[maxn];int vis[maxn];void Prim()&#123; int n,e,x,y,z; //最小生成树的权值 int res=0; //输入点、边的数目 cin&gt;&gt;n&gt;&gt;e; for(int i=0;i&lt;e;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; //一般都是求无向图的最小生成树，有向图可以使用最小树形图。 //-1*z 是因为优先队列默认从大到小，我们需要从小到大，随意推入取负的值。 //自己实现结构体可以自己另写cmp G[x].push_back(make_pair(y,-1*z)); G[y].push_back(make_pair(x,-1*z)); &#125; //从第一个点开始，下标为0，或者定义为1，后面也要从1开始。 vis[0]=1; priority_queue&lt;pair&lt;int,int&gt; &gt; Q; for(int i=0;i&lt;G[0].size();i++) &#123; //遍历连接到的点，推入优先队列中，会自动按边权值排序。 Q.push(G[0][i]); &#125; //开始探索 while(!Q.empty()) &#123; //取得队头的点的连接目标点to和权值value int to=Q.top().first; int value=Q.top().second; ///弹出 Q.pop(); //如果已经访问过，也就是说，已经在当前的生成树中/集合U中 if(vis[to]) continue; //否则标记以访问/纳入 vis[to]=1; //加入最小生成树的权值，因为之前我们把每条边的权值当作负数推入，这里减到而不是加上，--得+ res-=value; //遍历当前点可以到达的所有点，推入优先队列。 for(int i=0;i&lt;G[to].size();i++) &#123; Q.push(G[to][i]); &#125; &#125; //如果有点没访问，说明无法构成最小生成树 for(int i=0;i&lt;n;i++) if(vis[i]==0) &#123; cout&lt;&lt;-1&lt;&lt;endl; return; &#125; //输出花费 cout&lt;&lt;res&lt;&lt;endl;&#125; Kruskal算法概述 与prim相反，kruskal算法的注重点是边而不是点，它每次取图中相对权值最小的边，然后将边的两端点纳入集合中。而它基于并查集的思想。（什么是并查集) 算法流程 创建一个数组，为每个节点存储自身的父节点，初始化为自身。也就是刚开始，每个人只指向自己。 我们将边权按从小到大的顺序，排序好边权和对应的两端点。 我们取当前最小边权，把其两端点合并，也就是让他们的存储父节点的数组对应的值指向同一个节点，换句话说，这就是一个两个点组合成的子树了。 一直到所有点都纳入那个子树。 注意的是，合并两个点时，不是简单的赋值点下标，而是应该找到点的最终父节点，再把其赋值给另一端点的数组索引中。 例子 下图是kruskal算法，因为和prim算法用的是同一个原图，所以一起展示。 将边权排序得：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5-&gt;5-&gt;6-&gt;6 这里采用按秩合并。 我们取1，它的两端点是V1、V3 ，将他们合并 {V1,V3}，他们此时记录父节点的数组f[V1]=f[V3]=V1; 同理取2，它的两端点是V4、V6， 将他们合并{V4，V6},他们此时记录父节点的数组f[V4]=f[V6]=V4; 同理取3，它的两端点是V2、V5， 将他们合并{V2，V5},他们此时记录父节点的数组f[V2]=f[V5]=V2; 同理取4，它的两端点是V3、V6， 将他们合并{V3，V6},注意，这时候，V3的父节点即f[V3]的值为V1，而V6的父节点即f[V6]的值为V4，将其赋值，得f[V3]=f[V4]=V1,而V6的父节点依然为V4，但是V6的祖父节点f[V4]是V1了。合并的集合也成{V1、V3 、V6、V4} 此时树为：V1-&gt;V3 ​ \-&gt;V4-&gt;V6 同理取5，把端点V3的祖父节点赋值给另一个断点的祖父节点f[V2]，最后得树： V1-&gt;V3-&gt;V2-&gt;V5 ​ \-&gt;V4-&gt;V6 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const int maxn=1e5+1;//记录父亲节点int father[maxn];//因为我们需要对边权排序，并且需要获得两端点的下标，那么之前的vector&lt;pair&lt;,&gt;&gt; 在这里就用处不大了。struct Edge&#123; int from, to; long long value; //重写操作符，让它进入优先队列时自动按从小到大排序 friend bool operator &lt;(const Edge x,const Edge y) &#123; return x.value&gt;y.value; &#125;&#125;;void init(int n)&#123; for(int i=0;i&lt;=n;i++) &#123; //初始化，让所有点的父节点为自身 father[i]=i; &#125;&#125;//查找组父节点int findRoot(int target)&#123;//如果父节点是自身，说明已经到头了，也就是找到祖父了。 return father[target]==target ?target:findRoot(father[target]);&#125;//判断两个点x和y是不是指向同一个父亲节点，也就是是否在同一个集合中bool isUnion(int x,int y)&#123; return findRoot(x)==findRoot(y);&#125;//整合void comeTogeter(int x,int y)&#123; if(isUnion(x,y)) return ; //把x的祖父节点的父节点设置为y的祖父节点。 father[findRoot(x)]=findRoot(y);&#125;void kruskal()&#123; //点、边 int n,e; //to from worth int x,y,w; //花费 int res=0; //临时Edge对象 cin&gt;&gt;n&gt;&gt;e; //初始化 init(n); priority_queue&lt;Edge&gt; Q; for(int i=0;i&lt;e;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; Edge temp; temp.from=x; temp.to=y; temp.value=w; Q.push(temp); &#125; Edge temp; while(!Q.empty()) &#123; //取队列头，C++提供浅拷贝，直接赋值就好了 temp=Q.top(); Q.pop(); //判断是否在同个集合里，如果在就跳过 if(isUnion(temp.from,temp.to)) continue; //不在，那么整合 comeTogeter(temp.from,temp.to); //加入边权 res+=temp.value; &#125; //判断是不是所有点都在一个集合/生成树中 for(int i=1;i&lt;n;i++) if(!isUnion(0,i)) &#123; res=-1; break; &#125; cout&lt;&lt;res&lt;&lt;endl;&#125; 最大匹配问题 把所有点分成两个左右集合，左右集合里的点可以与对面集合的多个点有边，但不与同集合的点有边。 那么一般会问你求最大匹配和完美匹配。 什么是最大匹配？ ​ 上面谈到一个点可以与对面多个点有边，所以有可能出现左集合中的两点与对面集合的某点都有一条边，那么怎么分配，才能尽量让左右集合里的点一一对应且不重复呢。 ​ 网上很多都是拿男女生牵手的例子，每个男生都对自己心仪的女生们发出牵手请求，如何安排使得尽量满足每个男生都能牵到心仪女生的手，并且不会出现两个男生抢一个女生的 情况。求能牵手成功的最大数量，就是最大匹配。 ​ 什么时完美匹配？ ​ 基于最大匹配，左右集合的所有点都与对面集合有且只有一条边。 ​ 如图Fig.4 ，1-7；2-5；3-6‘4-8；一一对应且不占用同个右边的点。 匈牙利算法概述 发现概述不起来，直接看算法流程吧0 0 算法流程 假设有集合UX、UY，其中UX有多个点连接UY中的n个点，n&gt;=1 从UX的点xi开始遍历，找到它连接的第一个对面点yj，如果这个对面点yj没有被连接，那么我们将该点xi和对面点yi连接。 如果对面点yj被连接了，这时候并不是直接放弃，我们获取对面点yj所连接的点xk,这时候我们对xk进行上述操作，也就是说，我们要找到xk能连接的下一个对面点(抛开yj) ​ 1.如果找不到，说明xk只能连接yj，那么xi只能找它的下一个可连接点。 ​ 2.如果找得到，那么让xk放弃yj，连接其他的点，让xi与yj连接。 OK，这就是主要流程，我们对所有UX中的点按顺序进行上述操作，直到最后一个点，我们就可以找出最大匹配的数量了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//邻接矩阵 值为1 代表i和j可以连接int e[maxn][maxn];//记录当前X集合和Y集合里某点连接的点下标int fromX[maxn],fromY[maxn];//是否访问过int vis[maxn];//X集合的数目和Y的int nX,nY;//尝试搜寻连接 //x：尝试连接的点下标bool line(int x)&#123; //从1到nY遍历，也可以从0到ny-1，看输入情况 for(int y=1;y&lt;=nY;y++) &#123; //如果他们可以连接 并且 Y集合的y点没有被访问过(被连接过) if(e[x][y]&amp;&amp;!vis[y]) &#123; //访问y vis[y]=1; //如果y连接的点=-1，-1代表还没和任何点连接 //或者连接了某点 调用line为这个点递归查找是否可以连接其他点 if(fromY[y]==-1||line(fromY[y])) &#123; //让x和y连接，并在fromX/Y中登记连接对象的下标 fromX[x]=y; fromY[y]=x; //返回可以连接 //注意 如果这个点y是第一次被访问，此时返回true代表它第一次被连接 //如果是被递归调用，则代表它以被允许连接的下一个点连接 return true; &#125; &#125; &#125; //返回不可以连接||不可以被下一个点连接 return false;&#125;//最大匹配int maxMatch()&#123; //连接数n x集合数 y集合数 int n,x,y; //最大匹配的数值 int sum=0; memset(fromX,-1,sizeof(fromX)); memset(fromY,-1,sizeof(fromY)); memset(e,0,sizeof(e)); cin&gt;&gt;n; cin&gt;&gt;nX&gt;&gt;xY; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x&gt;&gt;y; //可以连接 为1 e[x][y]=1; &#125; for(int i=1;i&lt;=nX;i++) &#123; //如果x集合中的i还没有和对面连接 if(fromX[i]==-1) &#123; //格式化访问数组vis 这个是精髓 因为每一次调用line，都可能造成第一次连接的那个点的重新连接，所以vis数组是要被格式化的。 memset(vis,0,sizeof(vis)); //如果可以连接 那么数目加1 if(line(i)) sum++;; &#125; &#125; //如果sum=nX||sum=nY （看题目要求，以X集合为主还是Y集合为主） //如果X/Y集合的所有点都成功连接了唯一的对面集合的点 那么就是完美匹配~ cout&lt;&lt;sum&lt;&lt;endl;&#125; 参考文章]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数字符串的加减乘(含负数)]]></title>
    <url>%2F2019%2FMyAlgorithm-bigNum%2F</url>
    <content type="text"><![CDATA[什么是大数 首先计算机的数据类型所能表示的范围都是有限的。 表数据来源于网络 Type Size 数值范围 无值型void 0 byte 无值域 布尔型bool 1 byte true false 有符号短整型short [int] /signed short [int] 2 byte -32768~32767 无符号短整型unsigned short [int] 2 byte 0~65535 有符号整型int /signed [int] 4 byte -2147483648~2147483647 无符号整型unsigned [int] 4 byte 0~4294967295 有符号长整型long [int]/signed long [int] 4 byte -2147483648~2147483647 无符号长整型unsigned long [int] 4 byte 0~4294967295 long long 8 byte 0~18446744073709552000 有符号字符型char/signed char 1 byte -128~127 无符号字符型unsigned char 1 byte 0~255 宽字符型wchar_t (unsigned short.) 2 byte 0~65535 单精度浮点型float 4 byte -3.4E-38~3.4E+38 双精度浮点型double 8 byte 1.7E-308~1.7E+308 long double 8 byte 而比这些数值范围更大、或者是计算之后超出数值范围的数值都可以成为大数，当我们要对位数达到上百位的大整数进行计算，这些数据类型显然不能满足我们的要求，因此我们需要通过算法来实现这些功能。 正数加法大体思路 思想是采用用字符串表示大数。末尾逐位相加，超十进位。 计算前被加数比加数长度短 为了方便计算，我们在接受到两个需要相加的正整数时，应该将更长位数的大数置上，短的置下。 计算过程1.长度不扩充情况197+13计算 面向下面的大数，从末位开始与上置位的每一位对应数值相加。即表中的下标2。 当前游标 a 1 9 7 b 1 3 ​ a[2]+b[2] =&gt; 7+3=10，发现计算点相加后大于等于10而造成了进位，那么我们应该自身减10，通过为上置位的进位点加1，即9+1=10。至于处理后进位点是否也大于10，我们无需处理，因为我们只需要关心当前位的运算，以及对前一位的影响（即表中的计算点和进位点）。 假设进位点同时也大于10，那么我们在它变成当前点时再进行计算进位就好了。 当前游标 进位点 计算点 a 1 9-&gt;10 7-&gt;10-&gt;0 b 1 3 ​ 计算点计算，10+1=11， 计算点自身减10，发现需要进位，进位点加1。得到结果210。 如果进位时，发现进位点不存在，那么意味着相加后，长度发生了变化，这个时候，如果只是相加运算，我们只需要在上置位字符串a前方加一个’1’就好了，为什么就是’1’呢，因为保证计算点的数值是个数位，无论再怎么大也不会产生进位点进2位的情况。 但是，如果需要被大数相乘的函数调用，就不能简单的加1了，因为相乘后可能出现进位点的数值超过1.当然是为了以防万一，但感觉似乎不会产生进位+2以上的情况。。。 当前游标 进位点 计算点 a 1-&gt;2 10-&gt;11-&gt;1 0 b 1 3 2.长度扩充情况99+1计算 当前游标 进位点 计算点 a 9 9 b 1 a[1]+b[1]=&gt;9+1=10，计算点自身减10，进位点进位，9+1=10，10-10=0 当前游标 进位点 计算点 a 9-&gt;10 9-&gt;10-&gt;0 b 1 计算点a[0]+b[0]=&gt; 10+0=0,，计算点自身减10，10-10=0,进位点进位，发现超出长度，此时在字符串首加’1’，得到结果100。 当前游标 进位点 计算点 a 1 10-&gt;0 0 b 1 代码12345678910111213141516171819202122232425262728293031string bigNumAdd(string a,string b)&#123; //把长的字符串上置位，即换成a if(a.length()&lt;b.length()) &#123; //交换 swap(a,b); &#125; //计算点下标从长度-1开始，取两个i、j变量指向计算点，是为了判断是否结束以及是否超出 for(int i=a.length()-1,j=b.length()-1;i&gt;=0;i--,j--) &#123; //j是字符串b的计算点下标，如果依然大于0，说明还在长度内，可以正常计算 //正常计算的时候利用ascii码性质-'0'获得实际上增加的数值 //如果超出了就加0，即不变 a[i]+=(j&gt;=0?b[j]-'0':0); //发现计算点大于10，需要进位 if(a[i]-'0'&gt;=10) &#123; //如果计算点在a中的位置不是首位，那么进位点正常加上进位数 if(i) a[i-1]+=((a[i]-'0')/10); //如果是首位，也就是说，进位点超出了原本的长度，那么我们在a字符串这里加上进位的值就好了 else a=(char)(((a[i]-'0')/10)+'0')+a; //自身余10 a[i]=((a[i]-'0')%10)+'0'; &#125; &#125; return a;&#125; 减法大体思路 关键思路和加法差别不大，只需要在对应的操作更改以下就好了，当然，在这之前需要对被减数和减数。 计算前1.被减数为负数 由 -a-b = -(a+b) ，其中a&gt;0 得 我们将被减数的负号去掉，然后把被减数和减数当作两个正整数相加，得到的结果加上符号即可。 直接调用上面写的相加函数就好了。 2.被减数是正数 这时候我们要考虑被减数和减数他们的长度关系了,如果被减数长度比减数小，那么结果必然是负数。 由 a-b = –(b-a)，其中a&gt;0 得 我们将被减数和减数交换，让长的减数成为被减数，然后在结果前加上负号。 计算过程100-1计算 当前游标 借位点 计算点 a 1 0 0 b 1 a[2]-b[2]=&gt;0-1=-1,，计算点发现小于0，将自身取绝对值,，借位点借位，借位点减1; 当前游标 借位点 计算点 a 1 0-&gt;-9 0-&gt;-9-&gt;9 b 1 a[1]-b[1]=&gt;9-0=-9,，计算点发现小于0，将自身取绝对值,，借位点借位，借位点减1; 当前游标 借位点 计算点 a 1-&gt;0 -9-&gt;9 9 b 0 这个时候，发现结果的有效长度应该由3变为2，那么我们将第一个字符串元素去掉即可。 当前游标 借位点 计算点 a 9 9 b 0 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354string bigNumDel(string a,string b)&#123; //判断结果是不是负数，根据这个来判断是否在字符串前面加'-' bool isFushu=false; //情况1，被减数是负数，我们将其取正，两数相加，再加上负号 if(a[0]=='-') &#123; a.erase(a.begin()); isFushu=true; return '-'+bigNumAdd(a,b); &#125; //情况2，判断长度，如果被减数短，那么交换，结果必为负数 if(a.length()&lt;b.length()) &#123; isFushu=true; swap(a,b); &#125; //与加法的遍历方法一致 for(int i=a.length()-1,j=b.length()-1;i&gt;=0;i--,j--) &#123; //与加法的运算一致 a[i]-=(j&gt;=0?b[j]-'0':0); //如果小于0 if(a[i]&lt;'0') &#123; //取正数，为什么是加10呢？ 举个例子 //a[i]='0'-1 即 数值结果为-9 取正应该得9 //a[i]+=10 -&gt;'0'-1+10= '0'+9 ='9' a[i]=a[i]+10; //如果还在有效长度内 if(i) &#123; //借位 a[i-1]--; &#125; //否则不在有效长度内 else if(j==0) &#123; //结果为负数 isFushu=true; &#125; &#125; &#125; //开始去首位0操作 if(a[0]=='0') &#123; while(a[0]=='0') &#123; a.erase(a.begin()); &#125; &#125; //判断是否负数来加符号 return isFushu?'-'+a:a;&#125; 乘法大体思路 相信大部分人首算乘法的时候，都习惯从末尾开始乘，然后进位，但是要仔细考虑，进位之后，得到的数据应该缓存起来，最后相加而不是直接在原字符串上改变进位点的数值。也就是说 567 * 3 =21+180+1500 . 上面这种末尾相乘方法其实效率并不高，每个数字之间相乘的结果都要缓存一次，而其实我们只需要首位相乘就可以解决多次缓存的问题了，即从ab 中，对a的首位开始进行乘法运算，因为从前往后运算，计算点影响的值只会是前一位进位点，后面的都不会被影响到，所以只需要新建一个临时字符串c赋值a的元素，然后直接在c上更改就好。 也就是 567 3 =1701 计算过程计算前 乘法运算也需要和前两种运算一样，要求长度更长的置上方。 1.统计两个乘数是否为负数 负负得正，正负得负，将负号统计并且移除，在最后结果上根据情况加负号。 2.非特殊情况 新建一个字符串res，用于存储结果，然后在b的每位数字开始相乘时，新建一个临时字符串，存储这个数值对a乘法后的结果，然后加入res中。 当前游标 res a 4 5 7 b 3 4 temp 4 5 6 为了方便演示，我们从b的首位开始逐个对照a的首位开始算，3*4=12，先把2存储在temp的对应位置中。 在代码中，无论从b的首位还是末位开始遍历，只要从a的首位开始计算就行，只要加’0’的次数正确，结果不变。 当前游标 进位点 计算点 a 4 5 6 b 3 4 temp 4-&gt;2 5 6 然后12是大于10的，这时候我们需要在temp字符串前加入需要进位的数值 ，即 ‘1’。 当前游标 进位点 计算点 a 4 5 7 b 3 4 temp 1 2 5 6 接着对a的下一位进行运算，即3*5=15，对应计算点的temp数值改成5，进位点进位1。 当前游标 进位点 计算点 a 4 5 7 b 3 4 temp 1 2-&gt;3 5-&gt;5 6 同理，对a的下一位继续运算，即3*7=21，对应计算点的temp数值改成1，进位点进位2。 当前游标 进位点 计算点 a 4 5 7 b 3 4 temp 1 3 5-&gt;7 6-&gt;1 此时temp字符串的值应为’1’ ‘3’ ‘7’ ‘1‘，重点来了，我们应该记住在b字符串运算位距离末位的值，随后根据这个值，对temp末位逐个加’0’ 因为例子中b长度为2，当前从首位开始算， 所以相差1位，那么在temp末尾加1个‘0’ temp=”13710”,把他加入res,用上述的大数相加运算。 同理把4和457进行一次运算，得到的新temp也加入到res中 最后根据前面统计的负号个数，对结果进行加负号处理。 3.特殊情况 如果按照首位逐个相乘，如果遇到如699这样，即第一次运算 60 9=540 , 随后运算 9 * 9 =81 ,发现进位点4+8 超过10 这个时候怎么处理呢。 很简单，无视就好，它会在被调用大数相加运算的时候，自动向前进位的。 此时temp=’5’ ‘12’ ‘1’。 我们bigNumAdd(res,temp)。 在内循环中，因为12&gt;10 ，会把1加到5身上。结果为621 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263string bigNumMul(string a,string b)&#123; //统计负数个数 int fushu=0; string resStr; if(a[0]=='-') &#123; fushu++; a.erase(a.begin()); &#125; if(b[0]=='-') &#123; fushu++; b.erase(b.begin()); &#125; if(a.length()&lt;b.length()) &#123; swap(a,b); &#125; //面向b的末尾开始 for(int i=b.length()-1;i&gt;=0;i--) &#123; //新建临时字符串 string tempStr; //复制严肃，这里其实只要长度相等就可以了，不需要元素一致 tempStr.assign(a); //计算当前b的计算位距离末尾的长度，决定加0次数 int zeroB=b.length()-i-1; //从a的首位开始，因为这里复制了a的元素，直接从temp上索引 //如果上面的temp只复制了长度，那么就要从a本身索引 for(int j=0;j&lt;tempStr.length();j++) &#123; //相乘 int res=(tempStr[j]-'0')*(b[i]-'0'); //自身更正 tempStr[j]=res%10+'0'; //相乘结果大于10 if(res&gt;=10) &#123; //计算点在temp/a的首位，也就说进位点会超出范围 if(j==0) &#123; //在temp前加上进位的值的ascii码 tempStr=(char)((res/10)%10+'0')+tempStr; //长度加1，我们的j也要相对后移 ++j; &#125; else &#123; //否则正常进位 tempStr[j-1]+=(res/10)%10; &#125; &#125; &#125; //加'0'操作 for(int k=0;k&lt;zeroB;k++) tempStr+='0'; //与res相加 如果出现了特殊情况，会在其中被进位修正。 resStr=bigNumAdd(resStr,tempStr); &#125; //判断负数情况，加负号 return fushu==1 ? '-'+resStr:resStr;&#125; 总结 加法减法从被加/被减末尾开始算。 减法/乘法需要考虑负数情况。 乘法从被乘数的首位开始算。 加法运算要注意进位操作，减法要记得减0操作，乘法要加0操作。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立手游-19年-3月]]></title>
    <url>%2F2019%2FMyGame-19-Mar%2F</url>
    <content type="text"><![CDATA[[TOC] 本月主要开发内容放弃了帧动画，使用Anima2D制作的骨骼动画，花了不少时间写了自己的第一个开源背包框架，同时用于重构游戏里的背包系统。 成果图片以及描述Anima2D骨骼动画的简单使用可以参考我的另一篇文章Unity Anima2D编辑器的轻量骨骼动画和换装使用​ 手持武器的更换效果 棍类武器的蓄力攻击动画 长矛类武器的蓄力攻击动画 刀类武器的蓄力攻击动画 下月任务将背包系统重构完善，同时把框架的存储功能更新，把所有物品图标绘制完毕。尽可能编写怪物AI，因为还有计网课设和团队游戏开发，所以怪物AI行为树的进度可能较慢。]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>独立游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Anima2D编辑器的轻量骨骼动画和换装使用]]></title>
    <url>%2F2019%2FMyLearn-Anima2D%2F</url>
    <content type="text"><![CDATA[[TOC] &lt;学习记录&gt;Unity Anima2D编辑器的轻量骨骼动画和换装使用前言​ 前不久觉得骨骼动画难弄而选择帧动画，现在发现，一个人制作帧动画的工作量真的大，特别是发现需要换肤功能的时候，目前没有找到可以让同一个帧动画替换特定像素达到换肤效果的简易方法（shader可以简单换色，但是如果要有特别的形状图案就很复杂了），于是乎找到了一些关于Unity5.x版本之后自带的anima2D骨骼动画系统的一些文档，决定弃用帧动画使用骨骼动画。 ​ 这篇来做一个简易演示。 图片准备​ 将精灵图拖到Unity之后设置属性，因为画的时候是以1像素为单位，所以选择了FilterMode为Point。随后通过SpriteEditor将图片切割好，注意这里一定要规定好切割区域的大小，也就是规定如所有头部、身体精灵图的共同切割大小，以便骨骼的绑定不会产生换肤的图片偏移，对碰撞体有要求的同样可以设置得精细一点。 精灵网格和骨骼设置​ 将必要的头、身体、腿的图片拖入视图后，摆好位置，创建父物体Player，对其一一设置精灵网格，右键2D Object-&gt;SpriteMesh ​ 随后可以在父物体Player下创建骨骼，右键2D Object-&gt;Bone ​ 将创建的骨骼与摆好的图片对齐，如果在骨骼下创建骨骼，会生成子骨骼，子骨骼会随着父骨骼移动。 ​ 骨骼绑定​ 设置好骨骼，图片也对应好之后，将网格与骨骼绑定，点击视图中的头，查看监视面板，创建了网格会绑定的两个组件分别是SpriteMeshInstance和SpriteMeshRenderer，本篇只讲解SpriteMeshInstance的用法，SpriteMesh是精灵网格，可以在面板上设置，也可以在代码上设置，这也是本篇换装的重要途径，随后是颜色、材质、层级、Set bones骨骼设置，我们将对应的骨骼拖入这里，注意，拖入带有子骨骼的骨骼，会将子骨骼一起绑定，若子骨骼需要与其他图片绑定，请删除掉，以免冲突。 ​ 拖入以后并没有直接绑定成功，这时候我们需要通过Anima2D编辑器绑定骨骼，菜单栏Winodws-&gt;Anima2D-&gt;SpriteMesh Editor，点击Bind按钮将自动的计算骨骼的权重。点击Apply即可绑定，也可以通过Weight Editor设置影响程度，在此之前也可以在编辑器上通过鼠标来划分你的蒙皮需求。如果一张图片上有多个骨骼，那么你就要设置每个骨骼在某些三角形上的权重，让骨骼动作时图片动作的更逼真。而个人不需要过于精细，因此本篇没有特定设置蒙皮划分。 ​ 绑定骨骼以后，可以在视图界面控制骨骼，查看是否绑定成功。 IK绑定​ 反向力学系统，一般我们是通过骨骼的动作去控制图片，设置IK并绑定骨骼的话，通过操作IK控件，骨骼也会随着移动。这样我们可以更方便的做一些动画了。（展示图没有绑定武器，所以效果并不明显，但是骨骼效果随着IK的移动而移动很直白） ​ IK动画分两种:IK CCD、IK Limb。​ IK Limb适合肢体骨骼动画。IK CCD适合更长的骨骼。本篇使用Limb，在父物体Player下创建IK，右键2D Object-&gt;IK Limb ，在视图将IK部件移动到合适的位置之后，监视面板绑定骨骼，在这里，我们可以想像IK为关节，我们人体控制关节，骨骼也会随之移动，所以将IK绑定到对应的骨骼就好了。 骨骼动画和换装​ 利用Animation编辑器，新建anim动画，对骨骼进行操作录制即可，然后播放的时候，通过改变对应SpriteMeshInstance的精灵网格即可。 ​ 注意，你要对所有提供换装的精灵网格对它对应骨骼进行单独的绑定！ ​ 以下为本篇的换装样例代码 1234567891011121314151617181920212223242526using Anima2D;using System.Collections;using System.Collections.Generic;using UnityEngine;public class DebugBone : MonoBehaviour &#123; private SpriteMeshInstance body; private Object[] clothesMesh; int key = 0; // Use this for initialization void Start () &#123; body = GameObject.Find(&quot;身体&quot;).GetComponent&lt;SpriteMeshInstance&gt;(); clothesMesh = Resources.LoadAll(&quot;SpriteMesh/clothes&quot;); &#125; // Update is called once per frame void Update () &#123; if (Input.GetKeyDown(KeyCode.A)) &#123; key++; key = key % 6; body.spriteMesh = (SpriteMesh)clothesMesh[key]; &#125; &#125;&#125; 参考文章和视频​ 视频： 【游戏美术难于上青天】 系列 ​ 文章： Anima2D官方中文使用手册（对应Anima2D1.1.4）]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>问题以及解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Unity3D引用某些DLL发布之后可能出现的错误]]></title>
    <url>%2F2018%2FMyIssue-Solution-DLL%2F</url>
    <content type="text"><![CDATA[[TOC] 目的：在肝专业课设的时候，需要用的EPPLSUE.DLL写表格文件时，以及想用IRONPYTHON调用pyhton脚本时遇到了这些问题，在这里总结一下 主要问题：1.引用第三方类库之后，无法发布。提示引用的类库不支持。 2.发布之后，使用到对应第三方类库内容时，发生错误，但是在编辑器里却没错误。 问题可能原因和解决方法：问题1：可能原因：目前遇到的大部分是都是因为Unity的NET版本和要使用的类库不一致导致的，虽然目前Unity的设置中支持3.5和4.X，但实际上使用那些4.0以上NET支持的类库，大部分就会出现VS编译器里无报错，但Unity编辑器里报错的问题，或者如问题1那样，无法发布。 解决方法：1.尽量使用非4.XNET支持的第三方类库，总能找到课替代的或者低版本(最后我还是没用上iron Python ,选择把python写成web后端了= =)。 2.在发布页面的Player Setting中设置使用的NET版本，更改Unity为.NET 4.X ，但大部分第三方库依然不支持 3.老老实实使用.NET3.5，并选择API为.NET2.0而不是它的子集2.0 Subset 据说后面4.X会支持的更好，3.5也会被移除，希望能完全支持这些类库吧。 问题2：可能原因：我遇到的是在Unity编辑器里生成表格是可以的,但是发布之后，却失败了，通过异常捕获发现出现不支持IBM347编码，其实是缺少Unity编辑器里自带的一些文件。 解决方法：把Unity\Editor\Data\Mono\lib\mono\unity下的L18N相关的所有.dll赋值到当前项目的Assets文件夹下，保存再发布就可以解决了。 以上大部分分析来源于自己，因此可能不是百分百正确，勿在意。]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>问题以及解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立手游-11月]]></title>
    <url>%2F2018%2FMyGame-Nov%2F</url>
    <content type="text"><![CDATA[[TOC] 本月主要开发内容绘制大部分UI界面所用的素材、绘制主角样板和一些动画，然后对原来的UI布局根据像素风进行了一些修改。 成果图片以及描述板子用的是ctl672，绘制软件有PS和piskel，没有什么美术功底强上，在piskel上不支持压感，所以画主角样板的时候都是现在PS上画 再转到piskel做帧动画的。 总览 1.人物属性表每个两张，一张填满一张空，用填充分那个是控制数值 空san 2.电子表预览打算6/12min现实时间为游戏的一天，用uv动画去控制时间流动 3.人物待机图在piskel上绘制帧动画，导出xy行列的图集，然后在Unity上自己分割，拖动就可以形成动画 人物待机图* 待更新完毕]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>独立游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立手游-10月]]></title>
    <url>%2F2018%2FMyGame-Oct%2F</url>
    <content type="text"><![CDATA[[TOC] 本月主要开发内容UI框架、UI布局、美术制作、游戏物品数据json化、主角存档格式等 成果图片以及描述对于一个没有美术资源的游戏开发前期，打算先从UI入手由于截图软件问题，上面有大概0.5cm的高度矩形被截出了 但不影响观看 1.操作方式预览 左手移动 范围为2/5的左边屏幕右手攻击 范围固定 2.背包预览还没在主角数据里添加，所以暂时为空 3.合成系统预览主要用到Toggle来选择合成表点击目标物品，右侧会出现详情和合成所需的物品预览以及对应的消耗个数和已有个数 4.数据持久化JSON我也只是刚接触不久，用的litjson，因为我把所有物品都一股脑写入一个json里（手写。。。），解析不能用泛型，只好手动针对性解析(可能是我没学会其他更方便的方法)顺便加了AES加密主角的存档数据我也写了初版，并且加了脚本测试测试为：向主角数据添加物品持有、然后在背包中查阅 (在电脑上编辑器中的测试，在电脑录制的gif 比手机的更清晰顺滑一些) 本月总结 其实说是本月，不如说是9月和10月:grimacing:，这些是用了两个月的课余时间慢慢写的，但考虑到现在才开通博客记录，所以合二为一了。 设计这些低端UI还是相对容易的，因为轻量级的UI框架之前看视频学过倒是卡了摇杆设计上，EasyTouch要付费，网上找了一些别人的源码，自己照着造了一次适合的轮子，发现左右手不能同时使用，会卡住，最后知道了安卓有多点触控。。。用了Torch去判断才可以 在json数据的定义上，也许是开发经验太少，我甚至用到了伤害计算弄成数组。。。1234567891011121314&#123; "id": 304, "type": "bullet", "pose": 4, "name": "毒箭", "compose": [ 2, 1, 14, 1, 39, 1, 62, 1 ], "effect": "", "intro": "不要舔它", "isRealinjury": 1, "dT": [ 60, 0, 20, 1, 20, 1 ], "san": 0, "repair": [], "durability": 1 &#125; 就比如上面的。。。dT就是damageTime缩写，0为基础伤害，1为一秒的持续伤害:expressionless: 不在意这些细节啦，双11买了数位板，准备开肝素材，顺便贴下自己做的个人logo:yum:]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>独立游戏</tag>
      </tags>
  </entry>
</search>
